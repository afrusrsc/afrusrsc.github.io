<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Delphi on 慢步道人</title>
    <link>https://afrusrsc.github.io/tags/delphi/</link>
    <description>Recent content in Delphi on 慢步道人</description>
    <generator>Hugo -- 0.125.7</generator>
    <language>zh</language>
    <copyright>2017-2025 Jesse Jin</copyright>
    <lastBuildDate>Tue, 12 Jul 2022 21:47:37 +0800</lastBuildDate>
    <atom:link href="https://afrusrsc.github.io/tags/delphi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>idhttp POST的坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_idhttp_post/</link>
      <pubDate>Tue, 12 Jul 2022 21:47:37 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_idhttp_post/</guid>
      <description> 从其它平台迁移而来
坑 最近要和一个平台提供的http接口进行对接，由于服务不是部署在公网上的，所以没办法直接在开发环境下直接调试，又不能在客户的测试机上部署开发环境，只能选择加日志这种古老的方法。
在对接过程中却出现了莫名其妙的问题：POST的内容是一样的，但返回的内容却不一样，更准确点说是有的接口返回正常有的返回不正常（其实还是测试有限，测试多的话还会出现同一接口有的请求正常有的不正常）。
平台提供的word接口文档写得真的是……一言难尽，由此也对接口的准确性、可靠性等保持怀疑。不过，这次用我们提供的数据，平台方给出了相应的中间结果（中间结果一致）及返回结果，还有postman和curl的测试截图，充分证明接口以及数据请求是没有问题的。
在客户测试机上装了curl测试也证明接口没问题。（问为什么一开始没想到用curl？因为windows默认没有，而且utf8还会显示乱码，习惯性的就没想起来用）
请求头也改了，没用一样的效果。
最后实在找不出问题，就只能进行TCP抓包了，这一抓还就真抓出问题了：
原始数据
1 /knwRBV5D4Qtk7RzoQhtBUSMXQig3zURYmeSQBB17NVr6qddCkTxS7e0oO/qfNCkuX14vGsxEoLLN4KS5vtQWDs5on+GeAE5LadCZuHDCe7M25GitNKqnsCfC5qVmti1LyxLxYg2JpLP6GylWERWBOmbP2yO2Aiuey6V526rlRICnidM1W0A4ziNMSjGCng0n5Md4so/RjswNdcE4C5F0kBEGRWH0ZK+QdkZMs4zL84Pu/aiSMpiID9Mm+jtdLZuk0m0UtEd1MmxnU2KPdQz9057JAtM5LIj4YenZl3J86OPWtb9DE6a+410CWBawZY1vItZ+43Kh/QPnkw6Qe4toXRnF84X/ijtiWkTt4moJT87xDpf/TXEd7LRkddWPRRGF3KHnUKacLySwMmXkU6CQMazE1Kh1ZGML6zl1weaq4xVulFwhGfp2XKzYdZfT3uq4yqVr30AaEqYoy2/P1MkhTs5on+GeAE54r939gdklpefguipLJVBpWk/B5S9QsCDxDbfGYNxJo3rIAxDL7sjjlmVL1RjU86sHsNIbmRii7dL70pf5qcIMJzryGmtn94SAE2HjLw0abfr0A9amRsdIzs5on+GeAE5RIxdCKDfNRFnPqLzNU5stMSDcpuafJpNhUXDbQOMlPungXJHHZAgbE2XtoI4geIRYjiyBLDMQuB0l5WvfDhpRnYo1VaEu7J0tRuezwUplK61p4I8giLwAtO+yNMRV+J65g9XaT8vmf8gxmtK3wEFrve7HwsYH0QhlQQiMilY/JVsiHZS6+ID/w== 发送后抓到的却是
1 /knwRBV5D4Qtk7RzoQhtBUSMXQig3zURYmeSQBB17NVr6qddCkTxS7e0oO/qfNCkuX14vGsxEoLLN4KS5vtQWDs5on+GeAE5LadCZuHDCe7M25GitNKqnsCfC5qVmti1LyxLxYg2JpLP6GylWERWBOmbP2yO2Aiuey6V526rlRICnidM1W0A4ziNMSjGCng0n5Md4so/RjswNdcE4C5F0kBEGRWH0ZK+QdkZMs4zL84Pu/aiSMpiID9Mm+jtdLZuk0m0UtEd1MmxnU2KPdQz9057JAtM5LIj4YenZl3J86OPWtb9DE6a+410CWBawZY1vItZ+43Kh/QPnkw6Qe4toXRnF84X/ijtiWkTt4moJT87xDpf/TXEd7LRkddWPRRGF3KHnUKacLySwMmXkU6CQMazE1Kh1ZGML6zl1weaq4xVulFwhGfp2XKzYdZfT3uq4yqVr30AaEqYoy2/P1MkhTs5on+GeAE54r939gdklpefguipLJVBpWk/B5S9QsCDxDbfGYNxJo3rIAxDL7sjjlmVL1RjU86sHsNIbmRii7dL70pf5qcIMJzryGmtn94SAE2HjLw0abfr0A9amRsdIzs5on+GeAE5RIxdCKDfNRFnPqLzNU5stMSDcpuafJpNhUXDbQOMlPungXJHHZAgbE2XtoI4geIRYjiyBLDMQuB0l5WvfDhpRnYo1VaEu7J0tRuezwUplK61p4I8giLwAtO+yNMRV+J65g9XaT8vmf8gxmtK3wEFrve7HwsYH0QhlQQiMilY/JVsiHZS6+ID/w=%3D 最后的=被转码为%3D了！
解决 找到原因就好办了
1 2 //idhttp.HTTPOptions := [hoForceEncodeParams]; //默认强制对参数进行转码 idhttp.HTTPOptions := []; //去掉就OK了 </description>
    </item>
    <item>
      <title>安装 CodeTyphon</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/codetyphon_install/</link>
      <pubDate>Sun, 07 Feb 2021 09:29:48 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/codetyphon_install/</guid>
      <description>从其它平台迁移而来
一直想找个开源的可以商用的Delphi的替代品，能跨平台了最好。开始时试过Lazarus，和D7还真是挺像的，不过用惯了XE，还是想找个习惯相似的IDE，扒拉下论坛后发现了CodeTyphon，就想着试一下。
下载 下载就不多说了，网上很容易找到，而且官方wiki写得也很好，英文好的可以直接看，像我这样的英语渣渣，还是有必要慢慢去啃的。
CodeTyphon下载后只有一个CodeTyphonIns.zip的压缩包，无论是Windows、Linux还是MacOS，安装包都是它，因为不管在哪个平台上安装，都是要编译的。
安装 解压CodeTyphonIns.zip得到CodeTyphonIns
在Windows平台，以管理员方式运行install.bat；在类unix平台，先cd CodeTyphonIns，再sudo ./install.sh
出现以下界面，输入0
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ==================================================== CodeTyphon Studio Version 7.30 (GEN 7) Installation for Linux-Solaris-Openindiana-MacOS FreeBSD-NetBSD-OpenBSD-DragonFly ==================================================== -----WARNING------ WARNING ----WARNING------- You tryng to install CT as root This is NOT the correct procedure. You MUST start CodeTyphon Installation as normal user with sudo root privileges --------------------------------------------- 0) Install CodeTyphon Studio (remove old first) 1) Update CodeTyphon Studio 2) Remove CodeTyphon Studio 9) Exit &amp;gt;&amp;gt;&amp;gt; Select an action (press 0.</description>
    </item>
    <item>
      <title>自学RTC——DualServer</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc_dual_server/</link>
      <pubDate>Sun, 22 Nov 2020 14:54:39 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc_dual_server/</guid>
      <description>从其它平台迁移而来
在窗体上放4个TRtcHttpServer，依次设置ServerPort为：80、443、8080和8090，并分别命名为HS80、HS443、HS8080和HS8090
再放3个TRtcDualDataServerLink到窗体上，分别命名为DL80and443、DL8080and8090和DLall
设置DL80and443的Server属性为HS80，Server2属性为HS443；设置DL8080and8090的Server属性为HS8080，Server2属性为HS8090
设置DLall的Link属性为DL80and443，Link2属性为DL8080and8090
再放1个TRtcDataProvider到窗体上，设置Link属性为DLall，并在OnCheckRequest事件里写上代码：
1 2 3 4 5 with TRtcDataServer(Sender) do begin Accept; Write(&amp;#39;you are on Server &amp;#39; + ServerPort); end; 在窗口OnShow事件里启动所有TRtcHttpServer，在OnClose事件里停止所有TRtcHttpServer
编译运行
在浏览器里分别访问http://localhost:80、http://localhost:443、http://localhost:8080、http://localhost:8090
注意：TRtcDualDataServerLink只能选择设置Server*或Link*！</description>
    </item>
    <item>
      <title>RTC组件关系图</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc/</link>
      <pubDate>Tue, 10 Nov 2020 21:26:27 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc/</guid>
      <description>从其它平台迁移而来</description>
    </item>
    <item>
      <title>自学RTC——BrowserUpload</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc_browser_upload/</link>
      <pubDate>Tue, 10 Nov 2020 20:04:07 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc_browser_upload/</guid>
      <description>从其它平台迁移而来
核心代码 OnCheckRequest事件中的代码： 1 2 3 with TRtcDataServer(Sender) do if Request.FilePath.Equal(0, &amp;#39;UPLOAD&amp;#39;) then Accept; OnDataReceived事件中的代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 var fname: string; cnt: integer; begin with TRtcDataServer(Sender) do begin if Request.</description>
    </item>
    <item>
      <title>自学RTC——ServerLesson4</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson4/</link>
      <pubDate>Sat, 07 Nov 2020 23:47:54 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson4/</guid>
      <description>从其它平台迁移而来
对于上节的示例中，比较适合发送小文件，若直接用于发送大文件的话，很容易把服务器的内存资源耗尽。当请求大文件时，可以限制每次发送大文件时使用的内存大小（例如16000 B）。
打开上节的工程
修改RtcDataProvider3的OnCheckRequest事件：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var fname: string; begin with TRtcDataServer(Sender) do begin fname := GetFullFileName(Request.FileName); if (fname &amp;lt;&amp;gt; &amp;#39;&amp;#39;) and (File_Exists(fname)) then begin Accept; Request.Info[&amp;#39;fname&amp;#39;] := fname; Response.ContentLength := File_Size(fname); WriteHeader; end; end; end; 修改RtcDataProvider3的OnDataReceived事件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var fname: string; len: cardinal; begin with TRtcDataServer(Sender) do if Request.</description>
    </item>
    <item>
      <title>自学RTC——ServerLesson3</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson3/</link>
      <pubDate>Sat, 07 Nov 2020 20:27:36 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson3/</guid>
      <description>从其它平台迁移而来
/test.txt 打开上节的工程
添加组件RtcDataProvider3并设置Server属性为RtcHttpServer1，设置CheckOrder属性为900，使得RtcDataProvider3所处理的请求在其它请求之后（CheckOrder越小越先处理）
在当前exe所在路径下创建一个data文件夹，并在该文件夹内新建一个有内容的test.txt，然后编写一个GetFullFileName函数，用于从请求中提取文件名并转化为本地文件名
1 2 3 4 5 6 7 8 9 10 11 12 13 function GetFullFileName(fname: string): string; var DocRoot: string; begin DocRoot := ExtractFilePath(AppFileName); if Copy(DocRoot, length(DocRoot), 1) = &amp;#39;\&amp;#39; then Delete(DocRoot, length(DocRoot), 1); DocRoot := DocRoot + &amp;#39;\data&amp;#39;; fname := StringReplace(fname, &amp;#39;/&amp;#39;, &amp;#39;\&amp;#39;, [rfreplaceall]); Result := ExpandFileName(DocRoot + fname); if UpperCase(Copy(Result, 1, length(DocRoot))) &amp;lt;&amp;gt; UpperCase(DocRoot) then Result := &amp;#39;&amp;#39;; end; 在RtcDataProvider3的OnCheckRequest事件中写上代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 var fname: string; begin with TRtcDataServer(Sender) do begin fname := GetFullFileName(Request.</description>
    </item>
    <item>
      <title>自学RTC——ServerLesson2</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson2/</link>
      <pubDate>Thu, 05 Nov 2020 23:34:37 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson2/</guid>
      <description>从其它平台迁移而来
/SQUARE 打开上节的工程
添加组件RtcDataProvider2并设置Server属性为RtcHttpServer1
在RtcDataProvider2的OnCheckRequest事件中写上代码：
1 2 3 with TRtcDataServer(Sender) do if UpperCase(Request.FileName)=&amp;#39;/SQUARE&amp;#39; then Accept; 在RtcDataProvider2的OnDataReceived事件中写上代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var line:integer; begin with TRtcDataServer(Sender) do if Request.Complete then begin Write(&amp;#39;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;#39;); Write(&amp;#39;Here comes a table of square values ... &amp;lt;br&amp;gt;&amp;#39;); for line:=1 to 100 do begin // 使用3个 write 和使用1个效果是一样的 Write(&amp;#39;Square of &amp;#39;+IntToStr(line)+&amp;#39; = &amp;#39;); Write(IntToStr(line*line)); Write(&amp;#39;&amp;lt;br&amp;gt;&amp;#39;); end; Write(&amp;#39;.</description>
    </item>
    <item>
      <title>自学RTC——ServerLesson1</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson1/</link>
      <pubDate>Thu, 05 Nov 2020 20:51:13 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson1/</guid>
      <description>从其它平台迁移而来
RTC全称RealThinClient，据说是Delphi做三层的神器之一，虽然听说已久，却始终未好好研究过，而且安装包里带的有示例源码，于是乎，索性拿这些源码开这么个系列，督促下自己。
步骤 创建一个新工程
从RTC Server组件页中找到RtcHttpServer组件放到窗体上
设置RtcHttpServer1的ServerPort属性为80
在窗体的OnCreate事件里写上代码：
1 RtcHttpServer1.Listen; 从RTC Server组件页中找到RtcDataProvider组件放到窗体上
设置RtcDataProvider1的Server属性为RtcHttpServer1
在RtcDataProvider1的OnCheckRequest事件中写上代码：
1 2 3 with Sender as TRtcDataServer do if UpperCase(Request.FileName)=&amp;#39;/TIME&amp;#39; then Accept; 在RtcDataProvider1的OnDataReceived事件中写上代码： 1 2 3 with Sender as TRtcDataServer do if Request.Complete then Write(&amp;#39;Current time is: &amp;#39;+TimeToStr(Now)); 编译并运行
打开浏览器，访问网址http://localhost/time
示例源码 核心源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 procedure TForm1.</description>
    </item>
    <item>
      <title>FireDAC的数据连接池</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/firedac_fdconnection_pool/</link>
      <pubDate>Tue, 11 Aug 2020 21:59:09 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/firedac_fdconnection_pool/</guid>
      <description>从其它平台迁移而来
之前就想搞个数据连接池，结果太麻烦就放弃了，不想却在TFDConnection中看到了Pooled属性，就一路挖了下来，还真就是那么回事！
TFDManager 之前只知道，放上TFDManager控件后，什么都不用做，就可以在别的单元引用该单元后直接连接到TFDConnection控件了；现在，数据连接池还是要通过TFDManager来实现。
设置数据连接池参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //指定动态库 FDPhysMySQLDriverLink.VendorLib := &amp;#39;libmysql.dll&amp;#39;; //设置连接参数 with FDManager.ConnectionDefs.AddConnectionDef do begin Name := &amp;#39;MySQL_Conn&amp;#39;; Params.DriverID := &amp;#39;MySQL&amp;#39;; Params.Add(&amp;#39;CharacterSet=csUtf8mb4&amp;#39;); Params.Add(&amp;#39;Server=127.0.0.1&amp;#39;); Params.Add(&amp;#39;Port=3306&amp;#39;); Params.Database := &amp;#39;test&amp;#39;; Params.UserName := &amp;#39;root&amp;#39;; Params.Password := &amp;#39;123456&amp;#39;; Params.PoolMaximumItems := 10; Params.Pooled := True; end; 以上是以MySQL为例，其它数据库参照即可。
打开连接池 1 FDManager.Open; 获取连接 1 2 FDConnection.ConnectionDefName := &amp;#39;MySQL_Conn&amp;#39;; FDConnection.Connected := True; 归还连接 FDConnection直接放到窗体上，或动态创建，写上如下代码即可，无需在设计器里设置任何东西。</description>
    </item>
    <item>
      <title>从.h头文件到.pas单元</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/h2pas/</link>
      <pubDate>Mon, 04 May 2020 23:42:53 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/h2pas/</guid>
      <description>从其它平台迁移而来
由于长期使用Delphi开发，又与硬件打交道比较多，不可避免地要与标准C动态库进行对接，而往往厂家提供的SDK又偏偏没有Delphi的，无奈也就只好自己改写.h头文件了。写得多了，也就有了一点点心得，在这里就分享出来，也好与大家互相交流、学习。
知识点 标准C动态库使用的都是单字节字符。
Delphi 2007以前默认使用的是单字节字符，即Ansi编码，也就是说Char = AnsiChar、PChar = PAnsiChar、string = AnsiString；Delphi 2009以后使用的是双字节字符，即Unicode编码，也就是说Char = WideChar、PChar = PWideChar、string = WideString。为了保证改写后的.pas文件适用于Dephi的各个版本，应避免使用Char、PChar、string这种类型不明确的数据类型（通常情况下使用AnsiChar、PAnsiChar、AnsiString即可，但特殊情况要特殊处理）。
@string[1]才是字符串首地址。
Delphi中可以把AnsiString当作缓冲区来使用，某些情况下比array of Byte要方便得多。
对字符串变量第一次使用SetLengh时会重新分配内存，第二次使用时，若设定的长度比第一次小，则只会进行截断而并不改变已写入的内容，该特性在使用API返回字符串时非常好用。
Delphi中的record是进行过字节对齐的，执行效率高，但占用空间比看到的会略大；packed record是未进行过字节对齐的，执行效率略低，但占用空间与看到的保持一致。也就是说，Delphi中packed record才是与C中的struct等同。
在Delphi中packed record配合case可以实现C中的union，具体是否等同还要看实际定义的字节是否一致（需要对每种数据类型占用的空间十分熟悉）。
标准C动态库的API函数或回调函数，在Delphi中均要使用stdcall;来修饰，以确保传参顺序一致。
数据类型对应关系 C/C++ 类型 Delphi 基本类型 Delphi Window 单元类型 说明 char ShortInt / Int8 8位有符号整型 char* PShortInt unsigned char / BYTE Byte / UInt8 UCHAR 8位无符号整型，字节型 unsigned char* PByte LPBYTE / PUCHAR short SmallInt / Int16 SHORT 16位有符号整型 short* PSmallInt PSHORT unsigned short Word / UInt16 WORD 16位无符号整型 unsigned short* PWord PUSHORT int / long Integer / Longint / Int32 LONG 32位有符号整型 int* / long* PInteger / PLongInt PLONG unsigned / unsigned int / unsigned long Cardinal / LongWord / UInt32 DWORD / UINT / ULONG / ULONG32 32位无符号整型 unsigned int* / unsigned long* PCardinal / PLongWord / PUint32 PDWORD / PUINT / PULONG long long / __int64 Int64 LONG64 / LONGLONG 64位有符号整型 long long* / __int64* PInt64 PLONG64 unsigned long long / unsigned __int64 UInt64 ULONG64 / ULONGLONG / DWORD64 64位无符号整型 unsigned long long* / unsigned __int64* PUInt64 PULONG64 / PULONGLONG / PDWORD64 float Single / Float32 32位单精度浮点型 float* PSingle double Double / Float64 64位双精度浮点型 double* PDouble long double Extended 10字节浮点型 char AnsiChar 单字节字符 char* PAnsiChar LPSTR / LPCSTR char** PPAnsiChar wchar_t / WCHAR WideChar WCHAR 双字节字符 wchar_t* PWideChar PWChar / LPWSTR / LPCWSTR wchar_t** PPWideChar 任意1字节类型 Boolean / ByteBool 1字节布尔型 任意1字节类型指针 PBoolean / PByteBool 任意2字节类型 WordBool 2字节布尔型 任意2字节类型指针 PWordBool BOOL LongBool BOOL 4字节布尔型 BOOL* PLongBool PBOOL void* Pointer PVOID / LPVOID / LPCVOID 无类型指针 void** PPointer PPVOID 升华 有了以上知识，把.</description>
    </item>
    <item>
      <title>Delphi开发守则</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_rules/</link>
      <pubDate>Thu, 12 Mar 2020 22:39:03 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_rules/</guid>
      <description>从其它平台迁移而来
前言 接触编程已十年有余，使用Delphi谋生也已五年有余，不敢说阅码无数，实实在在看过的代码也是有几箩筐的，但见过的写得好的、写得漂亮的、写得优美的代码，少之又少。
由于pascal语言简单易学的优点，以及DelphiIDE快速开发的方便，致使随便来个阿猫阿狗搞几下就能搞出来个马马虎虎的东西，于是众多程序猿便借势野蛮生长，个个都长得很有个性，产出的代码也自然是个性十足。事实上，其它语言的这种现象也不少。
我无意发起圣战，毕竟每只猿都有自己的追求，而我，不过是长成了一只有点洁癖的猿。以下是我的洁癖，也是我的追求，算是总结，也算是对自己的警醒。
正文 排版 良好的排版能使代码看起来清晰愉悦，统一的排版能使团队合作愉快，也更能显出版本控制优势。
简单来说，cnPack提供的排版功能就不错。我喜欢在默认的基础上做如下调整：
关键字小写。因为小写比大写更易阅读。
begin 位于下一行。因为能突出代码块的起始位置。
当超过90列时自动换行于80列。因为我的屏幕有点小，而且我个人也比较懒，再加上一点点历史原因。
字符串拼接等不希望cnPack自动排版的地方，可在末尾加//单行注释进行妨碍。写过长SQL语句的都知道我在说什么。
注释 注释很重要，但注释也可以很美妙。比如：interface区主要使用xml风格的注释，implementation区主要使用默认风格的注释，具体如下：
函数、过程、类方法、类属性、结构体方法的声明使用xml风格的注释，注释在上，声明在下。当你把鼠标放上去的时候你就知道我是对的。
枚举成员、类字段、结构体字段使用//单行注释，注释在右，且同一代码块尽量缩进对齐。无他，我有洁癖。
xml风格的注释，我喜欢的格式如下，至于怎么设置，我想这不是问题。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 {func} /// &amp;lt;summary&amp;gt;|&amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n1&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;n2&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; {param} /// &amp;lt;param name=&amp;#34;|&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; {remarks} /// &amp;lt;remarks&amp;gt;|&amp;lt;/remarks&amp;gt; {returns} /// &amp;lt;returns&amp;gt;|&amp;lt;/returns&amp;gt; {seealso} /// &amp;lt;seealso&amp;gt;|&amp;lt;/seealso&amp;gt; {summary} /// &amp;lt;summary&amp;gt;|&amp;lt;/summary&amp;gt; {value} /// &amp;lt;value&amp;gt;|&amp;lt;/value&amp;gt; 命名 什么拼音首字母，什么1 2 3 4 5，我是极其痛恨的！</description>
    </item>
    <item>
      <title>从Delphi到Go——接口</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_interface/</link>
      <pubDate>Thu, 30 Jan 2020 12:52:16 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_interface/</guid>
      <description>从其它平台迁移而来
由于没有太多编写接口的经验，此处仅简单说明语法。后期对接口有更多认知和经验后再进行详细记录。
Delphi Delphi的接口是侵入式接口，并且是单继承的，但类可以同时实现多个接口，类声明时需要显示声明实现了哪些接口。
声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type //直接声明 IMyInterface1 = interface function Func1: Integer; //函数 procedure Proc1(Value: Integer); //过程 property MI: Integer read Func1 write Proc1; //属性 end; //从已有接口继承 IMyInterface2 = interface(IMyInterface1) procedure Proc2; end; //含有 GUID 的接口可以公开给其它进程调用 IMyInterface3 = interface [&amp;#39;{3E51374A-D0E8-4C84-AA30-9634409E45DD}&amp;#39;] procedure Proc3; end; Delphi已经提供了基接口IInterface，自己声明的接口最好从IInterface继承。
实现 1 2 3 4 5 6 7 8 9 10 11 type //含接口的类的声明 TMyClass = class(基类, 接口) public procedure Proc; //接口方法 end; //接口实现 procedure TMyClass.</description>
    </item>
    <item>
      <title>简单数学运算的比较</title>
      <link>https://afrusrsc.github.io/posts/program/misc/float_precision_calc/</link>
      <pubDate>Wed, 01 Jan 2020 22:37:24 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/misc/float_precision_calc/</guid>
      <description>从其它平台迁移而来
人到中年，总是不免生出些危机感，长年使用Delphi，心中自是不踏实，闲来便看两眼java，不想却发现个从未注意过的小问题。
java 1 2 3 4 5 double a = 1 / 10; //0.0 double b = 1.0 / 10; //0.1 double c = 1 / 10.0; //0.1 double d = 1 - 9.0 / 10; //0.09999999999999998 double e = 1 - 9 / 10; //1.0 Delphi 1 2 3 4 5 a := 1 / 10; //0.1 b := 1.0 / 10; //0.1 c := 1 / 10.</description>
    </item>
    <item>
      <title>Delphi中的延时</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_delay/</link>
      <pubDate>Fri, 13 Dec 2019 23:40:41 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_delay/</guid>
      <description>从其它平台迁移而来
开发过程中经常会需要使用到延时功能，Delphi中有不少实现延时的方法，网上已有不少文章做过说明和分析，但本着实践出真知的态度，还是亲自动手研究一番心里比较踏实。
常用的延时方法 Sleep Sleep(n)，延时n毫秒，延时过程中程序不响应，一般延时较小时使用。
在主线程中使用，延时较大（100+）的话会起程序假死，一般在子线程中使用较多。
无论在主线程还是子线程中，延时较长的话（如 2000 ms），一般不一次性Sleep(2000)，而是分多次循环Sleep。有时为了能在延时过程中响应外部消息，还会加上Application.ProcessMessages;，如：
1 2 3 4 5 6 //延时 2000 ms for i := 0 to 19 do begin Sleep(100); Application.ProcessMessages; end; Timer Timer为定时器，用于周期性地执行某个处理。也可用来实现延时，延时过程中不会引起程序假死，
GetTickCount GetTickCount返回从操作系统启动到当前所经过的毫秒数，一般用于计算代码段的用时。配合循环使用也可达到延时的功能。
1 2 3 4 n := GetTickCount; repeat Application.ProcessMessages; //若延时过程中需要响应消息可加上此句 until GetTickCount &amp;gt;= n + ms; //ms为延时的毫秒数 注意：使用以上代码进行延时的过程中，CPU使用率会异常地高（事实上，不加限制一直跑的循环都会导致CPU使用率过高）。
小结 以上是对Sleep、Timer和GetTickCount用于延时的简单说明，个人经验：通常较小延时的场景用Sleep，较大延时的场景用Timer，评估代码段耗时的场景用GetTickCount。至于为什么这样用，以前是不清楚的，但通过对三者的精度分析，目前已知晓来龙去脉。
延时精度分析 上文已经提到，一般用GetTickCount来分析代码段耗时，但由于本次GetTickCount在被测行列，故另寻他法。
本次测试假定系统时间是足够精确的，因此使用Now分别在延时前后获取系统当前时间来进行耗时评估。
为使测试更具代表性，每个测试点测试100次，取算术平均值。
在1ms~100ms内，测试点步长为1ms，在100ms~1000ms内，测试点步长为10ms。
为尽可能减小干扰，测试过程中未使用Application.ProcessMessages;，也未使用并行。
测试结果 XE10编译，Win10下运行，经过近5个小时的测试，结果终于出炉了。
延时(ms) Sleep GetTickCount Timer 1 1.70 15.58 15.64 2 2.</description>
    </item>
    <item>
      <title>从Delphi到Go——方法</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_method/</link>
      <pubDate>Mon, 02 Dec 2019 22:56:02 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_method/</guid>
      <description>从其它平台迁移而来
结构体的方法 Delphi Delphi结构体的方法与类的方法几乎是一致的，主要区别是内存的管理方式和可见性不同。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义 type TMyStruct = record No: Integer; Name: string; function ToString: string; end; //实现 function TMyStruct.ToString: string; begin Result := Format(&amp;#39;No:%d, Name:%s&amp;#39;, [Self.No, Self.Name]); end; //调用 var ms: TMyStruct; s: string; begin s := ms.ToString; end; Go 方法其实就是加了接收器的函数，语法如下：
1 2 3 func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) { 函数体 } Go结构体的方法无需声明，直接实现即可。</description>
    </item>
    <item>
      <title>从Delphi到Go——异常处理</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_except/</link>
      <pubDate>Sun, 01 Dec 2019 22:35:02 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_except/</guid>
      <description>从其它平台迁移而来
Delphi try&amp;hellip;finally&amp;hellip;end 1 2 3 4 5 6 //创建、打开、加锁等 try //具体处理 finally //释放、关闭、解锁等 end; raise 1 raise Exception.Create(&amp;#39;异常信息&amp;#39;); //手动抛出异常 try&amp;hellip;except&amp;hellip;end 1 2 3 4 5 6 7 8 9 try //可能产生异常的语句块 except //异常的相关处理 on E: Exception do begin //对应类型的异常的处理 end; end; Go defer 加defer的语句会延迟到函数调用结束返回时才执行，相当于finally...end区。存在多个defer语句时，最先出现的总是最后才执行。
1 2 3 4 5 func F(){ //打开、加锁等 defer //关闭、解锁等 //具体处理 } panic 1 panic(异常信息) recover 1 2 3 4 5 6 7 func FF(){ defer func(){ e := recover() //异常处理 }() //可能产生异常的语句块，或调用 panic() 抛出异常 } 虽然panic/recover组合可以模拟try.</description>
    </item>
    <item>
      <title>从Delphi到Go——函数的可变参数</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_func_args/</link>
      <pubDate>Wed, 27 Nov 2019 22:24:05 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_func_args/</guid>
      <description>从其它平台迁移而来
Delphi 事实上，Delphi并没有什么可以直接为函数传递可变参数（数量可变、类型可变）的语法，但是并不是说不可能实现，最常用的Format()函数就是最好的例子。
虽然不能直接传递可变参数，但是通过一种叫做可变类型的开放数组即可实现为函数传递数量不定、类型不一的可变参数。
可变类型 可变类型不是变体类型，而是一个记录类型TVarRec，在System单元中的定义如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 TVarRec = record { do not pack this record; it is compiler-generated } case Integer of 0: (case Byte of vtInteger: (VInteger: Integer); vtBoolean: (VBoolean: Boolean); vtChar: (VChar: _AnsiChr); vtExtended: (VExtended: PExtended); {$IFNDEF NEXTGEN} vtString: (VString: _PShortStr); {$ENDIF !</description>
    </item>
    <item>
      <title>从Delphi到Go——匿名函数</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_func/</link>
      <pubDate>Sun, 03 Nov 2019 12:14:24 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_func/</guid>
      <description>从其它平台迁移而来
早期的Delphi版本是没有匿名函数的，不过可以定义一个函数类型来实现类似的功能；后期的版本已经支持匿名函数，随用随写。Go天生就支持匿名函数。
Delphi 函数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //声明函数类型 type TMyProc = procedure(A: Integer); //过程 TMyFunc = function(x: Integer): Integer; //函数 //定义符合函数类型的函数 procedure MyProc(A: Integer); begin ShowMessage(IntToHex(A)); end; function MyFunc1(x: Integer): Integer; begin Result := x + x; end; function MyFunc2(x: Integer): Integer; begin Result := x * x; end; //使用 var mp: TMyProc; mf: TMyFunc; begin mp := MyProc; mf := MyFunc1; mp(mf(99)); end; //作为参数进行传递，这才是函数类型最主要的使用方法 procedure Test(x: Integer; Func: TMyFunc); begin ShowMessage(Func(x).</description>
    </item>
    <item>
      <title>从Delphi到Go——列表</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_list/</link>
      <pubDate>Wed, 30 Oct 2019 21:58:48 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_list/</guid>
      <description>从其它平台迁移而来
Delphi中最基本的列表是TList类和TList&amp;lt;T&amp;gt;泛型类，还有线程安全的TThreadList类和TThreadList&amp;lt;T&amp;gt;泛型类，底层实现是数组。Go用的是container/list包，内部实现是双向链表。
Delphi TList TList里存的是指针，使用时注意处理好指针即可。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //声明 var l: TList; //构造 l := TList.Create; //添加 l.Add(p); //元素个数 n := l.Count; //列表容量 cap := l.Capacity; //取值 p1 := l.Items[0]; p2 := l.Extract(p1); //找到指针p1并从列表中取出，列表中将不再有p1，若其后还有元素，则前移填充空缺。 p := l.First; //取第一个元素 p := l.Last; //取最后一个元素 //查找元素的索引 i := l.IndexOf(p); //修改 l.</description>
    </item>
    <item>
      <title>从Delphi到Go——字典</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_map/</link>
      <pubDate>Mon, 28 Oct 2019 22:09:02 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_map/</guid>
      <description>从其它平台迁移而来
字典，又称为哈希表，是一种能够快速寻找值的理想结构。Go语言中对应的数据类型是map，Delphi中是TDictionary泛型类。
声明 Delphi
1 2 uses System.Generics.Collections; var 字典名: TDictionary&amp;lt;键类型, 值类型&amp;gt;; Go
1 var 字典名 map[键类型]值类型 初始化 Delphi
1 字典名 := TDictionary&amp;lt;键类型, 值类型&amp;gt;.Create(初始容量); Go
1 2 3 4 //使用make构造 字典名 = make(map[键类型]值类型, 初始容量) //直接赋初值 字典名 = map[键类型]值类型{键1: 值1, 键2: 值2} 元素操作 Delphi
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 var m: TDictionary&amp;lt;Integer, string&amp;gt;; //构造 m := TDictionary&amp;lt;Integer, string&amp;gt;.</description>
    </item>
    <item>
      <title>从Delphi到Go——数组</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_array/</link>
      <pubDate>Tue, 08 Oct 2019 22:03:53 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_array/</guid>
      <description>从其它平台迁移而来
静态数组 一维数组 声明 Delphi
1 var 数组名 : array[索引范围] of 元素类型; //索引范围是子界类型，格式为：下限..上限 Go
1 var 数组名 [数组长度]元素类型 Delphi的索引范围可以是任意的子界类型，而且是包含上下限的闭区间。子界可以是任意的序数类型（整型、字符型、枚举元素等），例如：0..8、5..11、&#39;a&#39;..&#39;z&#39;等。子界元素就是数组元素的下标。
Go的数组长度只能是整型，下标为0~数组长度-1。
初始化 Delphi
1 2 var 数组名 : array[1..N] of 元素类型 = (元素1, 元素2, ……, 元素N); //如果先声明后赋值的话，赋值时就需要遍历数组对每个元素分别赋值 Go
1 2 3 4 5 6 7 8 9 10 11 var 数组名 [N]元素类型 = [N]元素类型{元素0, 元素1, ……, 元素N-1} //由于初始化时元素个数已知，以上代码也可写为： var 数组名 [N]元素类型 = [...]元素类型{元素0, 元素1, ……, 元素N-1} //如果先声明后赋值的话，写法如下： var 数组名 [N]元素类型 数组名 = [.</description>
    </item>
    <item>
      <title>再探Delphi字符串</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_string02/</link>
      <pubDate>Sun, 06 Oct 2019 04:43:45 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_string02/</guid>
      <description>从其它平台迁移而来
闲来无事，又开始扒拉起Delphi的源码，这次发现一个比较有意思的函数StringCodePage，作用是返回传入字符串的CodePage。至于什么是CodePage，暂且认为是字符编码吧。
先测试一把：
1 2 3 4 5 6 7 8 9 10 11 12 13 var s1: AnsiString; s2: WideString; s3: UTF8String; cp1, cp2, cp3: Word; begin s1 := &amp;#39;123abc中国&amp;#39;; s2 := &amp;#39;123abc中国&amp;#39;; s3 := &amp;#39;123abc中国&amp;#39;; cp1 := StringCodePage(s1); //936 - GBK(简体中文) cp2 := StringCodePage(s2); //1200 - UCS-2LE Unicode 小端序 cp3 := StringCodePage(s3); //65001 - UTF-8 Unicode end; 来看下是怎么实现的：
1 2 3 4 5 6 7 function StringCodePage(const S: UnicodeString): Word; overload; begin if S &amp;lt;&amp;gt; &amp;#39;&amp;#39; then Result := PWord(PByte(S) - 12)^ // StrRec.</description>
    </item>
    <item>
      <title>从Delphi到Go——基础</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_base/</link>
      <pubDate>Mon, 09 Sep 2019 23:30:04 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_base/</guid>
      <description>从其它平台迁移而来
废话 长期从事Delphi开发，虽不敢说精通，但说很熟悉还是相当有自信的。不过，只会一门语言，而且还是这么老的语言，更是在大天朝很小众的语言，总感觉自己离饿死街头没多远了，所以趁着还没老再学个潮点的吧。
先前考虑过Python，初步了解后觉得不太适合自己：
解释型语言：部署时得先搞个运行环境，发布的程序就是源码本身，再加上这个执行效率，怎么想都还是编译型语言更合适。
动态语言：无需声明，拿来就用，这已经很不合习惯了。想想一个变量，前一秒还是浮点数，下一秒就成字符串了，再一眨眼又成某个对象了……虽然一般不会有人这么写，但是挡不住手误啊，还是把这种小细节交给编译器更让人放心。
所以，对于有点强迫症和洁癖的自己，最后还是选了Go，比较符合已有的编程习惯，学习成本应该相对会低些吧。
至于Go嘛，想学是已经很久了，但由于种种原因却迟迟未开启，不过终究还是要迈出这一步的，所以就搞这么个系列来记录吧，一方面算是自我督促，另一方面也算是一种交流吧，当然，若一不留神帮上了谁，那自是开心极了。
言归正传 已经初步了解过了Go，说来和Delphi还是有不少相似之处呢，从Delphi转向Go应该会比较轻松吧。
工程结构 Delphi的工程算是比较自由的，源码的话，只要把单元路径引了或是直接包含进工程单元里就可以了，编译出的dcu和最终的exe指定下路径也就没问题了，通常我都使用下面这种结构：
1 2 3 4 5 6 7 8 9 10 11 Project/ bin/ src/ dcu/ mod1/ *.dfm *.pas mod2/ *.dfm *.pas *.dpr 不过，每一个工程都要设置，而且我习惯将Debug和Release设置完全一样，也还真是够烦的。
Go就没得选了，只有一种结构：
1 2 3 4 5 6 7 8 9 10 11 Project/ bin/ pkg/ src/ *.go mod1/ *.go *_test.go mod2/ *.go *_test.go 整体和我原有的习惯差不多，还是蛮容易接受的，不过倒是要把这Project的路径加入到GOPATH系统变量里让人有一点小不爽。但是Go可以直接把测试都写了，这点还是蛮让我惊喜的，毕竟用了这么多年Delphi也没写过一行像样的测试。
源码结构 Delphi典型的源码结构是这样：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 unit Unit1; interface uses .</description>
    </item>
    <item>
      <title>关于TField.DataSize的坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_field_datasize/</link>
      <pubDate>Thu, 11 Jul 2019 20:03:00 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_field_datasize/</guid>
      <description>从其它平台迁移而来
在从数据库中查询数据时，有时需要事先取得字段内容的大小，再根据情况进行处理。
对于ADO之类返回TField类型的，可以使用DataSize属性，但是！！！这里有很深的坑！！！。
首先看如下代码：
1 2 3 4 if ADOQuery.FieldByName(&amp;#39;Test&amp;#39;).DataSize &amp;gt; 3 then {处理1} else {处理2}; 按预想，当Test字段里的数据超过3B时，应该执行处理1的代码，但事实上无论该内容长短，都是执行处理2的代码，WHY?
扒一下Delphi的源码就明白了。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 function TField.</description>
    </item>
    <item>
      <title>Delphi安全结束线程</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_thread/</link>
      <pubDate>Sun, 28 Apr 2019 19:13:48 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_thread/</guid>
      <description>从其它平台迁移而来
在开发过程中，不可避免的要用到多线程，而线程的同步、释放等又可能引入新的问题，不过网上已有许多资料，这里重点说下我使用的方法。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 type TMyThread = class(TThread) protected procedure Execute; override; public constructor Create(...); destructor Destroy; override; //使用 reintroduce 关键字可以明确通知编译器屏蔽父类的同名方法而使用自己的方法。 procedure Free; reintroduce; end; constructor TMyThread.Create(...); begin { 在这里创建相关对象，可以省去先挂起线程再恢复的操作 } inherited Create; end; destructor TMyThread.</description>
    </item>
    <item>
      <title>关于窗口置屏的那个坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_screen_monitor/</link>
      <pubDate>Fri, 01 Mar 2019 16:16:46 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_screen_monitor/</guid>
      <description>从其它平台迁移而来
在开发多屏应用程序的时候，经常需要把某个窗口置到某个屏上的某个位置。以下是一个Delphi写的置屏方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 procedure ShowInMonitor(Sender: TObject; AIndex: Integer; ALeft: Integer = 0; ATop: Integer = 0); var lM: TMonitor; begin if Sender is TControl then begin if AIndex &amp;gt; Screen.MonitorCount - 1 then begin AIndex := 0; end; lM := Screen.Monitors[AIndex]; (Sender as TControl).Left := lM.Left + ALeft; (Sender as TControl).Top := lM.Top + ATop; end; end; Sender是需要置屏的窗口；AIndex是置屏的目标屏号，从0开始；ALeft是水平偏移量，ATop是垂直偏移量，默认均为0，即在目标屏的左上角。</description>
    </item>
    <item>
      <title>TClientDataSet的使用以及遇到的坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_clientdataset/</link>
      <pubDate>Sat, 12 Jan 2019 14:43:15 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_clientdataset/</guid>
      <description>从其它平台迁移而来
在Delphi未加入FireDAC之前，似乎是没有内存表控件的（也许有，可能我不知道吧），但是可以用TClientDataSet控件来做内存表使用，即使有了FireDAC可以使用TFDMemTable，我还是觉得TClientDataSet更好用一些。
做内存表使用 创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 with ClientDataSet do begin Close; //定义字段 with FieldDefs do begin Clear; Add(&amp;#39;Field1&amp;#39;, ftInteger, 0, False); Add(&amp;#39;Field2&amp;#39;, ftString, 0, False); ...... end; //创建结构 CreateDataSet; Open; end; 排序 在定义字段后，创建结构前，也可以指定排序字段。
1 IndexFieldNames := &amp;#39;Field1&amp;#39;; 做缓存使用 需要结合TDataSetProvider来使用。以下示例以使用ADO组件为例。
拉取数据 方法1 TDBGrid-&amp;gt;TDataSource-&amp;gt;TClientDataSet-&amp;gt;TDataSetProvider-&amp;gt;TADOQuery-&amp;gt;TADOConnection
1 2 3 4 5 6 7 ClientDataSet.ProviderName := DataSetProvider.Name; //设计器里设置过就不需要了 with ClientDataSet do begin Close; CommandText:=&amp;#39;select * from T_Table&amp;#39;; Open; end; 方法2 TDBGrid-&amp;gt;TDataSource</description>
    </item>
    <item>
      <title>使用海康威视SDK的那些坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/sdk_hcnetsdk/</link>
      <pubDate>Wed, 02 Jan 2019 16:29:46 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/sdk_hcnetsdk/</guid>
      <description>从其它平台迁移而来
由于工作需要，项目中有使用到海康威视的产品，不可避免的就要使用海康的SDK进行二次开发。开发过程中磕磕绊绊的，踩了不少坑，这里做一个简单的记录，算是给健忘的自己提个醒吧。
Delphi版本的接口 Gitee地址
首先，自己一直使用Delphi进行开发，然而海康官方只提供了C/C++的接口和示例，无奈只能自己改写了。改写完的部分已经上传，希望能有人共同来完善。
由于Delphi商业使用的限制，现已转到Lazarus，全面拥抱开源。
坑 播放声音 预览时播放声音，回放时播放声音，甚至使用播放库播放已下载的视频时播放声音，这些对于前端摄像头自带麦克的场景肯定是刚需（另接麦克的情况暂未测试），然而按照官方SDK文档和示例代码写出的程序死活就是没有声音，这样的情况似乎不少人都遇到过，但是，好像并没有见谁把解决方法公开过。
其实，这个问题特别简单，只需要把HCNetSDKCom目录下的OpenAL32.dll拷贝到PlayCtrl.dll所在的目录下就可以了。这下就明白了吧，没有声音的原因其实就是使用NET_DVR_OpenSound调了PlayCtrl.dll，而PlayCtrl.dll又调了OpenAL32.dll来播放声音，但是由于PlayCtrl.dll没有找到OpenAL32.dll所以没有声音，而且这个有问题的返回值也并没有一层层的返回给NET_DVR_OpenSound函数，结果就是函数返回调用成功了，但就是死活没声音。
PlayCtrl.dll不是PlayCtrl.dll 使用海康SDK进行二次开发的，一般也会使用到海康的播放库，但是有一个问题是需要注意的，那就是SDK里的PlayCtrl.dll并不是播放库里的PlayCtrl.dll。虽然它们长得一样，名字也一样，但它们的本质却是完全不一样的，是不能互相替代的！有兴趣的朋友可以使用eXeScope详细查看。</description>
    </item>
    <item>
      <title>Delphi自定义图形控件的自定义字体属性在设计期报错的解决办法</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_custom_graphic_control/</link>
      <pubDate>Tue, 02 Oct 2018 02:40:14 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_custom_graphic_control/</guid>
      <description>从其它平台迁移而来
背景 自定义一个图形控件（继承自TGraphicControl类），需要在不同区域显示不同字体的内容，此时会需要在设计器中加入多个字体，方法是在控件的published区增加对应的字体属性即可（使用Ctrl+Shift+C可快速生成），如：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 TMyGraphicControl = class(GraphicControl) private FText1Font: TFont; FText2Font: TFont; procedure SetText1Font(const Value: TFont); procedure SetText2Font(const Value: TFont); protected procedure Paint; override; public { public declarations } published property Text1Font:TFont read FText1Font write SetText1Font; property Text2Font:TFont read FText2Font write SetText2Font; end; 这样就可以在设计器里像使用原生控件一样使用自己的控件了。
问题 但是，如果在设计期选择了弹出字体对话框进行设置字体，IDE就会报错（大意是读或写某个地址异常），而在运行期则正常！
原因 对比查看Delphi自带的控件源码，终于找到了原因。
1 2 3 4 5 6 7 8 9 10 //Delphi TControl类设置字体属性的方法 procedure TControl.</description>
    </item>
    <item>
      <title>Delphi版本号对照表</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_version/</link>
      <pubDate>Sun, 12 Aug 2018 15:52:38 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_version/</guid>
      <description>从其它平台迁移而来
Conditional VER Product Product Version Package Version VER330 Delphi / C++Builder XE10.3 Rio 26 260 VER320 Delphi / C++Builder XE10.2 Tokyo 25 250 VER310 Delphi / C++Builder XE10.1 Berlin 24 240 VER300 Delphi / C++Builder XE10 Seattle 23 230 VER290 Delphi / C++Builder XE8 22 220 VER280 Delphi / C++Builder XE7 21 210 VER270 Delphi / C++Builder XE6 20 200 VER260 Delphi / C++Builder XE5 19 190 VER250 Delphi / C++Builder XE4 18 180 VER240 Delphi / C++Builder XE3 17 170 VER230 Delphi / C++Builder XE2 16 160 VER220 Delphi / C++Builder XE 15 150 VER210 Delphi / C++Builder 2010 14 140 VER200 Delphi / C++Builder 2009 12 120 VER190 Delphi 2007 for .</description>
    </item>
    <item>
      <title>使用FireDAC的TFDQuery查询Firebird遇到的坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/firedac_fdquery_firebird/</link>
      <pubDate>Wed, 03 Jan 2018 01:43:02 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/firedac_fdquery_firebird/</guid>
      <description>从其它平台迁移而来
这几天被Prepare这个东西搞死了，虽然用它解决了目前的问题，但是完全不知道为什么，如有大侠知道还望指教，不胜感激！
首先，说下开发环境：
win10 x64(1709 [10.0.16299.125])+Delphi XE7 up1(自带FireDAC)+Firebird 3.0.2.32703_0(数据库字符集使用UTF8)
问题一：中文模糊查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var CompanyType: Integer FDQuery1.Close; FDQuery1.SQL.Text := &amp;#39;SELECT * FROM companyinfo &amp;#39; + &amp;#39;WHERE (tag = 0) AND (companytype = :companytype) AND &amp;#39; + &amp;#39;((companyname LIKE :Text) OR (pym LIKE :Text))&amp;#39; + &amp;#39; ORDER BY TIMES DESC&amp;#39;; //FDQuery1.Prepare; //写在这里会报错，提示如下，大致意思是： //数据库 companytype 字段是SmallInt类型，却赋了一个Integer类型的值 {--------------------------- [FireDAC][Phys][FB]-338.</description>
    </item>
    <item>
      <title>FireDAC之TFDStoredProc</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/firedac_fdstoredproc/</link>
      <pubDate>Fri, 24 Nov 2017 10:11:13 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/firedac_fdstoredproc/</guid>
      <description>从其它平台迁移而来
1.在FireDAC选项卡中找到TFDStoredProc控件，放到窗体上，并把Connection属性设置为准备好的数据库连接控件上。
2.在需要执行存储过程的位置写入类似以下的代码：
1 2 3 4 5 6 7 8 9 FDStoredProc1.StoredProcName := &amp;#39;SP_StoredProcName&amp;#39;; FDStoredProc1.Prepare; //必须，否则会报找不到参数的错误 FDStoredProc1.ParamByName(&amp;#39;I_ID&amp;#39;).AsInteger := id; //无返回值或返回值由输出参数传递时 FDStoredProc1.ExecProc; UserName := FDStoredProc1.ParamByName(&amp;#39;O_USERNAME&amp;#39;).AsString; //有返回值或数据集时 FDStoredProc1.Open(); UserName := FDStoredProc1.FindField(&amp;#39;O_USERNAME&amp;#39;).AsString; 3.以上为存储过程返回单个值或单条记录时的用法，存储过程返回多条记录（即数据表）的用法暂未研究。</description>
    </item>
    <item>
      <title>FirdDAC之TFDQuery使用</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/firedac_fdquery/</link>
      <pubDate>Thu, 23 Nov 2017 22:31:27 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/firedac_fdquery/</guid>
      <description> 从其它平台迁移而来
1.在FireDAC选项卡中找到TFDQuery控件，放到窗体上，并把Connection属性设置为准备好的数据库连接控件上。
2.在需要查询或执行SQL语句的位置写入类似以下的代码：
1 2 3 4 5 6 7 8 //查询，有返回集 FDQuery1.SQL.Text := &amp;#39;SELECT * FROM DBTable WHERE id = :id&amp;#39;; FDQuery1.ParamByName(&amp;#39;id&amp;#39;).AsInteger := 1; FDQuery1.Open(); //执行SQL语句，无返回集 FDQuery1.SQL.Text := &amp;#39;DELETE FROM DBTable WHERE id = :id&amp;#39;; FDQuery1.ParamByName(&amp;#39;id&amp;#39;).AsInteger := 1; FDQuery1.ExecSQL; 3.若查询结果需要连接到数据集，则在DataAccess选项卡中找到TDataSource控件，放到窗体上，并把DataSet属性连接到TFDQuery控件。然后把数据感知控件（如cxGrid等）的DataSource属性连接到TDataSource控件。
4.若只需要取出查询结果并进行后续处理，可使用如下代码取出结果：
1 2 3 id := FDQuery1.FindField(&amp;#39;id&amp;#39;).AsInteger; DeptName := FDQuery1.FindField(&amp;#39;deptname&amp;#39;).AsString; Money := FDQuery1.FindField(&amp;#39;money&amp;#39;).AsFloat; </description>
    </item>
    <item>
      <title>FireDAC连接数据库</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/firedac_fdconnection/</link>
      <pubDate>Wed, 22 Nov 2017 11:25:47 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/firedac_fdconnection/</guid>
      <description>从其它平台迁移而来
建立DataModule
在FireDAC选项卡中找到我们的主角TFDConnection控件，并放到DataModule窗体上，把LoginPrompt设为False，这样在连接时就不会弹出登陆对话框了。然后再找到TFDManager控件，也放到DataModule窗体上，并且把Active属性设为True，这样一来，在引用了本单元的其它单元中，就可以直接把FireDAC控件的Connection连接到本单元的TFDConnection了。
在FireDAC Links选项卡中找到所需要连接的数据的驱动链接控件，放到DataModule窗体上。本例中使用的是FireBird数据库，因此就选择了TFDPhysFBDriverLink，其它数据库参照执行（本人接触的数据库不多，各数据库间的差异不敢妄言，但整体使用思路和方法应是不差的）。 在FireDAC UI选项卡中找到TFDGUIxWaitCursor控件，放到DataModule窗体上。该控件其实只是个光标，可修改ScreenCursor属性来改变光标。 至此，拖控件的工作基本上就做完了，下面该写代码了（虽然代码中有相当一部分工作可以直接在设计器中修改属性来达到，但建议用代码来实现，一方面便于DEBUG，另一方面也易于进行数据库的变更、迁移等）。
在DataModule的Create事件中写入类似以下的代码（也可写在其它地主，但要保证必须在任何数据库操作代码前运行）： 1 2 3 4 5 6 7 8 9 10 11 12 FDPhysFBDriverLink1.VendorLib := DllPath + &amp;#39;fbclient.dll&amp;#39;; FDConnection1.Params.DriverID := &amp;#39;FB&amp;#39;; FDConnection1.Params.Database := HostName + &amp;#39;/&amp;#39; + DBPort + &amp;#39;:&amp;#39; + DBFilePathAndName; FDConnection1.Params.UserName := UserName; FDConnection1.Params.Password := Password; FDConnection1.Params.Add(&amp;#39;CharacterSet=utf8&amp;#39;); try FDConnection1.Open(); except on E:Exception do ShowMessage(E.Message); end; 注意：FDConnection1.Params.Add(&#39;CharacterSet=utf8&#39;);这句是设置客户端连接数据库是默认使用的字符集，一定要与所连接的数据库使用的默认字符集一致，否则将会发生很多奇怪的事情。而且该项无法在设计器的属性中进行设置！</description>
    </item>
    <item>
      <title>深入Delphi的字符串类型</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_string01/</link>
      <pubDate>Tue, 15 Aug 2017 23:17:53 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_string01/</guid>
      <description>从其它平台迁移而来
探索 之前提到了Delphi的字符串，但并未展开说，这里就详细探讨下Delphi的字符串类型。
废话不多说，直接上源码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 program StringTest; {$APPTYPE CONSOLE} uses SysUtils; var s1, s2, s3: string; begin Writeln(&amp;#39;Now time : &amp;#39;,FormatDateTime(&amp;#39;HH:MM:SS.</description>
    </item>
    <item>
      <title>Delphi中的数据类型</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_type/</link>
      <pubDate>Sun, 13 Aug 2017 14:34:21 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_type/</guid>
      <description>从其它平台迁移而来
之前一直使用的是Delphi 7，现在准备转向Delphi XE7，据说数据类型上有一些微小的调整，便想亲自验证一下，也顺便加深一下自己对Delphi数据类型的认识，毕竟之前仅仅是在用而从未考虑过类型在内存中的形态。
验证方法很简单，就是在控制台用Sizeof()把相应数据类型的字节数显示出来。源码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 program TypeSize; {$APPTYPE CONSOLE} uses SysUtils; type Emnu = (one, two, three, four); Range1 = $0.</description>
    </item>
  </channel>
</rss>
