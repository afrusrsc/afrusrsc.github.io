[{"content":"事件 有一个任务需要把当前正在使用的镜像导出为离线包，在导出过程中发现速度特别慢，第一反应是CPU或内存被拉満了，top查看后是正常的，那问题可能出在磁盘上。\n服务器上暂时没有合适的查看磁盘I/O的工具，只好先看下容量：\n1 df -h 瞬间发现磁盘使用率达到了95%以上，铁定有问题了！\n1 du -h -d 1 / 发现/var目录巨大无比！\n1 du -h -t 10G /var 发现有几个/var/lib/docker/containers/xxxxxx的文件特别大，问了deepseek，得到的回答是：docker默认会将容器内应用产生的日志记录在json日志文件里，且默认没有大小限制！\n查了下容器的id，嗯，这下对上了，确实是日志的问题！那就限定下日志的大小即可。\n方案 全局配置 全局配置适用于所有之后新建的容器。\n修改/etc/docker/daemon.json，添加日志限制：\n1 2 3 4 5 6 7 { \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;10m\u0026#34;, \u0026#34;max-file\u0026#34;: \u0026#34;5\u0026#34; } } 单容器配置 启动时通过参数直接限制：\n1 docker run --log-opt max-size=10m --log-opt max-file=5 ... docker-compose.yaml配置 使用docker compose时，可以在docker-compose.yaml里配置：\n1 2 3 4 5 6 7 8 services: your-service: image: your-image logging: driver: \u0026#34;json-file\u0026#34; options: max-size: \u0026#34;10m\u0026#34; max-file: \u0026#34;5\u0026#34; 也可以使用yaml锚点避免重复配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 x-logging: \u0026amp;default-logging driver: \u0026#34;json-file\u0026#34; options: max-size: \u0026#34;10m\u0026#34; max-file: \u0026#34;5\u0026#34; services: your-service1: image: your-image1 logging: *default-logging your-service2: image: your-image2 logging: *default-logging 配置完执行docker compose up -d即可生效。\n","permalink":"https://afrusrsc.github.io/posts/devops/docker_log_opt/","summary":"事件 有一个任务需要把当前正在使用的镜像导出为离线包，在导出过程中发现速度特别慢，第一反应是CPU或内存被拉満了，top查看后是正常的，那问题可能出在磁盘上。\n服务器上暂时没有合适的查看磁盘I/O的工具，只好先看下容量：\n1 df -h 瞬间发现磁盘使用率达到了95%以上，铁定有问题了！\n1 du -h -d 1 / 发现/var目录巨大无比！\n1 du -h -t 10G /var 发现有几个/var/lib/docker/containers/xxxxxx的文件特别大，问了deepseek，得到的回答是：docker默认会将容器内应用产生的日志记录在json日志文件里，且默认没有大小限制！\n查了下容器的id，嗯，这下对上了，确实是日志的问题！那就限定下日志的大小即可。\n方案 全局配置 全局配置适用于所有之后新建的容器。\n修改/etc/docker/daemon.json，添加日志限制：\n1 2 3 4 5 6 7 { \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;10m\u0026#34;, \u0026#34;max-file\u0026#34;: \u0026#34;5\u0026#34; } } 单容器配置 启动时通过参数直接限制：\n1 docker run --log-opt max-size=10m --log-opt max-file=5 ... docker-compose.yaml配置 使用docker compose时，可以在docker-compose.yaml里配置：\n1 2 3 4 5 6 7 8 services: your-service: image: your-image logging: driver: \u0026#34;json-file\u0026#34; options: max-size: \u0026#34;10m\u0026#34; max-file: \u0026#34;5\u0026#34; 也可以使用yaml锚点避免重复配置：","title":"Docker容器日志配置"},{"content":"一个消息 听说，win10停更了，第一反应是：哦，已经到时间了啊，停吧，反正也就玩游戏时会用用。\n事实上，这个消息如果是在半年前，第一反应肯定是这样：哎呀，太好了，SBbug10终于不会再自动更新了，再也不用担心这SB偷偷自动更新半天、然后更新失败再回滚半天，浪费时间、浪费精力、浪费生命！\n但是，不管是哪种情况，对于新的继任者——瘟尸疫（win11），打死我也不会用的，更不会买预装了瘟尸疫的电脑，实在迫不得已要在别人的瘟尸疫设备上操作，心里也是要多骂几句的。\n话再说回来，现在对待win10的态度能这么平淡，其实是因为已经使用linux做主力了，毕竟最近几年在win10上使个劲儿地折腾wsl和虚拟机，就是为了转linux做主力。\n转战场 其实，大概从2009年有第一台自己的电脑后不到一年，就开始接触linux了，第一次安装的发行版是wubi安装的ubuntu，再后来是物理分区装双系统；工作后5~6年，基本上都是在虚拟机里玩，ubuntu、centos、mint、debian等主流发行版都尝试过，gnome、kde、mate、xfce、cinnamon等主流的桌面环境也尝试过，不过也仅仅是尝试过而已；后来，bug10（win10）出了wsl，又玩起了wsl。\n有一阵子，python爆火，无意间发现同样的python程序在wsl和win10下的性能天差地别，对win的不满（之前主要集中在SB自动更新上）瞬间爆涨。\n后来学了git并做为主力工具后，linux的tab补全简直爱死了，于是wsl+git就正式成为生产力工具了。\n再后来，固态硬盘开始大行其道，这本是件好事，但是无奈那些互联网大厂都推出了自己的桌面应用——清一色的浏览器套壳，真TM SB到极致了，于是，原本就喜欢绿色版的自己就变得更喜欢那些小而美的东西了。所以，debian+xfce的组合也就慢慢固定下来了。\n由于一直做的是delphi开发，基本上被win锁死了，所以，很长一段时间里都是在用win，即便是双系统。\n做了十年的delphi，早已厌倦了那种因个人审美及习惯不同而导致的各种算不上是真需求的需求，所以越来越倾向于去做更关注逻辑的后端。还好，碰巧遇到了这么一个机会，于是就从delphi转go了，顺便也转为linux做主力了。\n其实，有了wsl+git做主力的那段经历，完全转linux做主力并没有太多不适，真要说的话，主要还是那些消费级的应用不多（在信创大环境下，还是比以前好了不少，比如：微信、QQ、wps等），以及一些硬件的驱动麻烦些，但是那些生产级的应用真的是挺好的。\n不知不觉，使用linux做主力已经半年了，win10除了偶尔玩玩游戏外，几乎已经不用了，除非是需要使用个别只能在win上运行的应用。\n后话 中间也尝试过很短一段时间的free bsd，除了生态更小外，没明显感觉出与linux有太大不同。\n使用linux才真正感觉自己的电脑是自己的，虽然有时也会被玩坏点东西，但是网上查一下，照着敲几下命令，一般问题都能解决。\n","permalink":"https://afrusrsc.github.io/posts/os/bye_win10/","summary":"一个消息 听说，win10停更了，第一反应是：哦，已经到时间了啊，停吧，反正也就玩游戏时会用用。\n事实上，这个消息如果是在半年前，第一反应肯定是这样：哎呀，太好了，SBbug10终于不会再自动更新了，再也不用担心这SB偷偷自动更新半天、然后更新失败再回滚半天，浪费时间、浪费精力、浪费生命！\n但是，不管是哪种情况，对于新的继任者——瘟尸疫（win11），打死我也不会用的，更不会买预装了瘟尸疫的电脑，实在迫不得已要在别人的瘟尸疫设备上操作，心里也是要多骂几句的。\n话再说回来，现在对待win10的态度能这么平淡，其实是因为已经使用linux做主力了，毕竟最近几年在win10上使个劲儿地折腾wsl和虚拟机，就是为了转linux做主力。\n转战场 其实，大概从2009年有第一台自己的电脑后不到一年，就开始接触linux了，第一次安装的发行版是wubi安装的ubuntu，再后来是物理分区装双系统；工作后5~6年，基本上都是在虚拟机里玩，ubuntu、centos、mint、debian等主流发行版都尝试过，gnome、kde、mate、xfce、cinnamon等主流的桌面环境也尝试过，不过也仅仅是尝试过而已；后来，bug10（win10）出了wsl，又玩起了wsl。\n有一阵子，python爆火，无意间发现同样的python程序在wsl和win10下的性能天差地别，对win的不满（之前主要集中在SB自动更新上）瞬间爆涨。\n后来学了git并做为主力工具后，linux的tab补全简直爱死了，于是wsl+git就正式成为生产力工具了。\n再后来，固态硬盘开始大行其道，这本是件好事，但是无奈那些互联网大厂都推出了自己的桌面应用——清一色的浏览器套壳，真TM SB到极致了，于是，原本就喜欢绿色版的自己就变得更喜欢那些小而美的东西了。所以，debian+xfce的组合也就慢慢固定下来了。\n由于一直做的是delphi开发，基本上被win锁死了，所以，很长一段时间里都是在用win，即便是双系统。\n做了十年的delphi，早已厌倦了那种因个人审美及习惯不同而导致的各种算不上是真需求的需求，所以越来越倾向于去做更关注逻辑的后端。还好，碰巧遇到了这么一个机会，于是就从delphi转go了，顺便也转为linux做主力了。\n其实，有了wsl+git做主力的那段经历，完全转linux做主力并没有太多不适，真要说的话，主要还是那些消费级的应用不多（在信创大环境下，还是比以前好了不少，比如：微信、QQ、wps等），以及一些硬件的驱动麻烦些，但是那些生产级的应用真的是挺好的。\n不知不觉，使用linux做主力已经半年了，win10除了偶尔玩玩游戏外，几乎已经不用了，除非是需要使用个别只能在win上运行的应用。\n后话 中间也尝试过很短一段时间的free bsd，除了生态更小外，没明显感觉出与linux有太大不同。\n使用linux才真正感觉自己的电脑是自己的，虽然有时也会被玩坏点东西，但是网上查一下，照着敲几下命令，一般问题都能解决。","title":"Bye~~ win10！"},{"content":"背景 系统从debian 12升到debian 13后，一直有个地方很不爽：鼠标放到状态栏的音量图标上时无法显示当前的具体音量。但是，由于升级过程出了点状况（详见Debian从12升到13的翻车记），一时不确定是自己搞出来的问题还是本来就有bug。\n过程 新发现 今天无意间查看~/.xsession-errors内容时，看到大段如下重复的内容：\n1 2 (wrapper-2.0:1621): Gtk-WARNING **: 21:29:52.802: Failed to set text \u0026#39;音量 30% \u0026lt;/b\u0026gt;\u0026lt;small\u0026gt;内置音频 模拟立体声\u0026lt;/small\u0026gt;\u0026#39; from markup due to error parsing markup: 第 2 行第 5 个字符出错： 元素“b”已经闭合，当前仍开放的元素是“markup” 然后瞬间就觉得这可能是个bug！查看插件的关于信息：xfce4-pulseaudio-plugin 0.4.9，卸载并重装插件：\n1 2 3 4 5 6 # 卸载 sudo apt purge xfce4-pulseaudio-plugin # 重新安装 sudo apt install xfce4-pulseaudio-plugin # 重启面板 xfce4-panel -r 重启后，问题仍在。全盘搜索相关文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 sudo find / -name \u0026#34;*xfce4-pulseaudio-plugin*\u0026#34; # 部分结果如下 /usr/share/icons/hicolor/48x48/apps/xfce4-pulseaudio-plugin.png /usr/share/icons/hicolor/scalable/apps/xfce4-pulseaudio-plugin.svg /usr/share/doc/xfce4-pulseaudio-plugin /usr/share/locale/zh_TW/LC_MESSAGES/xfce4-pulseaudio-plugin.mo /usr/share/locale/da/LC_MESSAGES/xfce4-pulseaudio-plugin.mo /usr/share/locale/sv/LC_MESSAGES/xfce4-pulseaudio-plugin.mo /usr/share/locale/hy_AM/LC_MESSAGES/xfce4-pulseaudio-plugin.mo /usr/share/locale/ar/LC_MESSAGES/xfce4-pulseaudio-plugin.mo /usr/share/locale/de/LC_MESSAGES/xfce4-pulseaudio-plugin.mo /usr/share/locale/sr/LC_MESSAGES/xfce4-pulseaudio-plugin.mo ... 出现了很多xfce4-pulseaudio-plugin.mo的文件，都是在/usr/share/locale/xxx/LC_MESSAGES/这样的文件夹下，很明显这些都是不同语言的翻译。查看简体中文的文件：\n1 cat /usr/share/locale/zh_CN/LC_MESSAGES/xfce4-pulseaudio-plugin.mo 果然发现了日志中相似的内容：\n1 2 3 4 Plural-Forms: nplurals=1; plural=0; 音量 %d%% (已静音) \u0026lt;/b\u0026gt;\u0026lt;small\u0026gt;%s\u0026lt;/small\u0026gt;音量 %d%% \u0026lt;/b\u0026gt;\u0026lt;small\u0026gt;%s\u0026lt;/small\u0026gt;\u0026lt;big\u0026gt;\u0026lt;b\u0026gt;运行命令 \u0026#34;%s\u0026#34; 失败。\u0026lt;/b\u0026gt;\u0026lt;/big\u0026gt; 再查看繁体中文的文件：\n1 cat /usr/share/locale/zh_TW/LC_MESSAGES/xfce4-pulseaudio-plugin.mo 相似的内容如下：\n1 2 3 4 Plural-Forms: nplurals=1; plural=0; \u0026lt;b\u0026gt;音量 %d%%（已靜音）\u0026lt;/b\u0026gt; \u0026lt;small\u0026gt;%s\u0026lt;/small\u0026gt;\u0026lt;b\u0026gt;音量 %d%%\u0026lt;/b\u0026gt; \u0026lt;small\u0026gt;%s\u0026lt;/small\u0026gt;\u0026lt;big\u0026gt;\u0026lt;b\u0026gt;執行指令「%s」失敗。\u0026lt;/b\u0026gt;\u0026lt;/big\u0026gt; 两相对比，果然与~/.xsession-errors中记录的日志一致，bug实锤了！\n问题修复 邪修 既然是xfce4-pulseaudio-plugin.mo文件的问题，那就改一下好了：\n1 2 3 4 5 # 先备份 sudo cp /usr/share/locale/zh_CN/LC_MESSAGES/xfce4-pulseaudio-plugin.mo /usr/share/locale/zh_CN/LC_MESSAGES/xfce4-pulseaudio-plugin.mo.bak # 再修改 # 注意：*.mo 文件实际是二进制文件，当做文本文件修改是有风险的 sudo vi /usr/share/locale/zh_CN/LC_MESSAGES/xfce4-pulseaudio-plugin.mo 保存后重启面板。\n现在有提示了，但是是中英混合的，虽然能看了，但还是不完美。\n正修 网上查了下，*.mo文件是由*.po编译出来的，那就找一下xfce4-pulseaudio-plugin的po吧。\n在插件的关于信息中有网站的链接，进去后有gitlab的仓库地址，然后就看到源码的po目录，找到zh_CN.po文件，下载下来，编译一下：\n1 sudo msgfmt -o /usr/share/locale/zh_CN/LC_MESSAGES/xfce4-pulseaudio-plugin.mo zh_CN.po 重启面板。OK！搞定了！\n回头看了下源码下的NEWS，0.5.1 (2025-04-24)才更新了一些*.po文件，估计是已经过了debian 13的合并窗口期，所以debian 13的仓库中还只是有问题的0.4.9。\n总结 邪修不靠谱，还得正经来。\n到官方仓库地址下载po/zh_CN.po文件\n把*.po编译为*.mo\n1 sudo msgfmt -o /usr/share/locale/zh_CN/LC_MESSAGES/xfce4-pulseaudio-plugin.mo zh_CN.po 重启面板 1 xfce4-panel -r ","permalink":"https://afrusrsc.github.io/posts/os/xfce4-pulseaudio-plugin_zh_cn_mo/","summary":"背景 系统从debian 12升到debian 13后，一直有个地方很不爽：鼠标放到状态栏的音量图标上时无法显示当前的具体音量。但是，由于升级过程出了点状况（详见Debian从12升到13的翻车记），一时不确定是自己搞出来的问题还是本来就有bug。\n过程 新发现 今天无意间查看~/.xsession-errors内容时，看到大段如下重复的内容：\n1 2 (wrapper-2.0:1621): Gtk-WARNING **: 21:29:52.802: Failed to set text \u0026#39;音量 30% \u0026lt;/b\u0026gt;\u0026lt;small\u0026gt;内置音频 模拟立体声\u0026lt;/small\u0026gt;\u0026#39; from markup due to error parsing markup: 第 2 行第 5 个字符出错： 元素“b”已经闭合，当前仍开放的元素是“markup” 然后瞬间就觉得这可能是个bug！查看插件的关于信息：xfce4-pulseaudio-plugin 0.4.9，卸载并重装插件：\n1 2 3 4 5 6 # 卸载 sudo apt purge xfce4-pulseaudio-plugin # 重新安装 sudo apt install xfce4-pulseaudio-plugin # 重启面板 xfce4-panel -r 重启后，问题仍在。全盘搜索相关文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 sudo find / -name \u0026#34;*xfce4-pulseaudio-plugin*\u0026#34; # 部分结果如下 /usr/share/icons/hicolor/48x48/apps/xfce4-pulseaudio-plugin.","title":"关于xfce4-pulseaudio-plugin中文翻译的bug"},{"content":"背景 宝宝该上幼儿园了，之前千难万难终于拍成了一张红底的一寸照，现在突然又通知需要两版蓝底的一寸照，呃～还是自己P一个吧。\n早先使用Gimp处理过换底色，方法比较笨拙，效果也差强人意。这次的效果还算不错，做个记录。\n方法 思路 不管是用什么工具，思路都是一样的：\ngraph LR s1[扣出人像] --\u003e s2[删除原背景] --\u003e s3[添加新背景] 步骤 准备工作 安装Gimp 1 sudo apt install gimp 使用gimp打开红底照片，如果原图是使用Photoshop处理的话，一般都会有个转换的提示，点转换后，先另存为Gimp的*.xcf格式\n修改当前图层名为原图\n复制原图图层并改名为扣图\n新建背景图层，使用油漆桶工具填充成蓝色\n调整图层顺序，从下到上依次为背景、原图、扣图\n扣图 在扣图图层上右键添加透明通道，并锁定位置和大小，可避免拖动类的误操作\n选择前景选择工具，用鼠标粗略地围绕人物轮廓画一圈，形成一个大概的选区框，回车，画面变暗\n调整笔触宽度，在人物的内部（包括头发）涂抹，涂抹过的区域将变亮。\n注意：1.可以先用粗笔选中间区域，再用细笔选边缘区域；2.头发部分尽量不要选择到有背景色的部分；3.尽量贴近边缘选择，可以有效减少运算量\n涂抹完成后回车，等Gimp运算完，将会自动生成一个精确的人物轮廓区，可以在彩色和灰度之间切换查看效果，如果有未选择到的区别，可以调整笔触继续选择，但每一次选择都会触发运算，建议回到第2.步重新选择\n再次回车，可看到最终的选区\n反选，即选择到背景，删除\n精修 在扣图图层上右键添加图层蒙板，并选择蒙板\n选择低硬度的画笔，如硬度25的笔刷，前景色为黑色\n放大图片，在边缘有原背景色的地方进行涂抹，如果不小心把人物部分擦掉了，只需将前景色切换为白色，再涂抹就可以恢复\n导出 隐藏原图图层，显示背景图层\n菜单文件-\u0026gt;导出为，导出最终图片\n保存*.xcf文件备用，如改白底、改尺寸等\n总结 核心在扣图环节，这个环节做好了，后面基本不需要调整，或只需要微调。\n","permalink":"https://afrusrsc.github.io/posts/other/gimp_change_background_color/","summary":"背景 宝宝该上幼儿园了，之前千难万难终于拍成了一张红底的一寸照，现在突然又通知需要两版蓝底的一寸照，呃～还是自己P一个吧。\n早先使用Gimp处理过换底色，方法比较笨拙，效果也差强人意。这次的效果还算不错，做个记录。\n方法 思路 不管是用什么工具，思路都是一样的：\ngraph LR s1[扣出人像] --\u003e s2[删除原背景] --\u003e s3[添加新背景] 步骤 准备工作 安装Gimp 1 sudo apt install gimp 使用gimp打开红底照片，如果原图是使用Photoshop处理的话，一般都会有个转换的提示，点转换后，先另存为Gimp的*.xcf格式\n修改当前图层名为原图\n复制原图图层并改名为扣图\n新建背景图层，使用油漆桶工具填充成蓝色\n调整图层顺序，从下到上依次为背景、原图、扣图\n扣图 在扣图图层上右键添加透明通道，并锁定位置和大小，可避免拖动类的误操作\n选择前景选择工具，用鼠标粗略地围绕人物轮廓画一圈，形成一个大概的选区框，回车，画面变暗\n调整笔触宽度，在人物的内部（包括头发）涂抹，涂抹过的区域将变亮。\n注意：1.可以先用粗笔选中间区域，再用细笔选边缘区域；2.头发部分尽量不要选择到有背景色的部分；3.尽量贴近边缘选择，可以有效减少运算量\n涂抹完成后回车，等Gimp运算完，将会自动生成一个精确的人物轮廓区，可以在彩色和灰度之间切换查看效果，如果有未选择到的区别，可以调整笔触继续选择，但每一次选择都会触发运算，建议回到第2.步重新选择\n再次回车，可看到最终的选区\n反选，即选择到背景，删除\n精修 在扣图图层上右键添加图层蒙板，并选择蒙板\n选择低硬度的画笔，如硬度25的笔刷，前景色为黑色\n放大图片，在边缘有原背景色的地方进行涂抹，如果不小心把人物部分擦掉了，只需将前景色切换为白色，再涂抹就可以恢复\n导出 隐藏原图图层，显示背景图层\n菜单文件-\u0026gt;导出为，导出最终图片\n保存*.xcf文件备用，如改白底、改尺寸等\n总结 核心在扣图环节，这个环节做好了，后面基本不需要调整，或只需要微调。","title":"Gimp更换证件照的背景色"},{"content":"前言 之前都是在虚拟机里玩玩Debian，也就最近两年才实打实地在物理机上装了Debian 12，也一直用得挺好。\n前段时间，关注已久的trixie也就是Debian 13终于发布了，虽然告诫过自己要等稳定一段时间再升级，但终究挡不过尝鲜的念头一起再起，于是在发布的第二天晚上开启了升级之路。\n虽然已经研究了官方的升级文档，但还是翻车了。\n升级过程 先更新当前系统的补丁 1 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y 备份源，然后修改源，把bookworm替换为trixie 1 2 3 4 5 6 7 # 备份 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak # 修改 sudo sed -i \u0026#39;s/bookworm/trixie/g\u0026#39; /etc/apt/sources.list # 也可用一个命令备份并修改 sudo sed -i.bak \u0026#39;s/bookworm/trixie/g\u0026#39; /etc/apt/sources.list 再进行大版本更新 1 sudo apt update \u0026amp;\u0026amp; sudo apt full-upgrade -y 更新完成后会有类似执行apt autoremove的提示，慎重执行 翻车记 翻车根源在于：大版本更新时使用了sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y，之后又无脑执行了sudo apt autoremove，好巧不巧把network-manager卸载了，没法上网了！\n若是可以接有线网，插上网线，sudo apt install network-manager也就不会有后面的问题了。但是，偏偏这是在一个没有有线网的环境下。\n网上搜了下，可以使用networking先联上网，但折腾一番后没能成功（可能是哪个步骤出了点小问题吧，事后了也无法验证），心急了，就决定重装了（因为是双系统，在bug10上下载了最新的镜像并制作了启动盘）。\n因为热点是TypeC供电的一个设备提供的（充电和热点只能二选一），偏偏又在安装过程中的联网更新环节手机没电，最终导致仅安装了无桌面的基本系统。\n终于等到电量够用了，安装桌面，安装并切换到network-manager，安装需要使用的应用。\n后记 总结下经验教训吧：\n墨菲定律\n升级要选在一个有较大空闲的时间段里进行，并且要网络（最好是有线网络）、供电等条件一应俱全，万一翻车还能从容不迫的进行挽救\n执行sudo apt autoremove前一定要先执行sudo apt autoremove --dry-run，看清楚都卸载了哪些包，对于不希望卸载的包要使用sudo apt-mark manual xxx标记为手工，避免一顿操作猛如虎，仔细一看二百五的情况\n","permalink":"https://afrusrsc.github.io/posts/os/debian_12to13/","summary":"前言 之前都是在虚拟机里玩玩Debian，也就最近两年才实打实地在物理机上装了Debian 12，也一直用得挺好。\n前段时间，关注已久的trixie也就是Debian 13终于发布了，虽然告诫过自己要等稳定一段时间再升级，但终究挡不过尝鲜的念头一起再起，于是在发布的第二天晚上开启了升级之路。\n虽然已经研究了官方的升级文档，但还是翻车了。\n升级过程 先更新当前系统的补丁 1 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y 备份源，然后修改源，把bookworm替换为trixie 1 2 3 4 5 6 7 # 备份 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak # 修改 sudo sed -i \u0026#39;s/bookworm/trixie/g\u0026#39; /etc/apt/sources.list # 也可用一个命令备份并修改 sudo sed -i.bak \u0026#39;s/bookworm/trixie/g\u0026#39; /etc/apt/sources.list 再进行大版本更新 1 sudo apt update \u0026amp;\u0026amp; sudo apt full-upgrade -y 更新完成后会有类似执行apt autoremove的提示，慎重执行 翻车记 翻车根源在于：大版本更新时使用了sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y，之后又无脑执行了sudo apt autoremove，好巧不巧把network-manager卸载了，没法上网了！\n若是可以接有线网，插上网线，sudo apt install network-manager也就不会有后面的问题了。但是，偏偏这是在一个没有有线网的环境下。","title":"Debian从12升到13的翻车记"},{"content":"背景 随着微信在工作场景中使用得越来越多，为避免工作微信对个人生活的无缝入侵，多账号成了一个有效隔离工作和生活的手段。\n但是，微信官方客户端默认不支持多账号登录，这就对有多账号登录需求的人造成了不便。\n解决方案 多开的方法有很多，个人更倾向使用脚本完成，不推荐安装第三方软件。\nwindows win上多开的原理很简单，就是在微信彻底启动完成前启动多次，最终就会实现微信多开。可以拼手速，当然写成bat脚本更可靠。\n1 2 3 4 5 6 7 8 9 10 @echo off :: 设置需要打开的微信数量 set count=2 :: 循环启动微信 for /l %%i in (1,1,%count%) do ( :: 需要填写微信实际安装路径 start \u0026#34;\u0026#34; \u0026#34;C:\\Program Files (x86)\\Tencent\\WeChat\\WeChat.exe\u0026#34; ) 美化 可以给写好的脚本创建个桌面快捷方式，然后在快捷方式上右键属性，更改图标，选择WeChat.exe，选择微信自己的图标即可。\n若有开机启动的需求了，再把快捷方式加入开机启动项即可。\nlinux 注意：官方已经出了原生的linux版微信，以下方法是基于官方linux版，至于某些特供版是否适用尚不清楚。\n在linux上多开的原理也不复杂：微信启动后会生成个锁文件（~/.xwechat/lock/lock.ini），删除即可再开一个微信。可以手动删除，当然依然是写成脚本更可靠。\n1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash # 设置需要打开的微信数量 count=2 # 循环启动微信 for ((i=0; i\u0026lt;${count}; i++)); do # 需要填写微信实际安装路径 /usr/bin/wechat \u0026amp; # 0.1秒后删除锁文件，若系统不支持小数秒则改为1 sleep 0.1 \u0026amp;\u0026amp; rm $HOME/.xwechat/lock/lock.ini done 美化 官方微信默认创建的快捷方式（.desktop文件）是/usr/share/applications/wechat.desktop，可以先备份一下，然后把其中的Exec=/usr/bin/wechat %U替换为Exec=脚本的绝对路径即可。注意：需要使用root权限。\n注意：Linux版双开后，遇到了进入微信设置界面会导致微信退出的问题（不知道是否是个例），目前暂未寻找原因及解决办法。\n","permalink":"https://afrusrsc.github.io/posts/os/pc_mult_wechat/","summary":"背景 随着微信在工作场景中使用得越来越多，为避免工作微信对个人生活的无缝入侵，多账号成了一个有效隔离工作和生活的手段。\n但是，微信官方客户端默认不支持多账号登录，这就对有多账号登录需求的人造成了不便。\n解决方案 多开的方法有很多，个人更倾向使用脚本完成，不推荐安装第三方软件。\nwindows win上多开的原理很简单，就是在微信彻底启动完成前启动多次，最终就会实现微信多开。可以拼手速，当然写成bat脚本更可靠。\n1 2 3 4 5 6 7 8 9 10 @echo off :: 设置需要打开的微信数量 set count=2 :: 循环启动微信 for /l %%i in (1,1,%count%) do ( :: 需要填写微信实际安装路径 start \u0026#34;\u0026#34; \u0026#34;C:\\Program Files (x86)\\Tencent\\WeChat\\WeChat.exe\u0026#34; ) 美化 可以给写好的脚本创建个桌面快捷方式，然后在快捷方式上右键属性，更改图标，选择WeChat.exe，选择微信自己的图标即可。\n若有开机启动的需求了，再把快捷方式加入开机启动项即可。\nlinux 注意：官方已经出了原生的linux版微信，以下方法是基于官方linux版，至于某些特供版是否适用尚不清楚。\n在linux上多开的原理也不复杂：微信启动后会生成个锁文件（~/.xwechat/lock/lock.ini），删除即可再开一个微信。可以手动删除，当然依然是写成脚本更可靠。\n1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash # 设置需要打开的微信数量 count=2 # 循环启动微信 for ((i=0; i\u0026lt;${count}; i++)); do # 需要填写微信实际安装路径 /usr/bin/wechat \u0026amp; # 0.","title":"PC上多开微信的方法"},{"content":"背景 在Linux上，一直使用的是xfce桌面环境，要的就是一个简洁、轻量、稳定，够用却又不算丑。\n但是，在中文环境下，默认的下载目录名字就是下载，在命令行下使用时还要切换输入法，麻烦，虽然可以建立软链接解决，但还是想知道有没有更直接的方法。\n解决方案 一番折腾后，发现了$HOME/.config/目录下的user-dirs.dirs文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # This file is written by xdg-user-dirs-update # If you want to change or add directories, just edit the line you\u0026#39;re # interested in. All local changes will be retained on the next run. # Format is XDG_xxx_DIR=\u0026#34;$HOME/yyy\u0026#34;, where yyy is a shell-escaped # homedir-relative path, or XDG_xxx_DIR=\u0026#34;/yyy\u0026#34;, where /yyy is an # absolute path. No other format is supported. # XDG_DESKTOP_DIR=\u0026#34;$HOME/桌面\u0026#34; XDG_DOWNLOAD_DIR=\u0026#34;$HOME/下载\u0026#34; XDG_TEMPLATES_DIR=\u0026#34;$HOME/模板\u0026#34; XDG_PUBLICSHARE_DIR=\u0026#34;$HOME/公共\u0026#34; XDG_DOCUMENTS_DIR=\u0026#34;$HOME/文档\u0026#34; XDG_MUSIC_DIR=\u0026#34;$HOME/音乐\u0026#34; XDG_PICTURES_DIR=\u0026#34;$HOME/图片\u0026#34; XDG_VIDEOS_DIR=\u0026#34;$HOME/视频\u0026#34; 嗯，就是这个了。\n修改$HOME/.config/user-dirs.dirs内容，把XDG_DOWNLOAD_DIR=\u0026quot;$HOME/下载\u0026quot;改为XDG_DOWNLOAD_DIR=\u0026quot;$HOME/download\u0026quot;\n把下载文件夹重命名为download\n重启（或者重新登录）\n其它的修改也是类似。\n","permalink":"https://afrusrsc.github.io/posts/os/xfce4_user_dirs/","summary":"背景 在Linux上，一直使用的是xfce桌面环境，要的就是一个简洁、轻量、稳定，够用却又不算丑。\n但是，在中文环境下，默认的下载目录名字就是下载，在命令行下使用时还要切换输入法，麻烦，虽然可以建立软链接解决，但还是想知道有没有更直接的方法。\n解决方案 一番折腾后，发现了$HOME/.config/目录下的user-dirs.dirs文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # This file is written by xdg-user-dirs-update # If you want to change or add directories, just edit the line you\u0026#39;re # interested in. All local changes will be retained on the next run. # Format is XDG_xxx_DIR=\u0026#34;$HOME/yyy\u0026#34;, where yyy is a shell-escaped # homedir-relative path, or XDG_xxx_DIR=\u0026#34;/yyy\u0026#34;, where /yyy is an # absolute path.","title":"Xfce4自定义用户文件夹"},{"content":"背景 由于是win和debian双系统，并且需要在两个系统间共享使用资料分区，因此数据分区采用的是ntfs格式。虽说xfce桌面环境挂载ntfs分区不算麻烦（点下鼠标，再输个密码），但还是希望开机时就能自动挂载。\n解决方案 以需要把win下的D:盘挂载到/mnt/d下为例进行说明。\n准备工作 安装ntfs-3g驱动，已安装则忽略（桌面环境可挂载则证明已有驱动） 1 sudo apt update \u0026amp;\u0026amp; sudo apt install ntfs-3g 查看待挂载的ntfs分区的设备名称和UUID 1 lsblk -f # 假设设备名为 /dev/sda3，UUID 为 ABCDFE 手动创建挂载点 1 sudo mkdir /mnt/d 查看当前用户的uid和gid 1 id # 一般第一个非root的用户的 uid 和 gid 均为 1000 修改配置 编辑/etc/fstab 1 sudo vi /etc/fstab 添加如下内容并保存 1 UUID=ABCDFE /mnt/d ntfs-3g defaults,uid=1000,gid=1000,dmask=022,fmask=133,noatime,windows_names 0 0 重启 配置详解 1 \u0026lt;file system\u0026gt; \u0026lt;mount point\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; \u0026lt;file system\u0026gt;要挂载的设备，常见格式如下： 格式 示例 说明 设备路径 /dev/sda1 直接指定分区（不推荐，设备名可能变化） UUID UUID=1234-5678 唯一标识符（推荐，通过 blkid 或 lsblk -f 查看） 卷标 LABEL=Data 文件系统卷标（需提前用 e2label 等工具设置） 网络路径 nas:/share NFS/Samba 等网络共享路径 \u0026lt;mount point\u0026gt;挂载点，必须是已存在的空目录，一般在/mnt下\n\u0026lt;type\u0026gt;文件系统类型，必须与分区实际类型一致，常见类型如下：\n类型 说明 ext4 Linux 原生文件系统 ntfs / ntfs-3g Windows NTFS 分区（需安装 ntfs-3g） vfat FAT32/exFAT 分区 swap 交换分区 nfs / cifs 网络文件系统 \u0026lt;options\u0026gt;挂载选项，控制挂载后的权限、性能和行为，详见\u0026lt;options\u0026gt;详解\n\u0026lt;dump\u0026gt;备份标志，已废弃\n值 说明 0 不备份（默认） 1 需要备份（极少使用） \u0026lt;pass\u0026gt;文件系统检查顺序，控制fsck在启动时的检查顺序 值 说明 适用场景 0 不检查 NTFS/FAT/swap 等非 Linux 分区 1 优先检查 根分区 / 2 次级检查 其他 Linux 分区（如 /home） \u0026lt;options\u0026gt;详解 是一个以逗号分隔的列表（两个及以上时）。\n挂载行为 选项 作用 示例 说明 defaults 启用默认选项 defaults 等价于 rw,suid,dev,exec,auto,nouser,async rw / ro 读写 / 只读 ro 只读挂载（保护数据） exec / noexec 允许 / 禁止执行文件 noexec 增强安全性（如数据分区） suid / nosuid 允许 / 禁用 SUID/SGID nosuid 防止提权攻击 dev / nodev 是否允许挂载设备文件 nodev 防止访问设备（如 /dev/sda1） auto / noauto 是否开机自动挂载 noauto 手动挂载（如临时分区） user / nouser 是否允许普通用户挂载 user 允许非 root 用户挂载 权限控制 选项 作用 示例 说明 uid 设置文件所有者 uid=1000 指定用户 ID（id -u 查看） gid 设置文件所属组 gid=1000 指定组 ID（id -g 查看） dmask 目录权限掩码 dmask=022 目录权限 = 777 - dmask（如 755） fmask 文件权限掩码 fmask=133 文件权限 = 666 - fmask（如 644） umask 统一权限掩码 umask=000 同时控制文件和目录权限（不推荐） 性能与可靠性 选项 作用 示例 说明 async / sync 异步/同步写入 sync 同步写入更安全，但性能差 atime / noatime 更新访问时间 noatime 减少磁盘写入（推荐） relatime 相对访问时间 relatime 平衡性能与兼容性 errors=remount-ro 错误时只读挂载 errors=remount-ro 防止数据损坏 文件系统特定选项 NTFS/FAT 专用 选项 作用 示例 说明 windows_names 禁止非法文件名 windows_names 避免创建 *?\u0026lt;\u0026gt; 等 Windows 非法字符 utf8 强制 UTF-8 编码 utf8 正确显示非 ASCII 文件名 shortname=mixed 处理短文件名 shortname=mixed 兼容旧版 Windows 系统 ext4 专用 选项 作用 示例 说明 journal / nojournal 启用/禁用日志 nojournal 禁用日志（提升性能，但风险高） discard 启用 TRIM discard 优化 SSD 性能 data=writeback 日志模式 data=writeback 性能优先（默认 data=ordered） swap 分区 选项 系统 说明 sw OpenBSD等BSD 必要的，用于标记交换分区 sw Linux 只是一个占位符 ","permalink":"https://afrusrsc.github.io/posts/os/debian_mount_ntfs/","summary":"背景 由于是win和debian双系统，并且需要在两个系统间共享使用资料分区，因此数据分区采用的是ntfs格式。虽说xfce桌面环境挂载ntfs分区不算麻烦（点下鼠标，再输个密码），但还是希望开机时就能自动挂载。\n解决方案 以需要把win下的D:盘挂载到/mnt/d下为例进行说明。\n准备工作 安装ntfs-3g驱动，已安装则忽略（桌面环境可挂载则证明已有驱动） 1 sudo apt update \u0026amp;\u0026amp; sudo apt install ntfs-3g 查看待挂载的ntfs分区的设备名称和UUID 1 lsblk -f # 假设设备名为 /dev/sda3，UUID 为 ABCDFE 手动创建挂载点 1 sudo mkdir /mnt/d 查看当前用户的uid和gid 1 id # 一般第一个非root的用户的 uid 和 gid 均为 1000 修改配置 编辑/etc/fstab 1 sudo vi /etc/fstab 添加如下内容并保存 1 UUID=ABCDFE /mnt/d ntfs-3g defaults,uid=1000,gid=1000,dmask=022,fmask=133,noatime,windows_names 0 0 重启 配置详解 1 \u0026lt;file system\u0026gt; \u0026lt;mount point\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; \u0026lt;file system\u0026gt;要挂载的设备，常见格式如下： 格式 示例 说明 设备路径 /dev/sda1 直接指定分区（不推荐，设备名可能变化） UUID UUID=1234-5678 唯一标识符（推荐，通过 blkid 或 lsblk -f 查看） 卷标 LABEL=Data 文件系统卷标（需提前用 e2label 等工具设置） 网络路径 nas:/share NFS/Samba 等网络共享路径 \u0026lt;mount point\u0026gt;挂载点，必须是已存在的空目录，一般在/mnt下","title":"Debian开机自动挂载ntfs分区"},{"content":"前言 tar是个极其常用的命令，也是个功能很强大的命令，单是tar --help就出来好几屏，所以常用的也只是其中一小部分。\n最近看到别人用tar解压分卷大文件时，自己对tar分卷完全不了解，搜索后记录一下。\n分卷打包 tar自身不包含分卷功能，需要配合split完成。\n1 tar -cvf - 文件夹名/ | split -b 大小 - 输出文件名前缀 # 注意两个`-`不能省 tar也可以带上其它参数，比如-z、-j等压缩参数。\nsplit也可以带其它参数，比如-d使用数字后缀。\n解包分卷 同分卷打包类似，tar需要配合cat完成对分卷的解包。\n1 2 3 4 5 6 # 先拼接后解包 cat 文件前缀* \u0026gt; 合并后的文件名 tar -xvf 合并后的文件名 # 不产生中间文件 cat 文件前缀* | tar -xvf - # 注意这个`-`不能省 注意： 1. 分卷文件要全部在同一个目录下；2. 分卷文件的顺序特别重要，务必保证顺序正确无误。\n","permalink":"https://afrusrsc.github.io/posts/os/tar_split/","summary":"前言 tar是个极其常用的命令，也是个功能很强大的命令，单是tar --help就出来好几屏，所以常用的也只是其中一小部分。\n最近看到别人用tar解压分卷大文件时，自己对tar分卷完全不了解，搜索后记录一下。\n分卷打包 tar自身不包含分卷功能，需要配合split完成。\n1 tar -cvf - 文件夹名/ | split -b 大小 - 输出文件名前缀 # 注意两个`-`不能省 tar也可以带上其它参数，比如-z、-j等压缩参数。\nsplit也可以带其它参数，比如-d使用数字后缀。\n解包分卷 同分卷打包类似，tar需要配合cat完成对分卷的解包。\n1 2 3 4 5 6 # 先拼接后解包 cat 文件前缀* \u0026gt; 合并后的文件名 tar -xvf 合并后的文件名 # 不产生中间文件 cat 文件前缀* | tar -xvf - # 注意这个`-`不能省 注意： 1. 分卷文件要全部在同一个目录下；2. 分卷文件的顺序特别重要，务必保证顺序正确无误。","title":"tar分卷打包解包"},{"content":"场景 工作需要，一般使用的是相对较低的go版本，且较长时间内不会轻易变更；自己尝鲜或参与某个开源项目，又会使用另外的go版本。在不同项目间切换工作，通常需要切换到对应的go版本（虽然go目前是向下兼容的，高版本可以正确编译低版本，但开发人员即便熟知不同版本间的差异，也不能百分百保证不使用到高版本的特性）。\n解决方案 网上也有很多方案，尝试后摸索出了比较符合自己风格和习惯的方案。\n创建一个存放go不同版本的目录，用于将不同版本下载到该目录统一管理，并以版本号命名 1 mkdir $HOME/gosdk 编写下载脚本download_go.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/bin/bash if test \u0026#34;${1}\u0026#34; == \u0026#34;\u0026#34;; then echo \u0026#39;请传入正确的版本号，如：\u0026#39;${0}\u0026#39; 1.21.1\u0026#39; else # 统一管理目录 gosdk=$HOME/gosdk # 下载 gopkg=go${1}.linux-amd64.tar.gz if ! test -e ${gopkg}; then wget -c https://dl.google.com/go/${gopkg} fi # 删除可能冲突的文件 rm -rf ${gosdk}/go rm -rf ${gosdk}/go${1} # 解压 tar -C ${gosdk}/ -xzf ${gopkg} # 重命名 mv ${gosdk}/go ${gosdk}/go${1} # 删除安装包 rm ${gopkg} # 配置环境变量 go env -w GOPROXY=https://goproxy.cn,direct go env -w GO111MODULE=on fi 编写切换脚本switch_go.sh： 1 2 3 4 5 6 7 8 9 10 #!/bin/bash if test \u0026#34;${1}\u0026#34; == \u0026#34;\u0026#34;; then echo \u0026#39;请传入正确的版本号，如：\u0026#39;${0}\u0026#39; 1.21.1\u0026#39; else # 统一管理目录 gosdk=$HOME/gosdk # 创建符号链接 ln -sfn ${gosdk}/go${1} $HOME/.local/go fi 将符号链接的路径加入搜索路径： 1 echo -e \u0026#34;\\n# golang \\nexport PATH=\\$PATH:\\$HOME/.local/go/bin:\\$HOME/go/bin\u0026#34; \u0026gt;\u0026gt; ~/.bashrc 将download_go.sh和switch_go.sh放入$HOME/.local/bin之类已存在于搜索路径的目录下，或将其所在路径加入搜索路径\n使用download_go.sh下载所需版本的go，在需要切换时使用switch_go.sh进行切换\n","permalink":"https://afrusrsc.github.io/posts/program/go/go_multi_version/","summary":"场景 工作需要，一般使用的是相对较低的go版本，且较长时间内不会轻易变更；自己尝鲜或参与某个开源项目，又会使用另外的go版本。在不同项目间切换工作，通常需要切换到对应的go版本（虽然go目前是向下兼容的，高版本可以正确编译低版本，但开发人员即便熟知不同版本间的差异，也不能百分百保证不使用到高版本的特性）。\n解决方案 网上也有很多方案，尝试后摸索出了比较符合自己风格和习惯的方案。\n创建一个存放go不同版本的目录，用于将不同版本下载到该目录统一管理，并以版本号命名 1 mkdir $HOME/gosdk 编写下载脚本download_go.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/bin/bash if test \u0026#34;${1}\u0026#34; == \u0026#34;\u0026#34;; then echo \u0026#39;请传入正确的版本号，如：\u0026#39;${0}\u0026#39; 1.21.1\u0026#39; else # 统一管理目录 gosdk=$HOME/gosdk # 下载 gopkg=go${1}.linux-amd64.tar.gz if ! test -e ${gopkg}; then wget -c https://dl.google.com/go/${gopkg} fi # 删除可能冲突的文件 rm -rf ${gosdk}/go rm -rf ${gosdk}/go${1} # 解压 tar -C ${gosdk}/ -xzf ${gopkg} # 重命名 mv ${gosdk}/go ${gosdk}/go${1} # 删除安装包 rm ${gopkg} # 配置环境变量 go env -w GOPROXY=https://goproxy.","title":"Go多版本共存"},{"content":"前言 做了十多年桌面开发，虽然也会写一些服务端的东西，但毕竟不是主力，而且体量和规模也是极小的，所以很少接触docker这类。云原生已经普及很久了，而且桌面开发的路也越来越窄，是时候转变下方向了。\ndocker应该算是云原生的基石吧，但刚接触，光安装就够喝一壶了，多次尝试后终于成功，记录一下。\n安装 准备 linux环境，linux发行版或wsl都可以\n网络，有时候无法安装，仅仅是因为宽带运营商（此处点名批评下一动不动的移动）的不可知问题，换个网络即可\n安装Docker 直接下载官方安装脚本进行安装 1 2 curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 检查是否安装成功 1 docker -v 如果无权限则增加权限 1 sudo usermod -aG docker xxx 增加国内镜像源 执行以下命令\n1 sudo vi /etc/docker/daemon.json 添加类似以下内容，可添加其它已知可用的镜像源地址\n1 2 3 4 5 6 { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.1ms.run\u0026#34;, \u0026#34;https://docker.xuanyuan.me\u0026#34; ] } 基本使用 命令 功能 示例 docker images 列出本地存储的所有镜像 docker images docker pull 从仓库拉取镜像 docker pull ubuntu docker load -i 从tar文件导入镜像 docker load -i xx.tar docker save 导出镜像 docker save xxx -o xxx.tar docker run 启动一个新的容器并运行命令 docker run -d ubuntu docker ps 列出当前正在运行的容器 docker ps docker ps -a 列出所有容器（包括已停止的容器） docker ps -a docker stop 停止一个或多个容器 docker stop xxx docker start 启动已停止的容器 docker start xxx docker restart 重启一个容器 docker restart xxx docker rm 删除一个或多个容器 docker rm xxx docker rmi 删除一个或多个镜像 docker rmi ubuntu docker stats 显示容器的实时资源使用情况 docker stats docker logs 查看容器日志 docker logs -f xxx ","permalink":"https://afrusrsc.github.io/posts/devops/docker_install/","summary":"前言 做了十多年桌面开发，虽然也会写一些服务端的东西，但毕竟不是主力，而且体量和规模也是极小的，所以很少接触docker这类。云原生已经普及很久了，而且桌面开发的路也越来越窄，是时候转变下方向了。\ndocker应该算是云原生的基石吧，但刚接触，光安装就够喝一壶了，多次尝试后终于成功，记录一下。\n安装 准备 linux环境，linux发行版或wsl都可以\n网络，有时候无法安装，仅仅是因为宽带运营商（此处点名批评下一动不动的移动）的不可知问题，换个网络即可\n安装Docker 直接下载官方安装脚本进行安装 1 2 curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 检查是否安装成功 1 docker -v 如果无权限则增加权限 1 sudo usermod -aG docker xxx 增加国内镜像源 执行以下命令\n1 sudo vi /etc/docker/daemon.json 添加类似以下内容，可添加其它已知可用的镜像源地址\n1 2 3 4 5 6 { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.1ms.run\u0026#34;, \u0026#34;https://docker.xuanyuan.me\u0026#34; ] } 基本使用 命令 功能 示例 docker images 列出本地存储的所有镜像 docker images docker pull 从仓库拉取镜像 docker pull ubuntu docker load -i 从tar文件导入镜像 docker load -i xx.","title":"安装Docker"},{"content":"前言 先前就尝试过使用Lazarus写一个插件式的桌面应用框架，主程序只负责整体的插件管理以及为插件提供页签式的展示容器，具体的功能实现都由插件（动态库）来完成。\n但是之前比较零散的几次尝试，多或少有些问题，比较有代表性的如：\n无法以模式窗口显示插件内的子窗口\n插件内的窗口在任务栏上显示的是和主程序分离的两个程序\n动态库无法卸载\n使用接口无法释放动态库里的对象\n无法跨平台（主要针对windows）\n近来又进行了一次系统性的尝试，以前的一些也针对性的研究了下，并找到了目前来看比较合适的解决方案，并将阶段性成果开源了，具体地址见文末。\n旧问题解决 模式窗口 这个问题其实早在Lazarus官方的wiki（Form in Dll）上就有解决方案了。\n在此基础上也尝试进行一些魔改，过程就不多说了，经验总结如下：\nDisableFormsCallBack和EnableFormsCallback两个回调必须为普通过程，改为类方法会导致模式窗口失效\nTApplicationCallback可以和插件动态库内的管理类合并，做为插件入口的统一管理，甚至做为插件统一接口的实现\n视觉上为同一程序 Form in Dll中已经涉及，即在CreateParams中将Params.WndParent赋值为主程序中对应容器的句柄。\n卸载/释放 对于动态库的卸载，在Lazarus的dll卸载问题中已有提到，本次直接避免。\n对于对象的释放，这前的尝试犯了一个很严重的错误，即未遵守谁创建谁释放这一原则。接口中增加专门的释放函数，用于释放通过接口创建的对象。但，对于接口创建的对象，主程序除了释放外，也不应该（事实上也不能）进行其它操作，否则会抛内存访问异常。\n共享内存管理器 如果仅使用基本数据类型的话，这就是个伪命题，但若使用高阶数据类型的话还是会方便很多，毕竟字符串其实并不算是真正的基本类型。\n文章在Lazarus中使用ShareMem解决了在Windows平台上共享内存管理器的问题。在QQ群的交流中，群友啊D提出使用GetMemoryManager和SetMemoryManager，目前来看是能解决该问题的。\n跨平台一致性 Lazarus本身就是跨平台的，只注意避免使用平台专用的api即可，或者对不同平台的api进行封装。\n对于插件式的动态库，exports导出的函数统一使用Name关键字强制命名。同时，对于32位CPU，导出函数统一使用cdecl而不是stdcall进行传参约束；对于64位CPU，导出函数统一使用默认的传参约束，即不使用任何关键字，由编译器管理。\n新的问题 基于有限的测试，Linux的gtk2中显示模式窗口时主窗体还能进行最大化、最小化、移动等操作，但不能操作窗体内的元素，这与Windows上的行为表现不太一致\n插件动态库创建的窗体，嵌入主程序容器后，并不能像嵌入自身容器内那样可以方便的自适应大小和位置\nTODO 解决新发现的问题\n主程序页签式容器的实现\n主程序插件的管理\n开源地址 Github地址：https://github.com/afrusrsc/x-framework\nGitee地址：https://gitee.com/afrusrsc/x-framework\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_plugin_form/","summary":"前言 先前就尝试过使用Lazarus写一个插件式的桌面应用框架，主程序只负责整体的插件管理以及为插件提供页签式的展示容器，具体的功能实现都由插件（动态库）来完成。\n但是之前比较零散的几次尝试，多或少有些问题，比较有代表性的如：\n无法以模式窗口显示插件内的子窗口\n插件内的窗口在任务栏上显示的是和主程序分离的两个程序\n动态库无法卸载\n使用接口无法释放动态库里的对象\n无法跨平台（主要针对windows）\n近来又进行了一次系统性的尝试，以前的一些也针对性的研究了下，并找到了目前来看比较合适的解决方案，并将阶段性成果开源了，具体地址见文末。\n旧问题解决 模式窗口 这个问题其实早在Lazarus官方的wiki（Form in Dll）上就有解决方案了。\n在此基础上也尝试进行一些魔改，过程就不多说了，经验总结如下：\nDisableFormsCallBack和EnableFormsCallback两个回调必须为普通过程，改为类方法会导致模式窗口失效\nTApplicationCallback可以和插件动态库内的管理类合并，做为插件入口的统一管理，甚至做为插件统一接口的实现\n视觉上为同一程序 Form in Dll中已经涉及，即在CreateParams中将Params.WndParent赋值为主程序中对应容器的句柄。\n卸载/释放 对于动态库的卸载，在Lazarus的dll卸载问题中已有提到，本次直接避免。\n对于对象的释放，这前的尝试犯了一个很严重的错误，即未遵守谁创建谁释放这一原则。接口中增加专门的释放函数，用于释放通过接口创建的对象。但，对于接口创建的对象，主程序除了释放外，也不应该（事实上也不能）进行其它操作，否则会抛内存访问异常。\n共享内存管理器 如果仅使用基本数据类型的话，这就是个伪命题，但若使用高阶数据类型的话还是会方便很多，毕竟字符串其实并不算是真正的基本类型。\n文章在Lazarus中使用ShareMem解决了在Windows平台上共享内存管理器的问题。在QQ群的交流中，群友啊D提出使用GetMemoryManager和SetMemoryManager，目前来看是能解决该问题的。\n跨平台一致性 Lazarus本身就是跨平台的，只注意避免使用平台专用的api即可，或者对不同平台的api进行封装。\n对于插件式的动态库，exports导出的函数统一使用Name关键字强制命名。同时，对于32位CPU，导出函数统一使用cdecl而不是stdcall进行传参约束；对于64位CPU，导出函数统一使用默认的传参约束，即不使用任何关键字，由编译器管理。\n新的问题 基于有限的测试，Linux的gtk2中显示模式窗口时主窗体还能进行最大化、最小化、移动等操作，但不能操作窗体内的元素，这与Windows上的行为表现不太一致\n插件动态库创建的窗体，嵌入主程序容器后，并不能像嵌入自身容器内那样可以方便的自适应大小和位置\nTODO 解决新发现的问题\n主程序页签式容器的实现\n主程序插件的管理\n开源地址 Github地址：https://github.com/afrusrsc/x-framework\nGitee地址：https://gitee.com/afrusrsc/x-framework","title":"Lazarus插件式窗口设计尝试"},{"content":"起因 近来，翻看gin源码时，无意间看到了green = \u0026quot;\\033[97;42m\u0026quot;这种不明所以的代码，遂充满疑惑和好奇，于是就搜索探究了一番，这才知道这叫ANSI转义序列。\nANSI转义序列 简单说，就是一种标准化的终端控制序列，用于设置文本样式、颜色和背景等。先放个代码吧，以免不知所云。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { for i := 0; i \u0026lt;= 10; i++ { fmt.Printf(\u0026#34;这是\\033[%[1]dm\u0026lt;文本属性\u0026gt;%2[1]d\\033[0m\\n\u0026#34;, i) } s := []int{30, 31, 32, 33, 34, 35, 36, 37} for _, v := range s { fmt.Printf(\u0026#34;这是\\033[%[1]dm\u0026lt;16色标准前景色\u0026gt;%2[1]d\\033[0m\\t\\033[%[2]dm\u0026lt;16色亮前景色\u0026gt;%2[2]d\\033[0m\\n\u0026#34;, v, v+60) fmt.Printf(\u0026#34;这是\\033[%[1]dm\u0026lt;16色标准背景色\u0026gt;%2[1]d\\033[0m\\t\\033[%[2]dm\u0026lt;16色亮背景色\u0026gt;%2[2]d\\033[0m\\n\u0026#34;, v+10, v+70) } for i := 0; i \u0026lt; 256; i++ { fmt.Printf(\u0026#34;这是\\033[38;5;%[1]dm\u0026lt;256色前景色\u0026gt;%3[1]d\\033[0m\\t\\x1b[48;5;%[1]dm\u0026lt;256色背景色\u0026gt;%3[1]d\\033[0m\\n\u0026#34;, i) } } 语法 整体的语法为：\n1 ESC+控制序列 ESC：ESC转义字符，固定为\\033（八进制）或\\x1b（十六进制），告诉终端后面的内容是控制序列\n控制序列：有不同分类，一般为序列内容+命令字符的形式，具体语法后面再细说\n支持情况 大多数终端都支持ANSI转义序列，但不包括windows平台默认配置的命令提示符和PowerShell（也许通过某些配置后是支持的，未深究）。\n虽然大多数终端都支持，但支持的情况也是有差异的，即：\n有些终端只支持某一部分的ANSI转义序列，其它则不支持\n对于同一ANSI转义序列，不同终端的表现形式可能不同\n分类 分类 语法 说明 CSI序列 ESC[+参数序列+命令字符 用于控制光标、颜色、屏幕等 直接控制 ESC+命令字符 用于简单控制 OSC命令 ESC]+命令字符+参数+终止符 用于操作系统控制 私有模式控制 ESC[?+参数序列+命令字符 用于配置终端的独有功能（通常由终端制造商或特定标准扩展） 注意：\n参数序列若有多个参数，用;进行分隔\n命令字符区分大小写\n终止符仅OSC命令有，固定为\\007或\\033\\\\\nCSI序列 该分类应该是最常用的。\n命令字符 功能 示例 A 光标上移 \\033[5A上移5行 B 光标下移 \\033[3B下移3行 C 光标右移 \\033[10C右移10列 D 光标左移 \\033[2D左移2列 E 光标下移并到行首 \\033[1E下移1行到行首 F 光标上移并到行首 \\033[1F上移1行到行首 G 光标水平绝对定位 \\033[10G移动到第10列 H 光标定位 \\033[2;10H第2行第10列 J 擦除屏幕 \\033[2J清屏 K 擦除行 \\033[K清除到行尾 S 向上滚动 \\033[5S上滚5行 T 向下滚动 \\033[3T下滚3行 m 图形样式 \\033[1;31m红色粗体 n 设备状态报告 \\033[6n查询光标位置 s 保存光标位置 \\033[s u 恢复光标位置 \\033[u f 同H（光标定位） \\033[2;10f 其中m即图形样式，应该是用得最多的。\n图形样式 语法：\\033[参数序列m\n参数 效果 说明 0 重置所有属性 下面要介绍的文本属性和颜色的设置，在设置完之后将一直生效，通常需要在末尾加上\\033[0m来恢复到默认设置 文本属性 语法：\\033[单一参数m 参数 效果 重置参数 1 加粗/高亮 22 2 弱化/暗淡 22 3 斜体 23 4 下划线 24 5 慢闪烁 25 6 快闪烁 26 7 反色 27 8 隐藏 28 9 删除线 29 21 双下划线 53 单上划线 73 上标 74 下标 文本颜色 16色模式 语法：\\033[单一参数m 16色颜色 参数 效果 参数 效果 标准黑 30 前景色 40 背景色 标准红 31 前景色 41 背景色 标准绿 32 前景色 42 背景色 标准黄 33 前景色 43 背景色 标准蓝 34 前景色 44 背景色 标准品红 35 前景色 45 背景色 标准青 36 前景色 46 背景色 标准白 37 前景色 47 背景色 亮灰 90 前景色 100 背景色 亮红 91 前景色 101 背景色 亮绿 92 前景色 102 背景色 亮黄 93 前景色 103 背景色 亮蓝 94 前景色 104 背景色 亮品红 95 前景色 105 背景色 亮青 96 前景色 106 背景色 亮白 97 前景色 107 背景色 256色模式 前景色语法：\\033[38;5;颜色代码m\n背景色语法：\\033[48;5;颜色代码m\n其中，颜色代码\n0~15：标准16色\n16~231：6 × 6 × 6的RGB立方（即36×R + 6×G + B + 16，R/G/B∈[0,5]，最后的16为偏移）\n232~255：24级灰度（232=黑，255=白，即g + 232，g∈[0,23]，最后的232为偏移）\n24位RGB真彩色 前景色语法：\\033[38;2;R;G;Bm（R/G/B∈[0,255]）\n背景色语法：\\033[48;2;R;G;Bm（R/G/B∈[0,255]）\n直接控制 命令字符 功能 示例 7 保存光标位置 \\0337 8 恢复光标位置 \\0338 D 向下滚动一行 \\033D M 向上滚动一行 \\033M E 换行并回车 \\033E c 重置终端 \\033c完全重置终端 OSC命令 命令字符 功能 示例 说明 0 修改窗口标题 \\033]0;My Title\\007 1 修改图标名称（少用） \\033]1;Icon Name\\007 2 同 0（修改标题） \\033]2;New Title\\007 4 修改调色板颜色 \\033]4;1;rgb:FF/00/00\\007（红） 使用\\033]4;颜色索引;default\\007恢复默认 8 创建超链接 \\033]8;;https://example.com\\033\\\\点击\\033]8;;\\033\\\\ 必须使用\\033]8;;\\033\\\\终止 10 修改默认前景色（文本） \\033]10;rgb:FF/00/00\\007（红色） 11 修改默认背景色 \\033]11;rgb:00/00/80\\007（深蓝） 12 修改光标颜色 \\033]12;rgb:FF/FF/00\\007（黄色） ? 查询状态 \\033]10;?\\007查询前景色 总结 ANSI转义序列可以让终端的输出变得更漂亮，更像GUI，而且只是针对终端的一个标准，任何可编写终端应用的语言都可以使用。\n想当初刚学完c作为练手写的终端小游戏汉诺塔，若是当时掌握了这个知识点，展示效果绝对要上一个档次。\n虽然ANSI转义序列很酷，但写起来还是太啰嗦了，而且代码看起来也更乱，但果然还是封装一下再用会比较舒服，比如：fatih/color就是一个跨平台兼容性更好的设置终端颜色的库，与ANSI转义序列的颜色部分类似。\n","permalink":"https://afrusrsc.github.io/posts/program/misc/ansi_es/","summary":"起因 近来，翻看gin源码时，无意间看到了green = \u0026quot;\\033[97;42m\u0026quot;这种不明所以的代码，遂充满疑惑和好奇，于是就搜索探究了一番，这才知道这叫ANSI转义序列。\nANSI转义序列 简单说，就是一种标准化的终端控制序列，用于设置文本样式、颜色和背景等。先放个代码吧，以免不知所云。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { for i := 0; i \u0026lt;= 10; i++ { fmt.Printf(\u0026#34;这是\\033[%[1]dm\u0026lt;文本属性\u0026gt;%2[1]d\\033[0m\\n\u0026#34;, i) } s := []int{30, 31, 32, 33, 34, 35, 36, 37} for _, v := range s { fmt.Printf(\u0026#34;这是\\033[%[1]dm\u0026lt;16色标准前景色\u0026gt;%2[1]d\\033[0m\\t\\033[%[2]dm\u0026lt;16色亮前景色\u0026gt;%2[2]d\\033[0m\\n\u0026#34;, v, v+60) fmt.Printf(\u0026#34;这是\\033[%[1]dm\u0026lt;16色标准背景色\u0026gt;%2[1]d\\033[0m\\t\\033[%[2]dm\u0026lt;16色亮背景色\u0026gt;%2[2]d\\033[0m\\n\u0026#34;, v+10, v+70) } for i := 0; i \u0026lt; 256; i++ { fmt.","title":"ANSI转义序列"},{"content":"问题 业务中遇到一个非常慢的查询，大致可以简化为以下SQL：\n1 2 3 4 5 select * from t1 where c1 not in (...) and c2 not like \u0026#39;ABC%\u0026#39; and c3 in (...) and c4=-1 and c5\u0026gt;\u0026#39;2020-01-01,00:00:00\u0026#39; 其中：\n有索引且命中的条件已简化掉了\nc5为自定义格式的时间字符串\nc2和c5有索引（普通索引），c1、c3和c4无索引\nc3和c4为绑定条件\nc1、c3和c4均为小值域列\n分析 not in和not like会导致普通索引失效\n为小值域列添加普通索引无法提供预期的效果\nc3和c4为绑定条件，且条件固定不变，视为一体进行处理的话，可一定程度上扩充列的值域\nc5虽然已有索引，但字符串比较操作还是太低效\n解决方案 基于以上特殊的情形，搜索并尝试后发现，函数索引恰好可以达到预期，而使用的数据库又刚好支持（Oracel和PostgreSQL完全支持）。\n添加索引 将c1的not in手动改为in查询，即可利用已有索引\nc2的not like为后模糊查询，为其创建函数索引：\n1 CREATE INDEX idx_t1_func_c2 ON t1(CASE WHEN c2 NOT LIKE \u0026#39;ABC%\u0026#39; THEN 1 ELSE 0 END); 为c3和c4的绑定条件创建函数索引： 1 CREATE INDEX idx_t1_func_c3c4 ON t1(CASE WHEN c3 in (...) and c4=-1 THEN 1 ELSE 0 END); c5不能改变表数据类型，但可以转换为时间类型，为转换后的时间类型创建索引，即为c5创建函数索引： 1 CREATE INDEX idx_t1_func_c5 ON t1(to_date(c5, \u0026#39;YYYY-MM-DD,HH24:MI:SS\u0026#39;)); 修改查询 添加索引后，还需要按照索引使用相同的函数来改造条件语句，最终优化后的SQL：\n1 2 3 4 5 select * from t1 where c1 in (...) and (CASE WHEN c2 NOT LIKE \u0026#39;ABC%\u0026#39; THEN 1 ELSE 0 END)=1 and (CASE WHEN c3 in (...) and c4=-1 THEN 1 ELSE 0 END)=1 and to_date(c5, \u0026#39;YYYY-MM-DD,HH24:MI:SS\u0026#39;)\u0026gt;to_date(\u0026#39;2020-01-01,00:00:00\u0026#39;,\u0026#39;YYYY-MM-DD,HH24:MI:SS\u0026#39;) 效果 清除缓存测试，原查询大约需要57s，优化后大约13s。\n","permalink":"https://afrusrsc.github.io/posts/db/functional_index/","summary":"问题 业务中遇到一个非常慢的查询，大致可以简化为以下SQL：\n1 2 3 4 5 select * from t1 where c1 not in (...) and c2 not like \u0026#39;ABC%\u0026#39; and c3 in (...) and c4=-1 and c5\u0026gt;\u0026#39;2020-01-01,00:00:00\u0026#39; 其中：\n有索引且命中的条件已简化掉了\nc5为自定义格式的时间字符串\nc2和c5有索引（普通索引），c1、c3和c4无索引\nc3和c4为绑定条件\nc1、c3和c4均为小值域列\n分析 not in和not like会导致普通索引失效\n为小值域列添加普通索引无法提供预期的效果\nc3和c4为绑定条件，且条件固定不变，视为一体进行处理的话，可一定程度上扩充列的值域\nc5虽然已有索引，但字符串比较操作还是太低效\n解决方案 基于以上特殊的情形，搜索并尝试后发现，函数索引恰好可以达到预期，而使用的数据库又刚好支持（Oracel和PostgreSQL完全支持）。\n添加索引 将c1的not in手动改为in查询，即可利用已有索引\nc2的not like为后模糊查询，为其创建函数索引：\n1 CREATE INDEX idx_t1_func_c2 ON t1(CASE WHEN c2 NOT LIKE \u0026#39;ABC%\u0026#39; THEN 1 ELSE 0 END); 为c3和c4的绑定条件创建函数索引： 1 CREATE INDEX idx_t1_func_c3c4 ON t1(CASE WHEN c3 in (.","title":"使用函数索引优化特定查询"},{"content":"背景 系统安装完之后，默认的显卡驱动就能好好的工作，这点还是比较满意的，但用久了之后就会发现：看个高清视频啥的，CPU使用率就会蹭蹭上去，风扇呼呼的，总感觉N卡压根就没派上用场，所以就想换上Nvidia的闭源驱动看看效果。\n安装驱动 准备工作 修改/etc/apt/sources.list，在main后加入contrib non-free，已有则跳过\n禁用BIOS中的Secure Boot（！！！非常非常非常重要！！！）\n由于我一开始没有禁用Secure Boot，反复安装并修改了许多配置，浪费时间不说，原始安装能否像以下步骤那样光滑已无法考证，除非把系统也重装了。\n安装 更新包索引 1 sudo apt update 安装nvidia-detect 1 sudo apt install nvidia-detect 运行nvidia-detect，我的提示安装nvidia-driver即可\n安装nvidia-driver\n1 sudo apt install nvidia-driver 重启 双卡切换 Debian官方仓库中并没有nvidia-prime，所以使用envycontrol来实现。\n下载envycontrol\n安装\n1 sudo apt install ./python3-envycontrol_3.5.1-1_all.deb 查看当前显卡模式sudo envycontrol --query\n切换显卡\n1 2 3 sudo envycontrol -s integrated # 切换到 集显 sudo envycontrol -s hybrid # 切换到 混合模式 sudo envycontrol -s nvidia # 切换到 N卡 重启 ","permalink":"https://afrusrsc.github.io/posts/os/debian_nvidia_driver/","summary":"背景 系统安装完之后，默认的显卡驱动就能好好的工作，这点还是比较满意的，但用久了之后就会发现：看个高清视频啥的，CPU使用率就会蹭蹭上去，风扇呼呼的，总感觉N卡压根就没派上用场，所以就想换上Nvidia的闭源驱动看看效果。\n安装驱动 准备工作 修改/etc/apt/sources.list，在main后加入contrib non-free，已有则跳过\n禁用BIOS中的Secure Boot（！！！非常非常非常重要！！！）\n由于我一开始没有禁用Secure Boot，反复安装并修改了许多配置，浪费时间不说，原始安装能否像以下步骤那样光滑已无法考证，除非把系统也重装了。\n安装 更新包索引 1 sudo apt update 安装nvidia-detect 1 sudo apt install nvidia-detect 运行nvidia-detect，我的提示安装nvidia-driver即可\n安装nvidia-driver\n1 sudo apt install nvidia-driver 重启 双卡切换 Debian官方仓库中并没有nvidia-prime，所以使用envycontrol来实现。\n下载envycontrol\n安装\n1 sudo apt install ./python3-envycontrol_3.5.1-1_all.deb 查看当前显卡模式sudo envycontrol --query\n切换显卡\n1 2 3 sudo envycontrol -s integrated # 切换到 集显 sudo envycontrol -s hybrid # 切换到 混合模式 sudo envycontrol -s nvidia # 切换到 N卡 重启 ","title":"Debian安装Nvidia驱动"},{"content":"问题及原因 Debian安装过程中会有一个阶段下载特别慢，即便是在安装过程中更换了国内源，仍然是巨慢无比，其根本原因是：更换的源并不包含安全更新部分。\n当然，如果是网卡硬件不在默认的安装包驱动范围内，这种情况如果不在安装过程中安装相关驱动，压根也不会遇到下载慢的情况。如果使用的是最新的完整的DVD安装包，可能也不会遇到下载慢的情况。\n解决方案 断网安装 最简单的办法就是断网安装，安装完之后再彻底更换源，最后再进行更新。这也是比较适合小白的方案。\n至于断网的时机，可选择一开始就不联网，也可选择在下载慢的时候断网。建议小白选择后者。\n安装过程中彻底更换源 原理 安装过程其实本身就是运行了一个简版的、定制的linux系统，只不过整个安装过程是在其中一个终端中（命令终端或图形终端）完成的，那么，安装过程中自然可以从别的终端界入并完成更换源，如此即可解决下载过程巨慢的问题，同时，系统安装好之后也无需再考虑更换源的问题。\n具体操作 正常安装进行到选择国内源这一步\n按Ctrl+Alt+F2或Ctrl+Alt+F3进入终端，会有提示，直接回车\n注意：\nCtrl+Alt+F1为命令行安装终端，图形安装后台也使用该终端\nCtrl+Alt+F2和Ctrl+Alt+F3为暂未使用的命令行终端\nCtrl+Alt+F4为日志输出终端\nCtrl+Alt+F5为图形终端\n执行如下命令 1 2 cat /target/etc/apt/sources.list # /target 是正在安装的新系统的挂载点 如果第1.步选择完国内源之后没有继续，这里空的，或者只有deb cdrom: [pebian GNu/Linux 12.9.0Bookworm- 0fficial amd64 NETINST with irmware 20250111-10:54]/ bookworm contrib main non-free-firmware；如果第1.步选择完国内源之后继续了，并且此时已经进入下载阶段了，则会看到类似以下的内容：\n1 2 3 4 5 6 7 8 9 deb cdrom: [pebian GNu/Linux 12.9.0Bookworm- 0fficial amd64 NETINST with irmware 20250111-10:54]/ bookworm contrib main non-free-firmware deb http://mirrors.ustc.edu.cn/debian/ bookworm main non-free-firmware deb-src http://mirrors.ustc.edu.cn/debian/ bookworm main non-free-firmware deb http://security.debian.org/debian-security bookworm-security main non-free-firmware deb-src htto://security.debian.org/debian-security bookworm-security main non-free-firmware # bookworm-updates, to get updates before a point release is made; # see https://www.debian.org/doc/manuals/debian-reference/ch02.en.html#_updates_and_backports deb http://mirrors.ustc.edu.cn/debian/ bookworm-updates main non-free-firmware deb-src http://mirrors.ustc.edu.cn/debian/ bookworm-updates main non-free-firmware 从中可以看到security.debian.org并没有被替换成国内源的地址。\n执行如下命令，然后把security.debian.org替换为国内源的地址，把main non-free-firmware替换为main contrib non-free non-free-firmware 1 2 nano /target/etc/apt/sources.list # 没有 vi/vim，只有 nano 可用 替换完之后，按Ctrl+o保存，再按Ctrl+x退出nano编辑器\n按Ctrl+Alt+F1或Ctrl+Alt+F5回到安装界面，继续安装\n","permalink":"https://afrusrsc.github.io/posts/os/debian_install_slowly/","summary":"问题及原因 Debian安装过程中会有一个阶段下载特别慢，即便是在安装过程中更换了国内源，仍然是巨慢无比，其根本原因是：更换的源并不包含安全更新部分。\n当然，如果是网卡硬件不在默认的安装包驱动范围内，这种情况如果不在安装过程中安装相关驱动，压根也不会遇到下载慢的情况。如果使用的是最新的完整的DVD安装包，可能也不会遇到下载慢的情况。\n解决方案 断网安装 最简单的办法就是断网安装，安装完之后再彻底更换源，最后再进行更新。这也是比较适合小白的方案。\n至于断网的时机，可选择一开始就不联网，也可选择在下载慢的时候断网。建议小白选择后者。\n安装过程中彻底更换源 原理 安装过程其实本身就是运行了一个简版的、定制的linux系统，只不过整个安装过程是在其中一个终端中（命令终端或图形终端）完成的，那么，安装过程中自然可以从别的终端界入并完成更换源，如此即可解决下载过程巨慢的问题，同时，系统安装好之后也无需再考虑更换源的问题。\n具体操作 正常安装进行到选择国内源这一步\n按Ctrl+Alt+F2或Ctrl+Alt+F3进入终端，会有提示，直接回车\n注意：\nCtrl+Alt+F1为命令行安装终端，图形安装后台也使用该终端\nCtrl+Alt+F2和Ctrl+Alt+F3为暂未使用的命令行终端\nCtrl+Alt+F4为日志输出终端\nCtrl+Alt+F5为图形终端\n执行如下命令 1 2 cat /target/etc/apt/sources.list # /target 是正在安装的新系统的挂载点 如果第1.步选择完国内源之后没有继续，这里空的，或者只有deb cdrom: [pebian GNu/Linux 12.9.0Bookworm- 0fficial amd64 NETINST with irmware 20250111-10:54]/ bookworm contrib main non-free-firmware；如果第1.步选择完国内源之后继续了，并且此时已经进入下载阶段了，则会看到类似以下的内容：\n1 2 3 4 5 6 7 8 9 deb cdrom: [pebian GNu/Linux 12.9.0Bookworm- 0fficial amd64 NETINST with irmware 20250111-10:54]/ bookworm contrib main non-free-firmware deb http://mirrors.ustc.edu.cn/debian/ bookworm main non-free-firmware deb-src http://mirrors.","title":"解决Debian安装巨慢的问题"},{"content":"意外的乱码 在尝试用go操作pg数据库时，由于连接参数的笔误，意外得到了一条包含乱码的错误消息，很显然是字符编码的问题：win系统默认是gbk编码，debian一般都默认utf8编码，做一下编码转换就可以了。\n虽然很容易得到期望的结果，但还是引出了我很深的疑惑，因为这表现出了跨平台的不一致性，而这正是我一直都在设法避免的。\n环境说明 pg是在win10上的服务，安装方法见PostgreSQL zip 安装\ngo开发是在wsl2的debian上进行\n对比pg是在虚拟机的debian上，安装方法见Debian上安装PostgreSQL\n排查 统一服务端编码 \\l命令查看，win上的pg：Encoding是utf8，Collate和Ctype是cp932，即gbk；debian上的pg全部是utf8。\nwin上使用bin\\initdb -D data -U postgres -A password --locale=zh_CN.UTF-8 -E utf8 -W重新安装，全部变为utf8。\n此时进行测试，发现数据库连接成功之后的错误消息都是utf8的，但连接过程中的错误消息还是gbk。\n修改系统默认编码 修改windows的区域设置，勾选Beta版：使用 Unicode UTF-8 提供全球语言支持(U)，重启系统。\n此时进行测试，无论哪个环节，错误消息都是utf8。但这很可能会影响到其它程序，尤其是比较旧的程序或为了兼容旧系统的程序，因此，虽然可行，但还是不能采用。\n其它对比 使用Lazarus自带组件，配合libpq.dll，进行测试，在不修改系统默认编码的情况下，与go的程序表现一样。\n结论 目前，暂时无法通过修改配置使pg达到在windows和debian上的表现完全一致，但通过配置可以达到除连接成功前的错误消息编码外的一致性（至少暂未发现其它不一致处）。\n","permalink":"https://afrusrsc.github.io/posts/db/pgsql_errmsg/","summary":"意外的乱码 在尝试用go操作pg数据库时，由于连接参数的笔误，意外得到了一条包含乱码的错误消息，很显然是字符编码的问题：win系统默认是gbk编码，debian一般都默认utf8编码，做一下编码转换就可以了。\n虽然很容易得到期望的结果，但还是引出了我很深的疑惑，因为这表现出了跨平台的不一致性，而这正是我一直都在设法避免的。\n环境说明 pg是在win10上的服务，安装方法见PostgreSQL zip 安装\ngo开发是在wsl2的debian上进行\n对比pg是在虚拟机的debian上，安装方法见Debian上安装PostgreSQL\n排查 统一服务端编码 \\l命令查看，win上的pg：Encoding是utf8，Collate和Ctype是cp932，即gbk；debian上的pg全部是utf8。\nwin上使用bin\\initdb -D data -U postgres -A password --locale=zh_CN.UTF-8 -E utf8 -W重新安装，全部变为utf8。\n此时进行测试，发现数据库连接成功之后的错误消息都是utf8的，但连接过程中的错误消息还是gbk。\n修改系统默认编码 修改windows的区域设置，勾选Beta版：使用 Unicode UTF-8 提供全球语言支持(U)，重启系统。\n此时进行测试，无论哪个环节，错误消息都是utf8。但这很可能会影响到其它程序，尤其是比较旧的程序或为了兼容旧系统的程序，因此，虽然可行，但还是不能采用。\n其它对比 使用Lazarus自带组件，配合libpq.dll，进行测试，在不修改系统默认编码的情况下，与go的程序表现一样。\n结论 目前，暂时无法通过修改配置使pg达到在windows和debian上的表现完全一致，但通过配置可以达到除连接成功前的错误消息编码外的一致性（至少暂未发现其它不一致处）。","title":"PostgreSQL错误消息在win和linux上的差异"},{"content":"背景 文件去重功能做好了，但当文件比较多或文件比较大的时候，耗时也会比较久，想加个进度条来直观显示处理进度。\n简单尝试了下github.com/schollz/progressbar这个库，完全能满足目前的需求。\n使用 安装 1 go get -u github.com/schollz/progressbar/v3 # 注意带版本v3 一般使用 1 2 3 4 5 6 bar := progressbar.Default(n, \u0026#34;描述\u0026#34;) defer bar.Close() i := 0; i \u0026lt; n; i++ { bar.Add(1) // 工作代码 } n为总数，当n\u0026gt;0时，显示的是常规的进度条；当n=-1时，显示一个计数的进度。\n还有其它比较细的控制及其它场景的使用，等有空了再细细研究下。\n","permalink":"https://afrusrsc.github.io/posts/program/go/go_progressbar/","summary":"背景 文件去重功能做好了，但当文件比较多或文件比较大的时候，耗时也会比较久，想加个进度条来直观显示处理进度。\n简单尝试了下github.com/schollz/progressbar这个库，完全能满足目前的需求。\n使用 安装 1 go get -u github.com/schollz/progressbar/v3 # 注意带版本v3 一般使用 1 2 3 4 5 6 bar := progressbar.Default(n, \u0026#34;描述\u0026#34;) defer bar.Close() i := 0; i \u0026lt; n; i++ { bar.Add(1) // 工作代码 } n为总数，当n\u0026gt;0时，显示的是常规的进度条；当n=-1时，显示一个计数的进度。\n还有其它比较细的控制及其它场景的使用，等有空了再细细研究下。","title":"Go命令行加进度条"},{"content":"背景 想自己做这个功能，主要是因为Duplicate Cleaner这个商业软件只有几天的试用时间，而且文件去重这个逻辑也非常简单。\ngraph TD a[获取文件清单及大小] --\u003e b[按大小分组] --\u003e c[排除只有一个文件的组] --\u003e d[计算文件Hash值] --\u003e e[按Hash值分组] --\u003e f[排除只有一个文件的组] --\u003e g[选择需要删除的文件] --\u003e h[删除] 问题 计算文件Hash值，使用了hash.Hash接口，自然也用到了goroutine来缩短耗时，但是在测试的时候发现功能不太好用，时好时坏，准确说是有时能获取到重复列表，有时不能。\n一点点排查，并且把代码段发给DeepSeek，最终确定是因为hash.Hash不是并发安全的。\n修复方法很简单，只要在goroutine内实例化即可。修改之后达到了预期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func calcHashs(files []*FileInfo, hashName string) { g := sync.WaitGroup{} for _, file := range files { g.Add(1) go func(f *FileInfo) { defer g.Done() h := newHash(hashName) hashValue, err := calcHash(f.Path, h) if err != nil { log.Printf(\u0026#34;计算文件 %s 的哈希值失败: %v\u0026#34;, f.Path, err) return } f.Hash = hashValue }(file) } g.Wait() } TODO 以上存在一个隐患，即：当文件过多时，goroutine会爆炸，至于会有什么影响，没有进行测试，也没敢测试，担心把机器干翻。整体功能做完后，下一步进行这一处的优化。\n题外话 计算Hash值这部分，专门准备了约15G的测试文件，和Duplicate Cleaner比较了一下，为此还用Lazarus写了同样的功能，三者一起比较。结果不得不令人叹服：\ngo和Lazarus的耗时非常接近，但Duplicate Cleaner只用了go和Lazarus一半的时间\ngo不同hash算法之间耗会有几十秒不等的差异，Duplicate Cleaner各算法耗时只有几秒的差异\n看来收费果然是有收费的理由的！\n","permalink":"https://afrusrsc.github.io/posts/program/go/go_duplicate_cleaner/","summary":"背景 想自己做这个功能，主要是因为Duplicate Cleaner这个商业软件只有几天的试用时间，而且文件去重这个逻辑也非常简单。\ngraph TD a[获取文件清单及大小] --\u003e b[按大小分组] --\u003e c[排除只有一个文件的组] --\u003e d[计算文件Hash值] --\u003e e[按Hash值分组] --\u003e f[排除只有一个文件的组] --\u003e g[选择需要删除的文件] --\u003e h[删除] 问题 计算文件Hash值，使用了hash.Hash接口，自然也用到了goroutine来缩短耗时，但是在测试的时候发现功能不太好用，时好时坏，准确说是有时能获取到重复列表，有时不能。\n一点点排查，并且把代码段发给DeepSeek，最终确定是因为hash.Hash不是并发安全的。\n修复方法很简单，只要在goroutine内实例化即可。修改之后达到了预期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func calcHashs(files []*FileInfo, hashName string) { g := sync.WaitGroup{} for _, file := range files { g.Add(1) go func(f *FileInfo) { defer g.Done() h := newHash(hashName) hashValue, err := calcHash(f.","title":"用Go写一个文件去重工具"},{"content":"背景 鸟枪换大炮，把旧电脑的HDD升级成SSD了，是替换而非加装，所以需要重新安装系统。\n依旧是安装windows+linux双系统，由于windows安装时会覆盖EFI分区，不想折腾的话就先装windows再装linux。\n手里有windows的安装盘（原版iso，不带pe），安装时分区会自动分出来100M的EFI分区，但装双系统的话，很可能会不够用，但又不想再烧个pe，也不想装完系统再折腾分区。\n尝试过程中发现可以进入命令提示符，于是网上搜索命令行分区工具，找到了DiskPart，尝试后可以完美实现需求。\n解决方案 使用安装盘引导启动，进入到分区界面\n取消安装，回到初始界面\n按win+r会跳出一个新的界面，找到命令提示符并运行\n输入diskpart回车，进入分区工具\nlist disk列出磁盘列表，记住需要分区的磁盘号\nselect disk n选择要分区的磁盘（n为上一步查出的磁盘号）\nclean all删除所有分区（如果有的话）\nconvert gpt将磁盘转换为GPT分区列表（这年头就不要再用MBR了）\ncreate partition efi size=512创建512M的EFI分区\nexit退出分区工具\n关闭命令提示符\n继续安装\n注意 该方案适用于win10，其它版本windows未测试！\n","permalink":"https://afrusrsc.github.io/posts/os/win_efi/","summary":"背景 鸟枪换大炮，把旧电脑的HDD升级成SSD了，是替换而非加装，所以需要重新安装系统。\n依旧是安装windows+linux双系统，由于windows安装时会覆盖EFI分区，不想折腾的话就先装windows再装linux。\n手里有windows的安装盘（原版iso，不带pe），安装时分区会自动分出来100M的EFI分区，但装双系统的话，很可能会不够用，但又不想再烧个pe，也不想装完系统再折腾分区。\n尝试过程中发现可以进入命令提示符，于是网上搜索命令行分区工具，找到了DiskPart，尝试后可以完美实现需求。\n解决方案 使用安装盘引导启动，进入到分区界面\n取消安装，回到初始界面\n按win+r会跳出一个新的界面，找到命令提示符并运行\n输入diskpart回车，进入分区工具\nlist disk列出磁盘列表，记住需要分区的磁盘号\nselect disk n选择要分区的磁盘（n为上一步查出的磁盘号）\nclean all删除所有分区（如果有的话）\nconvert gpt将磁盘转换为GPT分区列表（这年头就不要再用MBR了）\ncreate partition efi size=512创建512M的EFI分区\nexit退出分区工具\n关闭命令提示符\n继续安装\n注意 该方案适用于win10，其它版本windows未测试！","title":"祼盘安装win10时调整EFI分区大小"},{"content":"gin版本v1.10.0\n包函数 方法 含义 说明 BasicAuth 创建一个HTTP基本认证（Basic HTTP Authorization）的中间件 底层调用BasicAuthForRealm BasicAuthForProxy 创建一个HTTP代理基本认证（Basic HTTP Proxy - Authorization）的中间件 BasicAuthForRealm 创建一个HTTP基本认证（Basic HTTP Authorization）的中间件 Bind 创建一个用于将请求中的数据绑定到指定的接口对象上的中间件 CreateTestContext 创建一个干净的Engine实例和一个与之关联的上下文对象用于测试 CreateTestContextOnly 在已有的Engine实例基础上创建一个独立的上下文用于测试 CustomRecovery 根据自定义的处理函数创建一个恢复中间件 底层调用CustomRecoveryWithWriter CustomRecoveryWithWriter 创建一个自定义的恢复中间件 Default 返回一个默认的Engine实例 默认含Logger和Recovery两个中间件 Dir 返回一个http.FileSystem接口的实现，该实现可被http.FileServer使用 DisableBindValidation 关闭默认的验证器 DisableConsoleColor 禁用控制台的颜色输出 EnableJsonDecoderDisallowUnknownFields 开启JSON解码器的DisallowUnknownFields功能 即遇到未知字段时就报错 EnableJsonDecoderUseNumber 开启JSON解码器的UseNumber功能 即将数字解码为json.Number类型，而不是float64，以在需要时精确地转换为整数或浮点数，从而避免精度丢失的问题 ErrorLogger 创建一个能够处理任意类型的错误的中间件 底层调用ErrorLoggerT ErrorLoggerT 创建一个能够处理指定类型的错误的中间件 ForceConsoleColor 强制在控制台输出带有颜色的内容 IsDebugging 判断当前框架是否处于调试模式 Logger 使用默认配置来创建一个日志中间件 底层调用LoggerWithConfig LoggerWithConfig 根据传入的配置来创建一个日志中间件 LoggerWithFormatter 根据指定的格式来创建一个日志中间件 底层调用LoggerWithConfig LoggerWithWriter 根据指定的输出目标创建一个日志中间件 底层调用LoggerWithConfig Mode 返回当前Gin框架的运行模式 有debug、release和test三种模式 New 返回一个全新的、没有任何中间件的Engine实例 Recovery 使用默认配置创建一个恢复中间件 底层调用RecoveryWithWriter RecoveryWithWriter 根据指定输出目标创建一个恢复中间件 底层调用CustomRecoveryWithWriter SetMode 设置gin框架的运行模式 WrapF 将标准的http.HandlerFunc类型的处理函数包装成Gin框架的中间件 WrapH 将标准的http.Handler类型的对象包装成Gin框架的中间件 IRouter接口 IRouter定义了所有的路由处理接口，包括单个路由和分组路由的处理接口。\n方法 含义 说明 Any 注册一个能匹配所有HTTP方法的路由 DELETE 注册一个DELETE方法的路由 GET 注册一个GET方法的路由 Group 创建一个路由组，可以将所有具有共同中间件或相同路径前缀的路由添加到这个组中 HEAD 注册一个HEAD方法的路由 Handle 根据给定的路径和HTTP方法注册一个新的请求处理函数和中间件 Match 注册一个能匹配指定HTTP方法的路由 通常用于多个方法 OPTIONS 注册一个OPTIONS方法的路由 PATCH 注册一个PATCH方法的路由 POST 注册一个POST方法的路由 PUT 注册一个PUT方法的路由 Static 从指定的文件系统根目录提供静态文件服务 底层调用StaticFS StaticFS 从自定义的http.FileSystem接口实现提供静态文件服务 StaticFile 注册一个单独的路由，以提供本地文件系统中的单个文件的服务 如favicon.ico StaticFileFS 从自定义的http.FileSystem接口实现提供单个文件的服务 Use 为路由组添加中间件 RouterGroup RouterGroup实现了IRouter接口。\n方法 含义 说明 BasePath 返回路由组的基础路径 Engine Engine是框架的实例（基于RouterGroup），包含了路由多路复用器、中间件和配置设置。\n方法 含义 说明 Delims 用于设置模板的左右分隔符 HandleContext 用于重新处理一个已被重写的上下文 可能会陷入循环处理的情况，慎用 Handler LoadHTMLFiles 加载一个HTML文件切片，并将加载结果与HTML渲染器关联起来 LoadHTMLGlob 通过glob模式来识别并加载HTML文件，然后将加载结果与HTML渲染器关联起来 NoMethod 设置当Engine.HandleMethodNotAllowed=true时被调用的处理函数 当出现方法不允许的情况时，这些处理函数会被调用，从而可以返回自定义的错误信息、页面或执行其他逻辑 NoRoute 为未匹配到路由的情况添加处理函数 Routes 返回一个已注册路由的切片 Run 根据指定的网络地址启动http服务 RunFd 根据指定的文件描述符启动http服务 底层调用RunListener RunListener 根据已有的net.Listener接口启动http服务 RunTLS 根据指定的网络地址、证书等启动https服务 RunUnix 根据指定的Unix套接字文件启动http服务 SecureJsonPrefix 用于设置c.SecureJSON方法中所使用的安全JSON前缀 在调用c.SecureJSON返回JSON数组时生效 ServeHTTP SetFuncMap 用于设置template.FuncMap所使用的函数映射 SetHTMLTemplate 用于将一个模板与HTML渲染器关联起来 SetTrustedProxies 用于设置一个受信任的网络源列表 With 使用所提供的选项创建并返回一个新的Engine实例 Context 方法 含义 说明 Abort 中断请求的后续处理链，但不影响当前正在执行的处理 AbortWithError 中断请求的后续处理链，并将错误信息记录到c.Errors切片中 内部调用AbortWithStatus和Error AbortWithStatus 中断请求的后续处理链，并在响应头中返回指定的HTTP状态码 内部调用Status和Abort AbortWithStatusJSON 中断请求的后续处理链，并在响应头中返回指定的HTTP状态码，响应体中返回指定的JSON 内部调用Abort和JSON AddParam 将参数添加到Gin的上下文对象中；另一个重要作用是为了端到端测试 AsciiJSON 将一个结构体序列化为JSON格式（其中的Unicode字符转换为ASCII字符）响应 Bind 根据请求的方法和Content-Type头信息自动选择合适的绑定引擎，将请求体中的数据解析并绑定到指定的结构体指针中 内部调用MustBindWith BindHeader 使用binding.Header绑定请求的数据 内部调用MustBindWith BindJSON 使用binding.JSON绑定请求的数据 内部调用MustBindWith BindQuery 使用binding.Query绑定请求的数据 内部调用MustBindWith BindTOML 使用binding.TOML绑定请求的数据 内部调用MustBindWith BindUri 将请求的URI（统一资源标识符）中的参数绑定到传入的结构体指针指向的结构体上 内部调用ShouldBindUri BindWith 使用指定的绑定引擎将请求的数据绑定到传入的结构体指针指向的结构体上 已弃用，建议使用MustBindWith或ShouldBindWith BindXML 使用binding.XML绑定请求的数据 内部调用MustBindWith BindYAML 使用binding.YAML绑定请求的数据 内部调用MustBindWith ClientIP 通过一种尽力而为的算法来获取发起请求的真实客户端IP地址 ContentType 返回请求中Content-Type请求头的值 Cookie 从请求中获取指定名称的Cookie值 返回的Cookie值是经过反编码处理的，且同名的Cookie只会返回其中一个 Copy 返回当前上下文的一个副本 需要将上下文传递给一个新的goroutine时必须使用 Data 将指定的数据写入响应的主体流中，同时更新响应的状态码 内部调用Render DataFromReader 将指定的io.Reader中的数据写入到响应的主体流中，同时更新响应的状态码 内部调用Render Deadline 返回该上下文的截止时间 DefaultPostForm 从POST请求的application/x-www-form-urlencoded格式表单或multipart/form-data格式表单中获取指定键对应的值，若不存在则使用默认值 内部使用GetPostForm DefaultQuery 从请求的URL查询字符串中获取指定键对应的值，若不存在则使用默认值 内部使用GetQuery Done 返回一个只读通道，当上下文被取消（比如调用c.CancelFunc）或者超时（使用c.WithTimeout等方法）时，该通道会被关闭。可以通过监听这个通道来感知上下文的状态变化，从而做出相应的处理 Err 用于获取上下文被取消或超时时的错误信息 Error 将错误信息附加到当前的上下文（Context）中的错误列表里，以便后续统一处理 传入nil错误会导致panic File 将指定的文件以高效的方式写入响应的主体流中 FileAttachment 将指定的文件以高效的方式写入响应的主体流中，并设置响应头中的Content-Disposition字段 FileFromFS 从指定的http.FileSystem中读取文件，并将文件内容以高效的方式写入响应的主体流中 FormFile 从POST请求的表单数据（通常是multipart/form-data格式）中获取指定表单键对应的第一个文件 FullPath 返回当前请求所匹配到的路由的完整路径 Get 从上下文中获取指定键对应的值，同时返回该键是否存在 GetBool 从上下文中获取指定键对应的值，并将其转换为bool类型返回 内部调用Get GetDuration 从上下文中获取指定键对应的值，并将其转换为duration类型返回 内部调用Get GetFloat64 从上下文中获取指定键对应的值，并将其转换为float64类型返回 内部调用Get GetHeader 从请求头中获取指定键对应的值 GetInt 从上下文中获取指定键对应的值，并将其转换为int类型返回 内部调用Get GetInt64 从上下文中获取指定键对应的值，并将其转换为int64类型返回 内部调用Get GetPostForm 从POST请求的application/x-www-form-urlencoded格式表单或multipart/form-data格式表单中获取指定键对应的值 内部调用GetPostFormArray GetPostFormArray 从POST请求的application/x-www-form-urlencoded格式表单或multipart/form-data格式表单中获取指定键对应的所有值，并以字符串切片的形式返回；同时返回该键是否至少存在一个与之对应的值 GetPostFormMap 从POST请求的表单数据里获取指定键对应的map类型的值，并返回该键是否存在 GetQuery 从请求的URL查询字符串中获取指定键对应的值，并返回该键是否存在 内部调用GetQueryArray GetQueryArray 从请求的URL查询字符串中获取指定键对应的所有值，并以字符串切片的形式返回；同时返回该键是否至少存在一个与之对应的值 GetQueryMap 从请求的URL查询字符串里获取指定键对应的map类型的值，并返回该键是否存在 GetRawData 获取请求体中的原始数据流数据 GetString 从上下文中获取指定键对应的值，并将其转换为string类型返回 内部调用Get GetStringMap 从上下文中获取指定键对应的值，并将其转换为map[string]any类型返回 内部调用Get GetStringMapString 从上下文中获取指定键对应的值，并将其转换为map[string]string类型返回 内部调用Get GetStringMapStringSlice 从上下文中获取指定键对应的值，并将其转换为map[string][]string类型返回 内部调用Get GetStringSlice 从上下文中获取指定键对应的值，并将其转换为[]string类型返回 内部调用Get GetTime 从上下文中获取指定键对应的值，并将其转换为time.Time类型返回 内部调用Get GetUint 从上下文中获取指定键对应的值，并将其转换为uint类型返回 内部调用Get GetUint64 从上下文中获取指定键对应的值，并将其转换为uint64类型返回 内部调用Get HTML 渲染指定文件名的HTTP模板，同时更新响应状态码 Handler 返回主处理器，即最后一个处理函数 HandlerName 返回主处理器的名称 名称会包含包名 HandlerNames 返回当前上下文中所有已注册处理器的名称列表 Header 设置响应头信息，若值为空字符串则删除对应项 IndentedJSON 将给定的结构体序列化为格式化后的JSON（带有缩进和换行符）写入响应体 比较消耗资源和带宽 IsAborted 判断当前的上下文是否已经被中止 IsWebsocket 判断客户端发送的请求是否是WebSocket握手 JSON 将给定的结构体序列化为JSON写入响应体 响应的Content-Type为application/json JSONP 将给定的结构体序列化为JSON格式，并在响应体中添加填充以实现从与客户端不同域名的服务器请求数据 响应的Content-Type为application/javascript MultipartForm 获取multipart/form-data类型的表单请求的解析结果，包含了表单中的所有字段和上传的文件信息 MustBindWith 使用指定的绑定引擎将请求的数据绑定到传入的结构体指针上 内部调用ShouldBindWith MustGet 从上下文中获取指定键对应的值，若不存在则触发panic 内部调用Get Negotiate 根据客户端请求头中Accept字段指定的可接受格式，调用不同的渲染器生成合适的响应内容 内部用到了NegotiateFormat NegotiateFormat 从客户端请求头的Accept字段里，结合服务器所支持的格式，协商出一个可接受的响应格式并返回 Next 用于中间件中，让当前处理流程继续执行后续的中间件和最终的处理函数，当后续的处理完成后，控制权会返回到调用Next方法的位置，继续执行该中间件剩余的代码 专为中间件设计，不应在普通的路由处理函数中使用 Param 从URL路径中提取指定参数的值 PostForm 从POST请求的application/x-www-form-urlencoded格式表单或multipart/form-data格式表单中获取指定键对应的值 内部调用GetPostForm PostFormArray 从POST请求的application/x-www-form-urlencoded格式表单或multipart/form-data格式表单中获取指定键对应的所有值 内部调用GetPostFormArray PostFormMap 从POST请求的表单数据中获取指定表单键所对应的map[string]string类型的值 内部调用GetPostFormMap ProtoBuf 将给定的结构体序列化为ProtoBuf写入响应体 PureJSON 将给定的结构体序列化为JSON写入响应体，但会直接保留原始的特殊HTML字符 Query 从请求的URL查询字符串中获取指定键对应的值，若不存在返回空字符串 内部调用GetQuery QueryArray 从请求的URL查询字符串中获取指定键对应的所有值，并以字符串切片的形式返回 内部调用GetQueryArray QueryMap 从请求的URL查询字符串中获取指定键对应的map[string]string值 内部调用GetQuery Redirect 将客户端的请求重定向到指定的位置 RemoteIP 从请求的Request.RemoteAddr字段中解析出客户端的IP地址 Render 设置响应头信息，然后调用传入的渲染器的Render方法来将数据渲染到响应体中 SSEvent 向响应的主体流中写入一个服务器发送事件SSE 单向通信，即只能服务器向客户端推送数据 SaveUploadedFile 将客户端通过表单上传的文件保存到服务器指定的目标路径 SecureJSON 将给定的结构体序列化为JSON写入响应体，若数据为数组则在前面添加安全前缀 默认前缀为while(1), Set 在当前的上下文中存储一个新的键值对 常用于在不同中间件和处理函数之间方便地共享数据 SetAccepted 设置请求头中的Accept字段的数据 SetCookie 在响应头中添加Set-Cookie字段，从而在客户端浏览器中设置Cookie SetSameSite 设置Cookie的SameSite属性 ShouldBind 依据请求的方法和Content-Type头，自动挑选合适的绑定引擎，把请求体中的数据绑定到指定的结构体指针上 绑定失败不会自动设置响应状态码或终止请求处理。内部调用ShouldBindWith ShouldBindBodyWith 使用指定的绑定引擎将请求中的数据绑定到传入的结构体指针上，但会将请求体的数据存储在上下文中 ShouldBindBodyWithJSON 使用binding.JSON绑定引擎将请求中的数据绑定到传入的结构体指针上，并将请求体的数据存储在上下文中 内部调用ShouldBindBodyWith ShouldBindBodyWithTOML 使用binding.TOML绑定引擎将请求中的数据绑定到传入的结构体指针上，并将请求体的数据存储在上下文中 内部调用ShouldBindBodyWith ShouldBindBodyWithXML 使用binding.XML绑定引擎将请求中的数据绑定到传入的结构体指针上，并将请求体的数据存储在上下文中 内部调用ShouldBindBodyWith ShouldBindBodyWithYAML 使用binding.YAML绑定引擎将请求中的数据绑定到传入的结构体指针上，并将请求体的数据存储在上下文中 内部调用ShouldBindBodyWith ShouldBindHeader 使用binding.Header绑定引擎将请求中的数据绑定到传入的结构体指针上 内部调用ShouldBindWith ShouldBindJSON 使用binding.JSON绑定引擎将请求中的数据绑定到传入的结构体指针上 内部调用ShouldBindWith ShouldBindQuery 使用binding.Query绑定引擎将请求中的数据绑定到传入的结构体指针上 内部调用ShouldBindWith ShouldBindTOML 使用binding.TOML绑定引擎将请求中的数据绑定到传入的结构体指针上 内部调用ShouldBindWith ShouldBindUri 使用指定的绑定引擎将请求的URI中的参数绑定到传入的结构体指针所指向的结构体实例上 ShouldBindWith 使用指定的绑定引擎将请求中的数据绑定到传入的结构体指针上 ShouldBindXML 使用binding.XML绑定引擎将请求中的数据绑定到传入的结构体指针上 内部调用ShouldBindWith ShouldBindYAML 使用binding.YAML绑定引擎将请求中的数据绑定到传入的结构体指针上 内部调用ShouldBindWith Status 设置响应的状态码 Stream 用于发送流式响应 String 将给定的字符串写入响应体中 TOML 将给定的结构体序列化为TOML写入响应体 Value 从当前的Context中获取与指定键关联的值 内部调用Get XML 将给定的结构体序列化为XML写入响应体 YAML 将给定的结构体序列化为YAML写入响应体 使用小结 读取请求 来源 详情 方法 备注 请求路径 路由参数 Param、BindUri、ShouldBindUri、FullPath 适用于RESTful参数，如：http://localhost/user/123 - 查询参数 Query、DefaultQuery、GetQuery、QueryArray、GetQueryArray、QueryMap、GetQueryMap 适用于传统查询参数，如：http://localhost/user?id=123 请求体 表单 DefaultPostForm、GetPostForm、GetPostFormArray、GetPostFormMap、MultipartForm application/x-www-form-urlencoded或multipart/form-data - 文件 FormFile、SaveUploadedFile multipart/form-data - 原始流 GetRawData - json BindJSON、ShouldBindBodyWithJSON - xml BindXML、ShouldBindBodyWithXML - toml BindTOML、ShouldBindBodyWithTOML - yaml BindYAML、ShouldBindBodyWithYAML 请求头 Cookies Cookie - Content-Type ContentType - 普通头 GetHeader、BindHeader、ShouldBindHeader 响应 位置 详情 方法 备注 响应状态码 Status 响应头 普通头 Header - Accept SetAccepted - Cookies SetCookie 响应体 普通文本 String - 页面 HTML - json JSON、JSONP、IndentedJSON、AsciiJSON、PureJSON、SecureJSON - xml XML - ProtoBuf ProtoBuf - toml TOML - yaml YAML - 流 Stream - 文件 File、FileAttachment、FileFromFS - SSE事件 SSEvent 流程控制 类型 方法 备注 中止 Abort、AbortWithError、AbortWithStatus、AbortWithStatusJSON 继续下一个 Next 对中间件很重要 重定向 Redirect ","permalink":"https://afrusrsc.github.io/posts/program/go/go_gin_funclist/","summary":"gin版本v1.10.0\n包函数 方法 含义 说明 BasicAuth 创建一个HTTP基本认证（Basic HTTP Authorization）的中间件 底层调用BasicAuthForRealm BasicAuthForProxy 创建一个HTTP代理基本认证（Basic HTTP Proxy - Authorization）的中间件 BasicAuthForRealm 创建一个HTTP基本认证（Basic HTTP Authorization）的中间件 Bind 创建一个用于将请求中的数据绑定到指定的接口对象上的中间件 CreateTestContext 创建一个干净的Engine实例和一个与之关联的上下文对象用于测试 CreateTestContextOnly 在已有的Engine实例基础上创建一个独立的上下文用于测试 CustomRecovery 根据自定义的处理函数创建一个恢复中间件 底层调用CustomRecoveryWithWriter CustomRecoveryWithWriter 创建一个自定义的恢复中间件 Default 返回一个默认的Engine实例 默认含Logger和Recovery两个中间件 Dir 返回一个http.FileSystem接口的实现，该实现可被http.FileServer使用 DisableBindValidation 关闭默认的验证器 DisableConsoleColor 禁用控制台的颜色输出 EnableJsonDecoderDisallowUnknownFields 开启JSON解码器的DisallowUnknownFields功能 即遇到未知字段时就报错 EnableJsonDecoderUseNumber 开启JSON解码器的UseNumber功能 即将数字解码为json.Number类型，而不是float64，以在需要时精确地转换为整数或浮点数，从而避免精度丢失的问题 ErrorLogger 创建一个能够处理任意类型的错误的中间件 底层调用ErrorLoggerT ErrorLoggerT 创建一个能够处理指定类型的错误的中间件 ForceConsoleColor 强制在控制台输出带有颜色的内容 IsDebugging 判断当前框架是否处于调试模式 Logger 使用默认配置来创建一个日志中间件 底层调用LoggerWithConfig LoggerWithConfig 根据传入的配置来创建一个日志中间件 LoggerWithFormatter 根据指定的格式来创建一个日志中间件 底层调用LoggerWithConfig LoggerWithWriter 根据指定的输出目标创建一个日志中间件 底层调用LoggerWithConfig Mode 返回当前Gin框架的运行模式 有debug、release和test三种模式 New 返回一个全新的、没有任何中间件的Engine实例 Recovery 使用默认配置创建一个恢复中间件 底层调用RecoveryWithWriter RecoveryWithWriter 根据指定输出目标创建一个恢复中间件 底层调用CustomRecoveryWithWriter SetMode 设置gin框架的运行模式 WrapF 将标准的http.","title":"Gin功能列表"},{"content":"前置知识 Windows上叫动态链接库，通常以*.dll形式命名；Linux上叫共享库，通常以lib*.so形式命名。（此处统一叫动态库）\nWindows上dll路径的一般搜索顺序为：当前目录-\u0026gt;系统目录（如：C:\\Windows\\System32、C:\\Windows\\SysWOW64）-\u0026gt;Windows目录（如C:\\Windows）-\u0026gt;PATH环境变量指定的目录。\nLinux上so路径的一般搜索顺序为：编译时使用-rpath指定的路径-\u0026gt;LD_LIBRARY_PATH环境变量指定的路径-\u0026gt;系统默认库路径（如/lib、/usr/lib等）-\u0026gt;/etc/ld.so.conf和/etc/ld.so.conf.d/目录中配置的路径。\nLazarus/Delphi调用动态库有两种形式：静态调用和动态调用。\n静态调用：主程序启动时加载，若动态库不存在或不匹配，则主程序抛异常并中止；主程序退出时卸载。\n动态调用：主程序在需要时可随时加载，不需要时可随时卸载；动态库发生异常时，一般不会导致主程序中止。\n使用动态库 动态库 动态库本身不需要特殊设置，正常编译、构建即可。（以名为dll的动态库为例，实际文件名为libdll.so）\n主程序 编译时 静态调用方式 主程序直接编译会报错：Warning: linker:/usr/bin/ld: cannot find -ldll: No such file or directory，意思是链接器找不到名为dll的动态库文件。\n解决方案 打开Project Options-\u0026gt;Compiler Options-\u0026gt;Compilation and Linking，勾选Pass options to linker with \u0026quot;-k\u0026quot;, delimiter is space，并在下方填入-L’动态库所在路径’，保存即可正常编译。\n动态调用方式 主程序直接编译即可。\n运行时 静态调用方式 此时编译后的程序并不能正常运行，会报错error while loading shared libraries: libdll.so: cannot open shared object file: No such file or directory，意思是加载动态库时找不到名为libdll.so的动态库文件。\n这是前面提到的路径搜索顺序导致的，可将动态库放入相应的搜索路径下，也可使用-rpath指定路径。对于自定的动态库，建议使用-rpath指定路径，最好指定的路径为当前路径（与Windows保持一致）。\n解决方案 打开Project Options-\u0026gt;Compiler Options-\u0026gt;Compilation and Linking，勾选Pass options to linker with \u0026quot;-k\u0026quot;, delimiter is space，并在下方填入-rpath='$ORIGIN'（与之前的-L’动态库所在路径’之间要添加一个空格），保存并重新编译，即可正常运行。\n注：$ORIGIN代表程序所在的路径。\n动态调用方式 主程序可以正常运行，但并不能正常使用动态库的功能。打断点可发现LoadLibrary返回的句柄为0，主要原因与静态调用相同，即未找到动态库文件。\n解决方案 打开Project Options-\u0026gt;Compiler Options-\u0026gt;Compilation and Linking，勾选Pass options to linker with \u0026quot;-k\u0026quot;, delimiter is space，并在下方填入-rpath='$ORIGIN'，保存并重新编译，即可正常运行。\n注意事项 静态调用方案，代码中动态库名为*.so或lib*.so均可；动态调用方案，则必须为lib*.so。\n若动态库与主程序不在同一目录下，动态调用方案，只需将代码中动态库名改为动态库相对路径/lib*.so即可；静态调用方案，则需在-L中追加所有用到的动态库路径，在-rpath中追加动态库与主程序的相对路径。\n总结 为保证灵活性，避免过多的编译配置，建议使用动态调用方式，只需在Project Options-\u0026gt;Compiler Options-\u0026gt;Compilation and Linking中，勾选Pass options to linker with \u0026quot;-k\u0026quot;, delimiter is space，并在下方填入-rpath='$ORIGIN'，代码中指定好与主程序的相对路径即可。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_dll_linux/","summary":"前置知识 Windows上叫动态链接库，通常以*.dll形式命名；Linux上叫共享库，通常以lib*.so形式命名。（此处统一叫动态库）\nWindows上dll路径的一般搜索顺序为：当前目录-\u0026gt;系统目录（如：C:\\Windows\\System32、C:\\Windows\\SysWOW64）-\u0026gt;Windows目录（如C:\\Windows）-\u0026gt;PATH环境变量指定的目录。\nLinux上so路径的一般搜索顺序为：编译时使用-rpath指定的路径-\u0026gt;LD_LIBRARY_PATH环境变量指定的路径-\u0026gt;系统默认库路径（如/lib、/usr/lib等）-\u0026gt;/etc/ld.so.conf和/etc/ld.so.conf.d/目录中配置的路径。\nLazarus/Delphi调用动态库有两种形式：静态调用和动态调用。\n静态调用：主程序启动时加载，若动态库不存在或不匹配，则主程序抛异常并中止；主程序退出时卸载。\n动态调用：主程序在需要时可随时加载，不需要时可随时卸载；动态库发生异常时，一般不会导致主程序中止。\n使用动态库 动态库 动态库本身不需要特殊设置，正常编译、构建即可。（以名为dll的动态库为例，实际文件名为libdll.so）\n主程序 编译时 静态调用方式 主程序直接编译会报错：Warning: linker:/usr/bin/ld: cannot find -ldll: No such file or directory，意思是链接器找不到名为dll的动态库文件。\n解决方案 打开Project Options-\u0026gt;Compiler Options-\u0026gt;Compilation and Linking，勾选Pass options to linker with \u0026quot;-k\u0026quot;, delimiter is space，并在下方填入-L’动态库所在路径’，保存即可正常编译。\n动态调用方式 主程序直接编译即可。\n运行时 静态调用方式 此时编译后的程序并不能正常运行，会报错error while loading shared libraries: libdll.so: cannot open shared object file: No such file or directory，意思是加载动态库时找不到名为libdll.so的动态库文件。\n这是前面提到的路径搜索顺序导致的，可将动态库放入相应的搜索路径下，也可使用-rpath指定路径。对于自定的动态库，建议使用-rpath指定路径，最好指定的路径为当前路径（与Windows保持一致）。\n解决方案 打开Project Options-\u0026gt;Compiler Options-\u0026gt;Compilation and Linking，勾选Pass options to linker with \u0026quot;-k\u0026quot;, delimiter is space，并在下方填入-rpath='$ORIGIN'（与之前的-L’动态库所在路径’之间要添加一个空格），保存并重新编译，即可正常运行。","title":"Lazarus在Linux上使用自定义动态库"},{"content":"问题 由于经常会在windows和linux间交替写代码，因此也经常遇到使用git status查看有变更，使用git diff查看却没有看到差异的情况，原因有两种：\n换行符的差异\n文件权限的差异\n换行符 默认情况下，windows使用crlf做为换行符，linux使用lf做为换行符，不进行配置和处理的话，自然会出现上述情况。\n通常情况下，windows下的git进行如下配置：\n1 2 git config --global core.safecrlf true git config --global core.autocrlf true linux下进行如下配置：\n1 2 git config --global core.safecrlf true git config --global core.autocrlf input 如此，可解决绝大部分换行符问题，但对于需要精细化控制的场景显然不够，对此，可通过仓库的.gitattributes进行配置实现。\n1 2 *.bat text eol=crlf *.sh text eol=lf 文件权限 在windows下，准确说是windows的文件系统下（如ntfs），git init一个仓库时，其filemode默认是false，即忽略文件权限的变化；而linux的文件系统下（如ext4），其filemode默认是true，即跟踪文件权限的变化。若是在两者之间交替工作，或是拷贝文件，则会出现文件权限的变化，此时若filemode=true则会出现上述问题。\n一种是一刀切的方案，关闭filemode，即：\n1 git config --local core.fileMode false 另一种精细化的方案，自然还是借助.gitattributes进行配置：\n1 2 * -filemode *.sh filemode=755 ","permalink":"https://afrusrsc.github.io/posts/git/git_filemode/","summary":"问题 由于经常会在windows和linux间交替写代码，因此也经常遇到使用git status查看有变更，使用git diff查看却没有看到差异的情况，原因有两种：\n换行符的差异\n文件权限的差异\n换行符 默认情况下，windows使用crlf做为换行符，linux使用lf做为换行符，不进行配置和处理的话，自然会出现上述情况。\n通常情况下，windows下的git进行如下配置：\n1 2 git config --global core.safecrlf true git config --global core.autocrlf true linux下进行如下配置：\n1 2 git config --global core.safecrlf true git config --global core.autocrlf input 如此，可解决绝大部分换行符问题，但对于需要精细化控制的场景显然不够，对此，可通过仓库的.gitattributes进行配置实现。\n1 2 *.bat text eol=crlf *.sh text eol=lf 文件权限 在windows下，准确说是windows的文件系统下（如ntfs），git init一个仓库时，其filemode默认是false，即忽略文件权限的变化；而linux的文件系统下（如ext4），其filemode默认是true，即跟踪文件权限的变化。若是在两者之间交替工作，或是拷贝文件，则会出现文件权限的变化，此时若filemode=true则会出现上述问题。\n一种是一刀切的方案，关闭filemode，即：\n1 git config --local core.fileMode false 另一种精细化的方案，自然还是借助.gitattributes进行配置：\n1 2 * -filemode *.sh filemode=755 ","title":"Git管理文件权限"},{"content":"需求背景 在开发过程中，我们经常需要给应用添加版本信息，以便于追踪和管理应用的版本。\n对于windows平台，直接在Project-\u0026gt;Project Options...对话框中的Project Options-\u0026gt;Version Info内进行设置即可。\n但是，对于非windows平台，该方案便不可行。\n而且，该方案还存在一个明显的问题：版本信息需要手动维护，未能与版本控制系统进行有效关联，很可能出现应用与源码不一致的情况。\n解决思路 不使用Version Info功能，但取其把版本信息编译到可执行文件中的思想。\n借鉴vscode的关于方案，版本信息中包含版本号和提交ID即可使应用和源码进行关联。\n只要解决了在构建时动态获取版本信息的问题，便可以解决该问题。\n解决方案 经多种尝试，最终确定的方案如下：\n在源码中添加ver.inc文件，用于存储版本信息，在关于界面等进行展示。\n编写脚本，获取版本信息并写入ver.inc文件。\n打开Project-\u0026gt;Project Options...对话框，在Compiler Options-\u0026gt;Compiler Commands-\u0026gt;Execute before中添加脚本的路径。\n正常构建应用即可。\n如要跨平台，可分别编写对应平台的脚本并创建对应的Build mode，在Build modes中选择对应的模式，然后配置对应的脚本，正常构建即可。\n附脚本 以使用git为例：\nwindows 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @echo off ::获取版本号 git describe --tags \u0026gt;nul 2\u0026gt;nul if errorlevel 1 ( set VER_NO=0.0 ) else ( for /f \u0026#34;delims=\u0026#34; %%a in (\u0026#39;git describe --tags\u0026#39;) do set VER_NO=%%a ) ::获取提交id git rev-parse HEAD \u0026gt;nul 2\u0026gt;nul if errorlevel 1 ( set COMMIT_ID=0000000000000000000000000000000000000000 ) else ( for /f \u0026#34;delims=\u0026#34; %%b in (\u0026#39;git rev-parse HEAD\u0026#39;) do set COMMIT_ID=%%b ) ::写入文件 echo const \u0026gt; ver.inc echo VER_NO = \u0026#39;%VER_NO%\u0026#39;; \u0026gt;\u0026gt; ver.inc echo COMMIT_ID = \u0026#39;%COMMIT_ID%\u0026#39;; \u0026gt;\u0026gt; ver.inc linux 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/bin/bash # 获取版本号 VER_NO=$(git describe --tags 2\u0026gt;/dev/null) if [ $? -ne 0 ]; then VER_NO=\u0026#34;0.0\u0026#34; fi # 获取提交ID COMMIT_ID=$(git rev-parse HEAD 2\u0026gt;/dev/null) if [ $? -ne 0 ]; then COMMIT_ID=\u0026#34;0000000000000000000000000000000000000000\u0026#34; fi # 写入文件 echo \u0026#34;const\u0026#34; \u0026gt; ver.inc echo \u0026#34;VER_NO = \u0026#39;$VER_NO\u0026#39;;\u0026#34; \u0026gt;\u0026gt; ver.inc echo \u0026#34;COMMIT_ID = \u0026#39;$COMMIT_ID\u0026#39;;\u0026#34; \u0026gt;\u0026gt; ver.inc ","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_add_appver/","summary":"需求背景 在开发过程中，我们经常需要给应用添加版本信息，以便于追踪和管理应用的版本。\n对于windows平台，直接在Project-\u0026gt;Project Options...对话框中的Project Options-\u0026gt;Version Info内进行设置即可。\n但是，对于非windows平台，该方案便不可行。\n而且，该方案还存在一个明显的问题：版本信息需要手动维护，未能与版本控制系统进行有效关联，很可能出现应用与源码不一致的情况。\n解决思路 不使用Version Info功能，但取其把版本信息编译到可执行文件中的思想。\n借鉴vscode的关于方案，版本信息中包含版本号和提交ID即可使应用和源码进行关联。\n只要解决了在构建时动态获取版本信息的问题，便可以解决该问题。\n解决方案 经多种尝试，最终确定的方案如下：\n在源码中添加ver.inc文件，用于存储版本信息，在关于界面等进行展示。\n编写脚本，获取版本信息并写入ver.inc文件。\n打开Project-\u0026gt;Project Options...对话框，在Compiler Options-\u0026gt;Compiler Commands-\u0026gt;Execute before中添加脚本的路径。\n正常构建应用即可。\n如要跨平台，可分别编写对应平台的脚本并创建对应的Build mode，在Build modes中选择对应的模式，然后配置对应的脚本，正常构建即可。\n附脚本 以使用git为例：\nwindows 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @echo off ::获取版本号 git describe --tags \u0026gt;nul 2\u0026gt;nul if errorlevel 1 ( set VER_NO=0.0 ) else ( for /f \u0026#34;delims=\u0026#34; %%a in (\u0026#39;git describe --tags\u0026#39;) do set VER_NO=%%a ) ::获取提交id git rev-parse HEAD \u0026gt;nul 2\u0026gt;nul if errorlevel 1 ( set COMMIT_ID=0000000000000000000000000000000000000000 ) else ( for /f \u0026#34;delims=\u0026#34; %%b in (\u0026#39;git rev-parse HEAD\u0026#39;) do set COMMIT_ID=%%b ) ::写入文件 echo const \u0026gt; ver.","title":"Lazarus为应用添加版本信息"},{"content":"path包 path包仅适用于处理由正斜杠/分隔的路径，例如URL。\n不能处理带有盘符或反斜杠\\的Windows路径。\n包函数 方法 含义 说明 Base 返回路径的最后一个元素 会先移除路径末尾的斜杠，空路径返回.，纯斜杠返回/ Clean 返回与输入路径等效的最短路径名 Dir 返回路径的目录部分 Ext 返回路径中以.分隔的文件扩展名 无.则返回空字符串 IsAbs 判断路径是否为绝对路径 只有以/开头的才是绝对路径 Join 将路径元素连接成路径 Match 判断路径是否匹配模式 Split 将路径拆分为目录和文件 filepath包 处理方式与目标操作系统定义的文件路径相兼容。 包函数 方法 含义 说明 Abs 返回绝对路径 Base 返回路径的最后一个元素 会先移除路径末尾的斜杠，空路径返回.，纯斜杠返回/ Clean 返回与输入路径等效的最短路径名 Dir 返回路径的目录部分 EvalSymlinks 返回路径中的符号链接所指向的真实路径 Ext 返回路径中以.分隔的文件扩展名 无.则返回空字符串 FromSlash 将路径中/的斜杠替换为特定操作系统的分隔符字符 linux中的\\不会被替换 ToSlash 将路径中特定操作系统的分隔符字符替换为/ linux中的\\不会被替换 Glob 返回与模式匹配的所有路径 IsAbs 判断路径是否为绝对路径 只有以/开头的才是绝对路径 IsLocal 判断路径是否为本地路径，即是否在当前路径下 仅词法分析，不考虑文件系统 Join 将路径元素连接成路径 Localize 将一个以/分隔的路径转换为一个操作系统路径 Match 判断路径是否匹配模式 Rel 返回从basepath到targpath的相对路径 Split 将路径拆分为目录和文件 SplitList 将一个包含多个以特定操作系统路径分隔符（如:或;）分隔的路径字符串拆分成单个的路径元素 分隔符取决于当前操作系统 VolumeName 返回路径的卷名 适用于Windows平台 Walk 遍历路径下的所有目录和文件并对其调用fn WalkDir 遍历路径下的所有目录和文件并对其调用fn 比Walk更优更高效 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_path/","summary":"path包 path包仅适用于处理由正斜杠/分隔的路径，例如URL。\n不能处理带有盘符或反斜杠\\的Windows路径。\n包函数 方法 含义 说明 Base 返回路径的最后一个元素 会先移除路径末尾的斜杠，空路径返回.，纯斜杠返回/ Clean 返回与输入路径等效的最短路径名 Dir 返回路径的目录部分 Ext 返回路径中以.分隔的文件扩展名 无.则返回空字符串 IsAbs 判断路径是否为绝对路径 只有以/开头的才是绝对路径 Join 将路径元素连接成路径 Match 判断路径是否匹配模式 Split 将路径拆分为目录和文件 filepath包 处理方式与目标操作系统定义的文件路径相兼容。 包函数 方法 含义 说明 Abs 返回绝对路径 Base 返回路径的最后一个元素 会先移除路径末尾的斜杠，空路径返回.，纯斜杠返回/ Clean 返回与输入路径等效的最短路径名 Dir 返回路径的目录部分 EvalSymlinks 返回路径中的符号链接所指向的真实路径 Ext 返回路径中以.分隔的文件扩展名 无.则返回空字符串 FromSlash 将路径中/的斜杠替换为特定操作系统的分隔符字符 linux中的\\不会被替换 ToSlash 将路径中特定操作系统的分隔符字符替换为/ linux中的\\不会被替换 Glob 返回与模式匹配的所有路径 IsAbs 判断路径是否为绝对路径 只有以/开头的才是绝对路径 IsLocal 判断路径是否为本地路径，即是否在当前路径下 仅词法分析，不考虑文件系统 Join 将路径元素连接成路径 Localize 将一个以/分隔的路径转换为一个操作系统路径 Match 判断路径是否匹配模式 Rel 返回从basepath到targpath的相对路径 Split 将路径拆分为目录和文件 SplitList 将一个包含多个以特定操作系统路径分隔符（如:或;）分隔的路径字符串拆分成单个的路径元素 分隔符取决于当前操作系统 VolumeName 返回路径的卷名 适用于Windows平台 Walk 遍历路径下的所有目录和文件并对其调用fn WalkDir 遍历路径下的所有目录和文件并对其调用fn 比Walk更优更高效 ","title":"Go path包"},{"content":"Mutex 无需显式初始化，直接声明变量即可使用。\n互斥锁，同一时刻只能有一个协程持有锁，不分读写。\n方法 含义 说明 Lock 加锁 Unlock 解锁 未加锁时调用会导致panic TryLock 尝试加锁 立即返回，成功返回true，失败返回false RWMutex 无需显式初始化，直接声明变量即可使用。\n读写锁，同一时刻可以有多个协程持有读锁，但是只能有一个协程持有写锁。\n有写锁时，其他协程无法获取读锁和写锁。\n有读锁时，其他协程可以获取读锁，但是无法获取写锁。\n方法 含义 说明 RLock 加读锁 RUnlock 解读锁 未加读锁时调用会导致panic TryRLock 尝试加读锁 立即返回，成功返回true，失败返回false Lock 加写锁 Unlock 解写锁 未加写锁时调用会导致panic TryLock 尝试加写锁 立即返回，成功返回true，失败返回false Map 无需显式初始化，直接声明变量即可使用。 方法 含义 说明 Store 存储键值对 Load 加载键对应的值 Delete 删除键对应的值 Clear 清除所有键值对 Swap 交换指定键对应的旧值和新值，并返回旧值和操作之前键是否存在 LoadAndDelete 加载键对应的值并删除键值对 LoadOrStore 加载键对应的值，如果键不存在则存储键值对 CompareAndDelete 比较键对应的值是否等于指定值，如果相等则删除键值对 CompareAndSwap 比较键对应的值是否等于指定值，如果相等则替换键对应的值 Range 遍历键值对 传入函数返回false时停止遍历 WaitGroup 无需显式初始化，直接声明变量即可使用。 方法 含义 说明 Add 添加计数器 启动协程前调用，传入协程数量 Done 减少计数器 协程执行完毕后调用 Wait 等待计数器变为0 主协程调用，等待所有协程执行完毕 Once 无需显式初始化，直接声明变量即可使用。 方法 含义 说明 Do 执行函数 传入函数，只会执行一次 Pool 需显式初始化，为New指定创建对象的函数。\n主要目的是缓存已分配但未使用的对象以便后续重用。\n池中的对象为临时对象，可能随时消失，不能依赖其中对象一直存在。\n首次使用后不能被复制。\n方法 含义 说明 Get 从池中获取对象 无可用对象时会调用New（不为nil）创建一个新对象 Put 把对象放回池中 Cond 需显式初始化，指定一个锁。\n用于协调协程的执行顺序，常用于生产者/消费者模型。\n方法 含义 说明 Broadcast 广播唤醒所有等待的协程 Signal 唤醒一个等待的协程 Wait 将协程持有的锁释放，同时将协程加入等待队列并阻塞协程，等待唤醒 调用时必需在循环中检查条件 包函数 方法 含义 说明 NewCond 创建一个新的条件变量 需指定一个锁 OnceFunc 创建一个只执行一次的无返回值的函数 调用返回函数时，传入函数只会执行一次 OnceValue 创建一个只执行一次的只有一个返回值的函数 调用返回函数时，传入函数只会执行一次 OnceValues 创建一个只执行一次的有两个返回值的函数 调用返回函数时，传入函数只会执行一次 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_sync/","summary":"Mutex 无需显式初始化，直接声明变量即可使用。\n互斥锁，同一时刻只能有一个协程持有锁，不分读写。\n方法 含义 说明 Lock 加锁 Unlock 解锁 未加锁时调用会导致panic TryLock 尝试加锁 立即返回，成功返回true，失败返回false RWMutex 无需显式初始化，直接声明变量即可使用。\n读写锁，同一时刻可以有多个协程持有读锁，但是只能有一个协程持有写锁。\n有写锁时，其他协程无法获取读锁和写锁。\n有读锁时，其他协程可以获取读锁，但是无法获取写锁。\n方法 含义 说明 RLock 加读锁 RUnlock 解读锁 未加读锁时调用会导致panic TryRLock 尝试加读锁 立即返回，成功返回true，失败返回false Lock 加写锁 Unlock 解写锁 未加写锁时调用会导致panic TryLock 尝试加写锁 立即返回，成功返回true，失败返回false Map 无需显式初始化，直接声明变量即可使用。 方法 含义 说明 Store 存储键值对 Load 加载键对应的值 Delete 删除键对应的值 Clear 清除所有键值对 Swap 交换指定键对应的旧值和新值，并返回旧值和操作之前键是否存在 LoadAndDelete 加载键对应的值并删除键值对 LoadOrStore 加载键对应的值，如果键不存在则存储键值对 CompareAndDelete 比较键对应的值是否等于指定值，如果相等则删除键值对 CompareAndSwap 比较键对应的值是否等于指定值，如果相等则替换键对应的值 Range 遍历键值对 传入函数返回false时停止遍历 WaitGroup 无需显式初始化，直接声明变量即可使用。 方法 含义 说明 Add 添加计数器 启动协程前调用，传入协程数量 Done 减少计数器 协程执行完毕后调用 Wait 等待计数器变为0 主协程调用，等待所有协程执行完毕 Once 无需显式初始化，直接声明变量即可使用。 方法 含义 说明 Do 执行函数 传入函数，只会执行一次 Pool 需显式初始化，为New指定创建对象的函数。","title":"Go sync包"},{"content":"简介 flag用于实现命令行标志的解析。\n一般流程 定义命令行标志\n解析命令行标志\n获取解析标志外的命令行参数\n使用解析后的标志和参数\n支持的标志格式 -flag：短标志\n--flag：长标志\n-flag=value：短标志和值\n-flag value：短标志和值，仅限非布尔标志\n解析规则 标志解析会在遇到第一个非标志参数（-被视为非标志参数）或者终止符--之后停止。\n1 0 t f T F true false TRUE FALSE True False均可被解析为布尔值。\n标志解析的返回值均为对应类型的指针。\n包函数 方法 含义 说明 NewFlagSet 创建一个新的标志集 通常用于创建子命令的标志集 Lookup 查找标志集中的标志 Set 设置标志集中的标志的值 NArg 返回实际传入的命令行参数的数量 调用Parse之后生效，不包含命令行标志 Arg 返回第i个命令行参数 从0开始 NFlag 返回实际传入的命令行标志的数量 调用Parse之后生效 Parsed 返回标志是否已被解析 Parse 解析命令行标志 Bool 定义一个布尔型标志 BoolVar 定义一个布尔型标志并绑定到指定变量 Int 定义一个整数标志 IntVar 定义一个整数标志并绑定到指定变量 Int64 定义一个64位整数标志 Int64Var 定义一个64位整数标志并绑定到指定变量 Uint 定义一个无符号整数标志 UintVar 定义一个无符号整数标志并绑定到指定变量 Uint64 定义一个64位无符号整数标志 Uint64Var 定义一个64位无符号整数标志并绑定到指定变量 Float64 定义一个64位浮点数标志 Float64Var 定义一个64位浮点数标志并绑定到指定变量 Duration 定义一个时间间隔标志 DurationVar 定义一个时间间隔标志并绑定到指定变量 String 定义一个字符串标志 StringVar 定义一个字符串标志并绑定到指定变量 Var 定义一个自定义类型标志并绑定到对应变量 自定义类型需要实现flag.Value接口 TextVar 定义一个encoding.TextUnmarshaler类型标志并绑定到对应变量 BoolFunc 定义一个布尔型标志并绑定到指定函数 通常用于开关功能，仅标志，无值 Func 定义一个标志并绑定到指定函数 其值会传递给指定函数 Visit 遍历已经被设置的命令行标志并调用传入的函数 VisitAll 遍历所有命令行标志并调用传入的函数 UnquoteUsage 去除标志的引号 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_flag/","summary":"简介 flag用于实现命令行标志的解析。\n一般流程 定义命令行标志\n解析命令行标志\n获取解析标志外的命令行参数\n使用解析后的标志和参数\n支持的标志格式 -flag：短标志\n--flag：长标志\n-flag=value：短标志和值\n-flag value：短标志和值，仅限非布尔标志\n解析规则 标志解析会在遇到第一个非标志参数（-被视为非标志参数）或者终止符--之后停止。\n1 0 t f T F true false TRUE FALSE True False均可被解析为布尔值。\n标志解析的返回值均为对应类型的指针。\n包函数 方法 含义 说明 NewFlagSet 创建一个新的标志集 通常用于创建子命令的标志集 Lookup 查找标志集中的标志 Set 设置标志集中的标志的值 NArg 返回实际传入的命令行参数的数量 调用Parse之后生效，不包含命令行标志 Arg 返回第i个命令行参数 从0开始 NFlag 返回实际传入的命令行标志的数量 调用Parse之后生效 Parsed 返回标志是否已被解析 Parse 解析命令行标志 Bool 定义一个布尔型标志 BoolVar 定义一个布尔型标志并绑定到指定变量 Int 定义一个整数标志 IntVar 定义一个整数标志并绑定到指定变量 Int64 定义一个64位整数标志 Int64Var 定义一个64位整数标志并绑定到指定变量 Uint 定义一个无符号整数标志 UintVar 定义一个无符号整数标志并绑定到指定变量 Uint64 定义一个64位无符号整数标志 Uint64Var 定义一个64位无符号整数标志并绑定到指定变量 Float64 定义一个64位浮点数标志 Float64Var 定义一个64位浮点数标志并绑定到指定变量 Duration 定义一个时间间隔标志 DurationVar 定义一个时间间隔标志并绑定到指定变量 String 定义一个字符串标志 StringVar 定义一个字符串标志并绑定到指定变量 Var 定义一个自定义类型标志并绑定到对应变量 自定义类型需要实现flag.","title":"Go flag包"},{"content":"Logger 方法 含义 说明 Fatal Fatalf Fatalln 记录一条严重错误后执行os.Exit(1) Panic Panicf Panicln 记录一条严重错误后引发panic Print Printf Println 记录一条普通信息 Flags 返回当前Logger的输出标志 SetFlags 设置当前Logger的输出标志 Prefix 返回当前Logger的前缀 SetPrefix 设置当前Logger的前缀 Writer 返回当前Logger的输出目标 SetOutput 设置当前Logger的输出目标 Output 直接输出日志 更接近底层，可指定调用等级 包函数 方法 含义 说明 Default 返回默认的Logger New 创建一个新的Logger Fatal Fatalf Fatalln 记录一条严重错误后执行os.Exit(1) 使用默认的Logger Panic Panicf Panicln 记录一条严重错误后引发panic 使用默认的Logger Print Printf Println 记录一条普通信息 使用默认的Logger Flags 返回默认Logger的输出标志 SetFlags 设置默认Logger的输出标志 Prefix 返回默认Logger的前缀 SetPrefix 设置默认Logger的前缀 Writer 返回默认Logger的输出目标 SetOutput 设置默认Logger的输出目标 Output 使用默认的Logger直接输出日志 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_log/","summary":"Logger 方法 含义 说明 Fatal Fatalf Fatalln 记录一条严重错误后执行os.Exit(1) Panic Panicf Panicln 记录一条严重错误后引发panic Print Printf Println 记录一条普通信息 Flags 返回当前Logger的输出标志 SetFlags 设置当前Logger的输出标志 Prefix 返回当前Logger的前缀 SetPrefix 设置当前Logger的前缀 Writer 返回当前Logger的输出目标 SetOutput 设置当前Logger的输出目标 Output 直接输出日志 更接近底层，可指定调用等级 包函数 方法 含义 说明 Default 返回默认的Logger New 创建一个新的Logger Fatal Fatalf Fatalln 记录一条严重错误后执行os.Exit(1) 使用默认的Logger Panic Panicf Panicln 记录一条严重错误后引发panic 使用默认的Logger Print Printf Println 记录一条普通信息 使用默认的Logger Flags 返回默认Logger的输出标志 SetFlags 设置默认Logger的输出标志 Prefix 返回默认Logger的前缀 SetPrefix 设置默认Logger的前缀 Writer 返回默认Logger的输出目标 SetOutput 设置默认Logger的输出目标 Output 使用默认的Logger直接输出日志 ","title":"Go log包"},{"content":"Reader 方法 含义 说明 Buffered 返回从当前缓冲区内可以读取的字节数量 Discard 跳过接下来的n字节 Peek 查看接下来的n字节 不移动读指针 Read 从bufio.Reader中读取内容到字节切片 ReadByte 从bufio.Reader中读取一个字节 ReadBytes 从bufio.Reader中读取数据，直到遇到指定的分隔符delim 包含分隔符 ReadLine 从bufio.Reader中读取一行数据 不包含换行符，建议使用Reader.ReadBytes('\\n')、Reader.ReadString('\\n')或者Scanner ReadRune 从bufio.Reader中读取一个rune ReadSlice 从bufio.Reader中读取数据，直到遇到指定的分隔符delim 包含分隔符，建议使用Reader.ReadBytes或ReadString ReadString 从bufio.Reader中读取数据，直到遇到指定的分隔符delim 包含分隔符 Reset 重置bufio.Reader Size 返回底层缓冲区的大小 UnreadByte 回退最后读取的一个字节 UnreadRune 回退最后读取的一个rune WriteTo 将数据从bufio.Reader写入到io.Writer Writer 方法 含义 说明 Available 返回当前缓冲区中可以写入的字节数量 AvailableBuffer 返回一个空的缓冲区，容量是Available返回的值 Buffered 返回当前缓冲区中已经写入的字节数量 Flush 将缓冲区中的数据写入到io.Writer ReadFrom 从io.Reader读取数据到bufio.Writer Reset 重置bufio.Writer Size 返回底层缓冲区的大小 Write 将数据写入bufio.Writer WriteByte 将一个字节写入bufio.Writer WriteRune 将一个rune写入bufio.Writer WriteString 将一个字符串写入bufio.Writer Scanner 方法 含义 说明 Buffer 设置在扫描时要使用的初始缓冲区，及在扫描过程中可能分配的最大缓冲区大小 Bytes 返回由最近一次调用Scanner.Scan生成的令牌 不会进行内存分配 Err 返回扫描过程中遇到的第一个非EOF错误 Scan 使扫描器前进到下一个令牌 Split 设置扫描器的分割函数 在扫描已经开始之后调用会触发panic Text 返回由最近一次调用Scanner.Scan生成的令牌 进行内存分配 包函数 方法 含义 说明 NewReader 从io.Reader创建一个带缓冲区的bufio.Reader NewReaderSize 从io.Reader创建一个带缓冲区的bufio.Reader，并指定缓冲区的大小 NewWriter 从io.Writer创建一个带缓冲区的bufio.Writer NewWriterSize 从io.Writer创建一个带缓冲区的bufio.Writer，并指定缓冲区的大小 NewReadWriter 将io.Reader和io.Writer包装成一个带缓冲区的bufio.ReadWriter ScanBytes bufio.Scanner的一种分割函数，将输入数据按字节进行分割 ScanLines bufio.Scanner的一种分割函数，将输入文本按行进行分割 会移除行尾的换行符 ScanRunes bufio.Scanner的一种分割函数，将输入数据按rune进行分割 ScanWords bufio.Scanner的一种分割函数，将输入文本按以空格分隔的单词进行分割 会移除单词之间的空格 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_bufio/","summary":"Reader 方法 含义 说明 Buffered 返回从当前缓冲区内可以读取的字节数量 Discard 跳过接下来的n字节 Peek 查看接下来的n字节 不移动读指针 Read 从bufio.Reader中读取内容到字节切片 ReadByte 从bufio.Reader中读取一个字节 ReadBytes 从bufio.Reader中读取数据，直到遇到指定的分隔符delim 包含分隔符 ReadLine 从bufio.Reader中读取一行数据 不包含换行符，建议使用Reader.ReadBytes('\\n')、Reader.ReadString('\\n')或者Scanner ReadRune 从bufio.Reader中读取一个rune ReadSlice 从bufio.Reader中读取数据，直到遇到指定的分隔符delim 包含分隔符，建议使用Reader.ReadBytes或ReadString ReadString 从bufio.Reader中读取数据，直到遇到指定的分隔符delim 包含分隔符 Reset 重置bufio.Reader Size 返回底层缓冲区的大小 UnreadByte 回退最后读取的一个字节 UnreadRune 回退最后读取的一个rune WriteTo 将数据从bufio.Reader写入到io.Writer Writer 方法 含义 说明 Available 返回当前缓冲区中可以写入的字节数量 AvailableBuffer 返回一个空的缓冲区，容量是Available返回的值 Buffered 返回当前缓冲区中已经写入的字节数量 Flush 将缓冲区中的数据写入到io.Writer ReadFrom 从io.Reader读取数据到bufio.Writer Reset 重置bufio.Writer Size 返回底层缓冲区的大小 Write 将数据写入bufio.Writer WriteByte 将一个字节写入bufio.Writer WriteRune 将一个rune写入bufio.Writer WriteString 将一个字符串写入bufio.Writer Scanner 方法 含义 说明 Buffer 设置在扫描时要使用的初始缓冲区，及在扫描过程中可能分配的最大缓冲区大小 Bytes 返回由最近一次调用Scanner.","title":"Go bufio包"},{"content":"包函数 方法 含义 说明 FileInfoToDirEntry 将fs.FileInfo转换为fs.DirEntry FormatDirEntry 将fs.DirEntry格式化为字符串 FormatFileInfo 将fs.FileInfo格式化为字符串 Glob 获取指定模式的文件列表 ReadDir 读取指定目录中的内容，返回DirEntry切片 ReadFile 读取指定文件的内容，返回字节切片 Stat 获取文件信息，返回FileInfo Sub 获取指定目录的子目录 ValidPath 验证路径是否合法 WalkDir 遍历目录 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_io_fs/","summary":"包函数 方法 含义 说明 FileInfoToDirEntry 将fs.FileInfo转换为fs.DirEntry FormatDirEntry 将fs.DirEntry格式化为字符串 FormatFileInfo 将fs.FileInfo格式化为字符串 Glob 获取指定模式的文件列表 ReadDir 读取指定目录中的内容，返回DirEntry切片 ReadFile 读取指定文件的内容，返回字节切片 Stat 获取文件信息，返回FileInfo Sub 获取指定目录的子目录 ValidPath 验证路径是否合法 WalkDir 遍历目录 ","title":"Go io/fs包"},{"content":"OffsetWriter OffsetWriter是io.Writer的一个实现，它可以将写入的数据偏移指定的字节数后写入到另一个io.Writer中。\n方法 含义 说明 Write 将数据写入io.Writer WriteAt 将数据写入io.Writer，从指定位置开始 Seek 设置指针位置 SectionReader SectionReader是io.Reader的一个实现，它可以从另一个io.Reader中读取指定范围的数据。\n方法 含义 说明 Outer 获取底层的ReaderAt、偏移量和长度 Read 从io.Reader读取内容到字节切片 读取后指针位置会移动 ReadAt 从io.Reader读取内容到字节切片，从指定位置开始 读取后指针位置不会移动 Seek 设置指针位置 Size 返回区间的大小 PipeReader PipeReader是io.Reader的一个实现，它可以从另一个io.Reader中读取数据。\n方法 含义 说明 Read 从管道读取内容到字节切片 Close 关闭PipeReader CloseWithError 关闭PipeReader并返回错误 PipeWriter PipeWriter是io.Writer的一个实现，它可以将数据写入到另一个io.Reader中。\n方法 含义 说明 Write 将数据写入io.Writer Close 关闭PipeWriter CloseWithError 关闭PipeWriter并返回错误 包函数 方法 含义 说明 Copy 将数据从io.Reader复制到io.Writer CopyBuffer 将数据从io.Reader复制到io.Writer，使用指定的缓冲区 CopyN 将数据从io.Reader复制到io.Writer，最多复制n个字节 LimitReader 从io.Reader创建一个限制的读取范围的io.Reader MultiReader 将多个io.Reader组合成一个io.Reader 先后读取，类似内容拼接 MultiWriter 将多个io.Writer组合成一个io.Writer 同时写入 NewOffsetWriter 从io.Writer创建一个带有偏移量的io.Writer NewSectionReader 从io.Reader创建一个指定范围的io.Reader NopCloser 从io.Reader创建一个不关闭的io.ReadCloser Pipe 创建一个io.Reader和io.Writer的管道 ReadAll 从io.Reader读取所有数据到字节切片，直到数据读完 ReadAtLeast 从io.Reader读取至少n个字节的数据到字节切片 ReadFull 从io.Reader读取数据到字节切片，直到切片填满 TeeReader 创建一个io.Reader，将数据同时写入到io.Writer中 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_io/","summary":"OffsetWriter OffsetWriter是io.Writer的一个实现，它可以将写入的数据偏移指定的字节数后写入到另一个io.Writer中。\n方法 含义 说明 Write 将数据写入io.Writer WriteAt 将数据写入io.Writer，从指定位置开始 Seek 设置指针位置 SectionReader SectionReader是io.Reader的一个实现，它可以从另一个io.Reader中读取指定范围的数据。\n方法 含义 说明 Outer 获取底层的ReaderAt、偏移量和长度 Read 从io.Reader读取内容到字节切片 读取后指针位置会移动 ReadAt 从io.Reader读取内容到字节切片，从指定位置开始 读取后指针位置不会移动 Seek 设置指针位置 Size 返回区间的大小 PipeReader PipeReader是io.Reader的一个实现，它可以从另一个io.Reader中读取数据。\n方法 含义 说明 Read 从管道读取内容到字节切片 Close 关闭PipeReader CloseWithError 关闭PipeReader并返回错误 PipeWriter PipeWriter是io.Writer的一个实现，它可以将数据写入到另一个io.Reader中。\n方法 含义 说明 Write 将数据写入io.Writer Close 关闭PipeWriter CloseWithError 关闭PipeWriter并返回错误 包函数 方法 含义 说明 Copy 将数据从io.Reader复制到io.Writer CopyBuffer 将数据从io.Reader复制到io.Writer，使用指定的缓冲区 CopyN 将数据从io.Reader复制到io.Writer，最多复制n个字节 LimitReader 从io.Reader创建一个限制的读取范围的io.Reader MultiReader 将多个io.Reader组合成一个io.Reader 先后读取，类似内容拼接 MultiWriter 将多个io.Writer组合成一个io.Writer 同时写入 NewOffsetWriter 从io.Writer创建一个带有偏移量的io.Writer NewSectionReader 从io.","title":"Go io包"},{"content":"File 方法 含义 说明 Close 关闭文件 Chdir 改变当前工作目录 *File必须为目录 Chmod 修改文件权限 Chown 修改文件所有者和组 Fd 返回文件描述符 Name 返回文件名 Read 从文件读取内容到字节切片 读取后指针位置会移动 ReadAt 从文件读取内容到字节切片，从指定位置开始 读取后指针位置不会移动 ReadDir 获取目录下的列表，返回DirEntry切片 *File必须为目录 Readdir 获取目录下的列表，返回FileInfo切片 *File必须为目录 Readdirnames 获取指定目录下的文件名 *File必须为目录 ReadFrom 从io.Reader读取内容到文件 读取后指针位置会移动，本质上是写文件 Seek 设置指针位置 SetDeadline 设置文件I/O超时时间 只有部分文件类型支持 SetReadDeadline 设置文件读取超时时间 只有部分文件类型支持 SetWriteDeadline 设置文件写入超时时间 只有部分文件类型支持 Stat 获取文件信息，返回FileInfo Sync 将文件内容同步到磁盘 SyscallConn 获取与文件操作相关的系统调用连接 Truncate 截断文件 Write 将字节切片中的数据写入文件 写入后指针位置会移动 WriteAt 将字节切片中的数据写入文件，从指定位置开始 写入后指针位置不会移动 WriteString 将字符串写入文件 写入后指针位置会移动 WriteTo 将数据写入io.Writer 写入后指针位置会移动，本质上是读文件 FileInfo 方法 含义 说明 IsDir 返回文件是否是目录 ModTime 返回文件的修改时间 Name 返回文件名 Size 返回文件的大小 Sys 返回文件的系统信息 FileMode 方法 含义 说明 IsDir 返回文件是否是目录 IsRegular 返回文件是否是普通文件 Perm 返回文件的权限 String 返回文件的字符串表示形式 Type 返回文件的类型 Process 方法 含义 说明 Kill 杀掉进程 Release 释放与Process对象相关的资源 Signal 向进程发送信号 Wait 等待进程退出 ProcessState 用于获取已结束进程状态信息。\n方法 含义 说明 ExitCode 返回进程的退出码 Exited 返回进程是否已经退出 Pid 返回进程的进程ID String 返回进程的字符串表示形式 Success 返回进程是否成功退出 Sys 返回进程的系统信息 SysUsage 获取进程系统资源使用情况 SystemTime 获取进程的系统CPU时间 UserTime 获取进程的用户CPU时间 包函数 函数名 含义 说明 Chdir 改变当前工作目录 Chmod 修改文件权限 Chown 修改文件所有者和组 Chtimes 修改文件访问时间和修改时间 Clearenv 清除当前进程的环境变量 CopyFS 复制文件系统 Create 创建文件 CreateTemp 创建临时文件 DirFS 将一个本地目录转换为一个实现了fs.FS接口的文件系统对象 Environ 返回当前进程的环境变量 Executable 返回当前可执行文件的路径 Exit 直接退出当前进程 不会执行defer语句 Expand 将字符串中的${var}形式的变量替换为实际的值 ExpandEnv 将字符串中的环境变量引用（形如$VAR或${VAR}）替换为对应的环境变量值 FindProcess 查找指定进程 Getegid 返回当前进程的有效组ID Windows返回-1 Getenv 获取指定的环境变量 Setenv 设置指定的环境变量 Unsetenv 删除指定的环境变量 Geteuid 返回当前进程的有效用户ID Windows返回-1 Getgid 返回当前进程的组ID Windows返回-1 Getgroups 返回当前进程所属的组ID列表 Windows返回nil Getpagesize 返回当前系统的页大小 Getpid 返回当前进程的进程ID Getppid 返回当前进程的父进程ID Getuid 返回当前进程的用户ID Windows返回-1 Getwd 返回当前工作目录 Hostname 返回当前主机的名称 IsExist 检查错误是否表示文件或目录已经存在 针对error IsNotExist 检查错误是否表示文件或目录不存在 针对error IsPathSeparator 检查字符是否为路径分隔符 IsPermission 判断错误是否是由权限问题导致的 针对error IsTimeout 判断一个错误是否是由于超时导致的 针对error Lchown 修改符号链接本身的所有者和组 Link 创建硬链接 Symlink 创建符号链接 LookupEnv 获取指定的环境变量 Lstat 获取文件信息，返回FileInfo 对于符号链接是其本身 Stat 获取文件信息，返回FileInfo 对于符号链接是其指向的目标 Mkdir 创建目录 MkdirAll 创建多级目录 MkdirTemp 创建临时目录 NewFile 根据文件描述符创建一个文件对象 NewSyscallError 根据传入的系统调用名称syscall和原始错误err创建一个新的error对象 Open 以只读方式打开文件 OpenFile 以指定方式打开文件 Pipe 创建一个管道 ReadDir 获取目录下的列表，返回DirEntry切片 *File必须为目录 ReadFile 读取指定文件的全部内容到切片 Readlink 读取符号链接的目标 不能读硬链接 Remove 删除文件或目录 RemoveAll 删除指定目录及其所有子目录和文件 Rename 重命名文件或目录 SameFile 检查两个文件是否是同一个文件 StartProcess 启动一个新的进程 TempDir 返回默认的临时目录 Truncate 截断文件 UserCacheDir 返回用户缓存目录 UserConfigDir 返回用户配置目录 UserHomeDir 返回用户主目录 WriteFile 将字节切片中的数据写入文件 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_os/","summary":"File 方法 含义 说明 Close 关闭文件 Chdir 改变当前工作目录 *File必须为目录 Chmod 修改文件权限 Chown 修改文件所有者和组 Fd 返回文件描述符 Name 返回文件名 Read 从文件读取内容到字节切片 读取后指针位置会移动 ReadAt 从文件读取内容到字节切片，从指定位置开始 读取后指针位置不会移动 ReadDir 获取目录下的列表，返回DirEntry切片 *File必须为目录 Readdir 获取目录下的列表，返回FileInfo切片 *File必须为目录 Readdirnames 获取指定目录下的文件名 *File必须为目录 ReadFrom 从io.Reader读取内容到文件 读取后指针位置会移动，本质上是写文件 Seek 设置指针位置 SetDeadline 设置文件I/O超时时间 只有部分文件类型支持 SetReadDeadline 设置文件读取超时时间 只有部分文件类型支持 SetWriteDeadline 设置文件写入超时时间 只有部分文件类型支持 Stat 获取文件信息，返回FileInfo Sync 将文件内容同步到磁盘 SyscallConn 获取与文件操作相关的系统调用连接 Truncate 截断文件 Write 将字节切片中的数据写入文件 写入后指针位置会移动 WriteAt 将字节切片中的数据写入文件，从指定位置开始 写入后指针位置不会移动 WriteString 将字符串写入文件 写入后指针位置会移动 WriteTo 将数据写入io.Writer 写入后指针位置会移动，本质上是读文件 FileInfo 方法 含义 说明 IsDir 返回文件是否是目录 ModTime 返回文件的修改时间 Name 返回文件名 Size 返回文件的大小 Sys 返回文件的系统信息 FileMode 方法 含义 说明 IsDir 返回文件是否是目录 IsRegular 返回文件是否是普通文件 Perm 返回文件的权限 String 返回文件的字符串表示形式 Type 返回文件的类型 Process 方法 含义 说明 Kill 杀掉进程 Release 释放与Process对象相关的资源 Signal 向进程发送信号 Wait 等待进程退出 ProcessState 用于获取已结束进程状态信息。","title":"Go os包"},{"content":"Time 方法 说明 Add 在该时间上加个时间得到新时间 AddDate 在该时间上加个日期得到新时间 After 判断该时间是否在另一个时间之后 AppendFormat 将该时间格式化为字符串并追加到字节切片中 Before 判断该时间是否在另一个时间之前 Clock 返回当前时间的时、分、秒 Compare 和另一个时间比较大小，返回-1、0、1 Date 返回该时间的年、月、日 Day 返回该时间的日 Equal 判断该时间是否和另一个时间相等 Format 将该时间格式化为字符串 GoString 返回该时间的字符串表示形式 GobDecode 从字节切片中解码该时间 GobEncode 将该时间编码为字节切片 Hour 返回该时间的小时 ISOWeek 返回该时间所在的ISO周 In 返回该时间在指定时区对应的时间 IsDST 判断该时间是否在夏令时 IsZero 判断一个时间值是否为零值 Local 返回该时间在本地时区对应的时间 Location 返回该时间所在的时区 MarshalBinary 将该时间序列化为二进制格式 MarshalJSON 将该时间序列化为JSON格式 MarshalText 将该时间序列化为文本格式 Minute 返回该时间的分钟 Month 返回该时间的月份 Nanosecond 返回该时间的纳秒 Round 将该时间舍入到指定的时间单位 Second 返回该时间的秒 String 返回该时间的字符串表示形式 Sub 在该时间上减去另一个时间得到新时间 Time 返回该时间的时间戳 Truncate 将该时间截断到指定的时间单位 UTC 返回该时间在UTC时区对应的时间 Unix 返回该时间的Unix时间戳，单位：秒 UnixMicro 返回该时间的Unix时间戳，单位：微秒 UnixMilli 返回该时间的Unix时间戳，单位：毫秒 UnixNano 返回该时间的Unix时间戳，单位：纳秒 UnmarshalBinary 从二进制格式反序列化该时间 UnmarshalJSON 从JSON格式反序列化该时间 UnmarshalText 从文本格式反序列化该时间 Weekday 返回该时间所在的星期几 Year 返回该时间的年份 YearDay 返回该时间所在的年中的第几天 Zone 返回该时间所在的时区名称和偏移量（单位：秒） ZoneBounds 返回该时间所在的时区的夏令时开始和结束时间 包函数 函数名 含义 说明 Now 返回当前时间 Date 构造指定的时间 FixedZone 构造一个指定偏移时的时区 LoadLocation 加载时区信息 LoadLocationFromTZData 从TZData文件加载时区信息 Parse 解析时间字符串 ParseDuration 解析时间间隔字符串 ParseInLocation 在指定时区解析时间字符串 Since 计算指定时间与现在的间隔 等同于time.Now().Sub(t) Sleep 暂停当前协程指定的时间 Unix 从Unix时间戳构造时间 UnixMicro 从Unix微秒时间戳构造时间 UnixMilli 从Unix毫秒时间戳构造时间 Until 计算指定时间与现在的剩余时间 等同于t.Sub(time.Now()) NewTimer 构造一个单次定时器 执行一次 NewTicker 构造一个周期定时器 周期执行 After 在指定时间后返回一个time.Time类型的chan 执行一次 AfterFunc 返回一个Timer，并在指定时间后执行指定的函数 执行一次 Tick 按指定的周期返回一个time.Time类型的chan 周期执行 定时器 Timer是定时执行一次的定时器，Ticker是周期执行的定时器。\n成员 说明 C 一个chan，用于接收定时器触发的时间点 方法 说明 Stop 停止定时器 Reset 重置定时器 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_time/","summary":"Time 方法 说明 Add 在该时间上加个时间得到新时间 AddDate 在该时间上加个日期得到新时间 After 判断该时间是否在另一个时间之后 AppendFormat 将该时间格式化为字符串并追加到字节切片中 Before 判断该时间是否在另一个时间之前 Clock 返回当前时间的时、分、秒 Compare 和另一个时间比较大小，返回-1、0、1 Date 返回该时间的年、月、日 Day 返回该时间的日 Equal 判断该时间是否和另一个时间相等 Format 将该时间格式化为字符串 GoString 返回该时间的字符串表示形式 GobDecode 从字节切片中解码该时间 GobEncode 将该时间编码为字节切片 Hour 返回该时间的小时 ISOWeek 返回该时间所在的ISO周 In 返回该时间在指定时区对应的时间 IsDST 判断该时间是否在夏令时 IsZero 判断一个时间值是否为零值 Local 返回该时间在本地时区对应的时间 Location 返回该时间所在的时区 MarshalBinary 将该时间序列化为二进制格式 MarshalJSON 将该时间序列化为JSON格式 MarshalText 将该时间序列化为文本格式 Minute 返回该时间的分钟 Month 返回该时间的月份 Nanosecond 返回该时间的纳秒 Round 将该时间舍入到指定的时间单位 Second 返回该时间的秒 String 返回该时间的字符串表示形式 Sub 在该时间上减去另一个时间得到新时间 Time 返回该时间的时间戳 Truncate 将该时间截断到指定的时间单位 UTC 返回该时间在UTC时区对应的时间 Unix 返回该时间的Unix时间戳，单位：秒 UnixMicro 返回该时间的Unix时间戳，单位：微秒 UnixMilli 返回该时间的Unix时间戳，单位：毫秒 UnixNano 返回该时间的Unix时间戳，单位：纳秒 UnmarshalBinary 从二进制格式反序列化该时间 UnmarshalJSON 从JSON格式反序列化该时间 UnmarshalText 从文本格式反序列化该时间 Weekday 返回该时间所在的星期几 Year 返回该时间的年份 YearDay 返回该时间所在的年中的第几天 Zone 返回该时间所在的时区名称和偏移量（单位：秒） ZoneBounds 返回该时间所在的时区的夏令时开始和结束时间 包函数 函数名 含义 说明 Now 返回当前时间 Date 构造指定的时间 FixedZone 构造一个指定偏移时的时区 LoadLocation 加载时区信息 LoadLocationFromTZData 从TZData文件加载时区信息 Parse 解析时间字符串 ParseDuration 解析时间间隔字符串 ParseInLocation 在指定时区解析时间字符串 Since 计算指定时间与现在的间隔 等同于time.","title":"Go time包"},{"content":"Builder 方法 说明 String 返回最终构造的字符串 Len 返回缓冲区（字节切片）的长度 Cap 返回缓冲区（字节切片）的容量 Reset 重置Builder Grow 显式扩容 Write 向Builder追加字节切片 WriteByte 向Builder追加字节 WriteRune 向Builder追加Unicode码点 WriteString 向Builder追加字符串 包函数 函数名 含义 说明 Clone 返回字符串的副本 Compare 比较两个字符串的大小，返回-1、0、1 Contains 判断一个字符串是否包含另一个字符串 类似于pascal的Pos()\u0026gt;0 ContainsAny 判断一个字符串是否包含另一个字符串中的任意一个字符 ContainsRune 判断一个字符串是否包含一个Unicode码点 ContainsFunc 判断一个字符串是否包含满足特定条件的字符 Count 统计一个字符串中某个子字符串出现的次数 Cut 将一个字符串按照指定的分隔符进行切割 只进行一次切割 CutPrefix 判断一个字符串是否以指定的前缀开始，是则进行切割 CutSuffix 判断一个字符串是否以指定的后缀结束，是则进行切割 EqualFold 判断两个字符串是否相等，忽略大小写 类似于pascal的SameText() Fields 用连续的空白字符对字符串进行分割 FieldsFunc 用指定的函数对字符串进行分割 HasPrefix 判断一个字符串是否以指定的前缀开始 HasSuffix 判断一个字符串是否以指定的后缀结束 Index 返回一个字符串中某个子字符串第一次出现的位置（从0开始，未找到返回-1） 类似于pascal的Pos() IndexAny 返回一个字符串中任意一个字符第一次出现的位置（从0开始，未找到返回-1） IndexByte 返回一个字符串中某个字节第一次出现的位置（从0开始，未找到返回-1） IndexRune 返回一个字符串中某个Unicode码点第一次出现的位置（从0开始，未找到返回-1） IndexFunc 返回一个字符串中满足特定条件的字符第一次出现的位置（从0开始，未找到返回-1） LastIndex 返回一个字符串中某个子字符串最后一次出现的位置（从0开始，未找到返回-1） LastIndexAny 返回一个字符串中任意一个字符最后一次出现的位置（从0开始，未找到返回-1） LastIndexByte 返回一个字符串中某个字节最后一次出现的位置（从0开始，未找到返回-1） LastIndexFunc 返回一个字符串中满足特定条件的字符最后一次出现的位置（从0开始，未找到返回-1） Join 将一个字符串切片用指定的字符串连接成一个新字符串 Map 将一个字符串中的每个字符都映射成另一个字符 Repeat 将一个字符串重复指定的次数 Replace 将一个字符串中的某个子字符串替换成另一个字符串 ReplaceAll 将一个字符串中的所有子字符串替换成另一个字符串 Split 用指定的字符对字符串进行分割 SplitN 用指定的字符对字符串进行分割，最多分割n次 SplitAfter 用指定的字符对字符串进行分割，保留分隔符 SplitAfterN 用指定的字符对字符串进行分割，保留分隔符，最多分割n次 ToLower 将一个字符串中的所有字符都转换成小写 ToUpper 将一个字符串中的所有字符都转换成大写 ToTitle 将其中所有的Unicode字母转换为它们对应的Unicode标题大小写 ToLowerSpecial 将字符串中的字符按照特定规则转换为小写形式 ToUpperSpecial 将字符串中的字符按照特定规则转换为大写形式 ToTitleSpecial 将字符串中的字符按照特定规则转换为标题形式 ToValidUTF8 将一个字符串中的无效UTF-8字符替换成Unicode替换字符 Trim 去除字符串两端的指定字符 连续的指定字符都会被去除 TrimLeft 去除字符串左边的指定字符 连续的指定字符都会被去除 TrimRight 去除字符串右边的指定字符 连续的指定字符都会被去除 TrimFunc 去除字符串两端满足特定条件的字符 连续的满足条件的字符都会被去除 TrimLeftFunc 去除字符串左边满足特定条件的字符 连续的满足条件的字符都会被去除 TrimRightFunc 去除字符串右边满足特定条件的字符 连续的满足条件的字符都会被去除 TrimSpace 去除字符串两端的空白字符 连续的空白都会被去除 TrimPrefix 去除字符串前缀 TrimSuffix 去除字符串后缀 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_strings/","summary":"Builder 方法 说明 String 返回最终构造的字符串 Len 返回缓冲区（字节切片）的长度 Cap 返回缓冲区（字节切片）的容量 Reset 重置Builder Grow 显式扩容 Write 向Builder追加字节切片 WriteByte 向Builder追加字节 WriteRune 向Builder追加Unicode码点 WriteString 向Builder追加字符串 包函数 函数名 含义 说明 Clone 返回字符串的副本 Compare 比较两个字符串的大小，返回-1、0、1 Contains 判断一个字符串是否包含另一个字符串 类似于pascal的Pos()\u0026gt;0 ContainsAny 判断一个字符串是否包含另一个字符串中的任意一个字符 ContainsRune 判断一个字符串是否包含一个Unicode码点 ContainsFunc 判断一个字符串是否包含满足特定条件的字符 Count 统计一个字符串中某个子字符串出现的次数 Cut 将一个字符串按照指定的分隔符进行切割 只进行一次切割 CutPrefix 判断一个字符串是否以指定的前缀开始，是则进行切割 CutSuffix 判断一个字符串是否以指定的后缀结束，是则进行切割 EqualFold 判断两个字符串是否相等，忽略大小写 类似于pascal的SameText() Fields 用连续的空白字符对字符串进行分割 FieldsFunc 用指定的函数对字符串进行分割 HasPrefix 判断一个字符串是否以指定的前缀开始 HasSuffix 判断一个字符串是否以指定的后缀结束 Index 返回一个字符串中某个子字符串第一次出现的位置（从0开始，未找到返回-1） 类似于pascal的Pos() IndexAny 返回一个字符串中任意一个字符第一次出现的位置（从0开始，未找到返回-1） IndexByte 返回一个字符串中某个字节第一次出现的位置（从0开始，未找到返回-1） IndexRune 返回一个字符串中某个Unicode码点第一次出现的位置（从0开始，未找到返回-1） IndexFunc 返回一个字符串中满足特定条件的字符第一次出现的位置（从0开始，未找到返回-1） LastIndex 返回一个字符串中某个子字符串最后一次出现的位置（从0开始，未找到返回-1） LastIndexAny 返回一个字符串中任意一个字符最后一次出现的位置（从0开始，未找到返回-1） LastIndexByte 返回一个字符串中某个字节最后一次出现的位置（从0开始，未找到返回-1） LastIndexFunc 返回一个字符串中满足特定条件的字符最后一次出现的位置（从0开始，未找到返回-1） Join 将一个字符串切片用指定的字符串连接成一个新字符串 Map 将一个字符串中的每个字符都映射成另一个字符 Repeat 将一个字符串重复指定的次数 Replace 将一个字符串中的某个子字符串替换成另一个字符串 ReplaceAll 将一个字符串中的所有子字符串替换成另一个字符串 Split 用指定的字符对字符串进行分割 SplitN 用指定的字符对字符串进行分割，最多分割n次 SplitAfter 用指定的字符对字符串进行分割，保留分隔符 SplitAfterN 用指定的字符对字符串进行分割，保留分隔符，最多分割n次 ToLower 将一个字符串中的所有字符都转换成小写 ToUpper 将一个字符串中的所有字符都转换成大写 ToTitle 将其中所有的Unicode字母转换为它们对应的Unicode标题大小写 ToLowerSpecial 将字符串中的字符按照特定规则转换为小写形式 ToUpperSpecial 将字符串中的字符按照特定规则转换为大写形式 ToTitleSpecial 将字符串中的字符按照特定规则转换为标题形式 ToValidUTF8 将一个字符串中的无效UTF-8字符替换成Unicode替换字符 Trim 去除字符串两端的指定字符 连续的指定字符都会被去除 TrimLeft 去除字符串左边的指定字符 连续的指定字符都会被去除 TrimRight 去除字符串右边的指定字符 连续的指定字符都会被去除 TrimFunc 去除字符串两端满足特定条件的字符 连续的满足条件的字符都会被去除 TrimLeftFunc 去除字符串左边满足特定条件的字符 连续的满足条件的字符都会被去除 TrimRightFunc 去除字符串右边满足特定条件的字符 连续的满足条件的字符都会被去除 TrimSpace 去除字符串两端的空白字符 连续的空白都会被去除 TrimPrefix 去除字符串前缀 TrimSuffix 去除字符串后缀 ","title":"Go strings包"},{"content":"说明 预声明标识符是指在代码中可以直接使用的标识符，但它们并没有在任何包中声明。这些标识符通常是由Go语言的标准库或编译器提供的，它们在代码中可以直接使用，而不需要导入任何包。\nbuiltin包的作用是为这些预声明标识符提供文档说明，以便开发人员了解它们的用途和用法。通过查看builtin包的文档，开发人员可以了解到哪些预声明标识符是可用的，以及它们的作用和使用方法。\n内置函数 函数名 含义 说明 append 将元素追加到切片末尾 容量足够时，不会重新分配内存；容量不足时，会重新分配内存 copy 将切片中的元素复制到另一个切片中，返回复制的元素数量 delete 从映射中删除指定的键值对 len 返回切片、映射、通道或字符串的长度 cap 返回切片、映射或通道的容量 make 为切片、映射或通道分配内存，并返回该类型的零值 max 返回一组可比较类型中的最大值 如果是浮点型且参数中有NaN，则返回NaN min 返回一组可比较类型中的最小值 如果是浮点型且参数中有NaN，则返回NaN new 为指定类型的新值分配内存，并返回指向该类型的零值的指针 complex 创建一个复数 real 返回复数的实部 imag 返回复数的虚部 clear 清除切片、映射中的所有元素 close 关闭通道 只能由发送方调用 panic 停止当前协程的正常执行，引发一个运行时错误，导致程序回溯调用栈 recover 从panic中恢复，并返回panic的值 只能在defer语句中使用 print println 对传入的参数进行格式化，然后将格式化后的结果输出到标准错误 用于引导程序和调试，未来其可能会被修改或移除，不应该在生产环境中使用 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_builtin/","summary":"说明 预声明标识符是指在代码中可以直接使用的标识符，但它们并没有在任何包中声明。这些标识符通常是由Go语言的标准库或编译器提供的，它们在代码中可以直接使用，而不需要导入任何包。\nbuiltin包的作用是为这些预声明标识符提供文档说明，以便开发人员了解它们的用途和用法。通过查看builtin包的文档，开发人员可以了解到哪些预声明标识符是可用的，以及它们的作用和使用方法。\n内置函数 函数名 含义 说明 append 将元素追加到切片末尾 容量足够时，不会重新分配内存；容量不足时，会重新分配内存 copy 将切片中的元素复制到另一个切片中，返回复制的元素数量 delete 从映射中删除指定的键值对 len 返回切片、映射、通道或字符串的长度 cap 返回切片、映射或通道的容量 make 为切片、映射或通道分配内存，并返回该类型的零值 max 返回一组可比较类型中的最大值 如果是浮点型且参数中有NaN，则返回NaN min 返回一组可比较类型中的最小值 如果是浮点型且参数中有NaN，则返回NaN new 为指定类型的新值分配内存，并返回指向该类型的零值的指针 complex 创建一个复数 real 返回复数的实部 imag 返回复数的虚部 clear 清除切片、映射中的所有元素 close 关闭通道 只能由发送方调用 panic 停止当前协程的正常执行，引发一个运行时错误，导致程序回溯调用栈 recover 从panic中恢复，并返回panic的值 只能在defer语句中使用 print println 对传入的参数进行格式化，然后将格式化后的结果输出到标准错误 用于引导程序和调试，未来其可能会被修改或移除，不应该在生产环境中使用 ","title":"Go builtin包"},{"content":"Go是强数据类型语言，且不支持隐式类型转换，strconv包是用于字符串和基本数据类型之间转换的。\n其它类型转字符串 函数名 含义 说明 FormatBool 布尔型转字符串 FormatInt FormatUint 整形转字符串 需指定进制 FormatFloat 浮点型转字符串 需指定格式、精度、位宽（32/64） FormatComplex 复数型转字符串 需指定格式、精度、位宽（64/128） Itoa 整形转字符串 固定十进制 字符串转其它类型 函数名 含义 说明 ParseBool 字符串转布尔型 1 t T true TRUE True为真，0 f F false FALSE False为假 ParseInt ParseUint 字符串转整形 需指定字符串的进制及转换后的位宽 ParseFloat 字符串转浮点型 需指定转换后的位宽 ParseComplex 字符串转复数 需指定转换后的位宽 Atoi 字符串转整形 固定十进制 其它 函数名 含义 说明 CanBackquote 判断一个字符串是否可以不被修改地放在反引号中 不能包含换行符，除了制表符之外，不能包含其他控制字符 IsGraphic 判断一个Unicode字符是否是图形字符 IsPrint的超集 IsPrint 判断一个Unicode字符是否是可打印字符 IsGraphic的子集 Quote 返回一个用双引号包裹的Go语言字符串字面量 控制字符和由IsPrint定义的不可打印字符会进行转义 QuoteToASCII 返回一个用双引号包裹的Go语言字符串字面量 非ASCII字符以及由IsPrint定义的不可打印字符会进行转义 QuoteToGraphic 返回一个用双引号包裹的Go语言字符串字面量 由IsGraphic定义的非图形字符会进行转义 QuoteRune 返回一个单引号包裹的Go字符字面量 控制字符和由IsPrint定义的不可打印字符会进行转义 QuoteRuneToASCII 返回一个单引号包裹的Go字符字面量 非ASCII字符以及由IsPrint定义的不可打印字符会进行转义 QuoteRuneToGraphic 返回一个单引号包裹的Go字符字面量 由IsGraphic定义的非图形字符会进行转义 AppendBool 布尔型转字符串，结果追加到指定的字节切片，并返回新的字节切片 AppendInt AppendUint 整型转字符串，结果追加到指定的字节切片，并返回新的字节切片 需指定进制 AppendFloat 浮点型转字符串，结果追加到指定的字节切片，并返回新的字节切片 需指定格式、精度、位宽（32/64） AppendQuote Quote处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteToASCII QuoteToASCII处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteToGraphic QuoteToGraphic处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteRune QuoteRune处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteRuneToASCII QuoteRuneToASCII处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteRuneToGraphic QuoteRuneToGraphic处理后的结果追加到指定的字节切片，并返回新的字节切片 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_strconv/","summary":"Go是强数据类型语言，且不支持隐式类型转换，strconv包是用于字符串和基本数据类型之间转换的。\n其它类型转字符串 函数名 含义 说明 FormatBool 布尔型转字符串 FormatInt FormatUint 整形转字符串 需指定进制 FormatFloat 浮点型转字符串 需指定格式、精度、位宽（32/64） FormatComplex 复数型转字符串 需指定格式、精度、位宽（64/128） Itoa 整形转字符串 固定十进制 字符串转其它类型 函数名 含义 说明 ParseBool 字符串转布尔型 1 t T true TRUE True为真，0 f F false FALSE False为假 ParseInt ParseUint 字符串转整形 需指定字符串的进制及转换后的位宽 ParseFloat 字符串转浮点型 需指定转换后的位宽 ParseComplex 字符串转复数 需指定转换后的位宽 Atoi 字符串转整形 固定十进制 其它 函数名 含义 说明 CanBackquote 判断一个字符串是否可以不被修改地放在反引号中 不能包含换行符，除了制表符之外，不能包含其他控制字符 IsGraphic 判断一个Unicode字符是否是图形字符 IsPrint的超集 IsPrint 判断一个Unicode字符是否是可打印字符 IsGraphic的子集 Quote 返回一个用双引号包裹的Go语言字符串字面量 控制字符和由IsPrint定义的不可打印字符会进行转义 QuoteToASCII 返回一个用双引号包裹的Go语言字符串字面量 非ASCII字符以及由IsPrint定义的不可打印字符会进行转义 QuoteToGraphic 返回一个用双引号包裹的Go语言字符串字面量 由IsGraphic定义的非图形字符会进行转义 QuoteRune 返回一个单引号包裹的Go字符字面量 控制字符和由IsPrint定义的不可打印字符会进行转义 QuoteRuneToASCII 返回一个单引号包裹的Go字符字面量 非ASCII字符以及由IsPrint定义的不可打印字符会进行转义 QuoteRuneToGraphic 返回一个单引号包裹的Go字符字面量 由IsGraphic定义的非图形字符会进行转义 AppendBool 布尔型转字符串，结果追加到指定的字节切片，并返回新的字节切片 AppendInt AppendUint 整型转字符串，结果追加到指定的字节切片，并返回新的字节切片 需指定进制 AppendFloat 浮点型转字符串，结果追加到指定的字节切片，并返回新的字节切片 需指定格式、精度、位宽（32/64） AppendQuote Quote处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteToASCII QuoteToASCII处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteToGraphic QuoteToGraphic处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteRune QuoteRune处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteRuneToASCII QuoteRuneToASCII处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteRuneToGraphic QuoteRuneToGraphic处理后的结果追加到指定的字节切片，并返回新的字节切片 ","title":"Go strconv包"},{"content":"fmt包提供了格式化输入、输出的功能。\n格式化输出 函数名 说明 Print 以默认格式进行格式化，格式化结果输出到os.Stdout Printf 以指定格式进行格式化，格式化结果输出到os.Stdout Println 以默认格式进行格式化，并在末尾添加换行符，格式化结果输出到os.Stdout Fprint 以默认格式进行格式化，格式化结果输出到指定的io.Writer接口 Fprintf 以指定格式进行格式化，格式化结果输出到指定的io.Writer接口 Fprintln 以默认格式进行格式化，并在末尾添加换行符，格式化结果输出到指定的io.Writer接口 Sprint 以默认格式进行格式化，格式化结果以字符串形式返回 Sprintf 以指定格式进行格式化，格式化结果以字符串形式返回 Sprintln 以默认格式进行格式化，并在末尾添加换行符，格式化结果以字符串形式返回 具体格式化规则详见Go 格式化。\n格式化输入 函数名 说明 Scan 按默认格式从os.Stdin进行扫描，空格用于分隔数据，换行符按空格处理，扫描结果存入对应的变量 Scanf 按指定格式从os.Stdin进行扫描，扫描结果存入对应的变量 Scanln 按默认格式从os.Stdin进行扫描，空格用于分隔数据，遇换行符时停止扫描，扫描结果存入对应的变量 Fscan 按默认格式从指定的io.Reader接口进行扫描，空格用于分隔数据，换行符按空格处理，扫描结果存入对应的变量 Fscanf 按指定格式从指定的io.Reader接口进行扫描，扫描结果存入对应的变量 Fscanln 按默认格式从指定的io.Reader接口进行扫描，空格用于分隔数据，遇换行符时停止扫描，扫描结果存入对应的变量 Sscan 按默认格式从指定的字符串中进行扫描，空格用于分隔数据，换行符按空格处理，扫描结果存入对应的变量 Sscanf 按指定格式从指定的字符串中进行扫描，扫描结果存入对应的变量 Sscanln 按默认格式从指定的字符串中进行扫描，空格用于分隔数据，遇换行符时停止扫描，扫描结果存入对应的变量 注意：变量前必须要带上\u0026amp;才能成功接收扫描到的数据!\n其它 函数名 说明 Append 以默认格式进行格式化，格式化结果追加到指定的字节切片，并返回新的字节切片 Appendf 以指定格式进行格式化，格式化结果追加到指定的字节切片，并返回新的字节切片 Appendln 以默认格式进行格式化，并在末尾添加换行符，格式化结果追加到指定的字节切片，并返回新的字节切片 Errorf 以指定格式进行格式化，格式化结果转为error接口并返回 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_fmt/","summary":"fmt包提供了格式化输入、输出的功能。\n格式化输出 函数名 说明 Print 以默认格式进行格式化，格式化结果输出到os.Stdout Printf 以指定格式进行格式化，格式化结果输出到os.Stdout Println 以默认格式进行格式化，并在末尾添加换行符，格式化结果输出到os.Stdout Fprint 以默认格式进行格式化，格式化结果输出到指定的io.Writer接口 Fprintf 以指定格式进行格式化，格式化结果输出到指定的io.Writer接口 Fprintln 以默认格式进行格式化，并在末尾添加换行符，格式化结果输出到指定的io.Writer接口 Sprint 以默认格式进行格式化，格式化结果以字符串形式返回 Sprintf 以指定格式进行格式化，格式化结果以字符串形式返回 Sprintln 以默认格式进行格式化，并在末尾添加换行符，格式化结果以字符串形式返回 具体格式化规则详见Go 格式化。\n格式化输入 函数名 说明 Scan 按默认格式从os.Stdin进行扫描，空格用于分隔数据，换行符按空格处理，扫描结果存入对应的变量 Scanf 按指定格式从os.Stdin进行扫描，扫描结果存入对应的变量 Scanln 按默认格式从os.Stdin进行扫描，空格用于分隔数据，遇换行符时停止扫描，扫描结果存入对应的变量 Fscan 按默认格式从指定的io.Reader接口进行扫描，空格用于分隔数据，换行符按空格处理，扫描结果存入对应的变量 Fscanf 按指定格式从指定的io.Reader接口进行扫描，扫描结果存入对应的变量 Fscanln 按默认格式从指定的io.Reader接口进行扫描，空格用于分隔数据，遇换行符时停止扫描，扫描结果存入对应的变量 Sscan 按默认格式从指定的字符串中进行扫描，空格用于分隔数据，换行符按空格处理，扫描结果存入对应的变量 Sscanf 按指定格式从指定的字符串中进行扫描，扫描结果存入对应的变量 Sscanln 按默认格式从指定的字符串中进行扫描，空格用于分隔数据，遇换行符时停止扫描，扫描结果存入对应的变量 注意：变量前必须要带上\u0026amp;才能成功接收扫描到的数据!\n其它 函数名 说明 Append 以默认格式进行格式化，格式化结果追加到指定的字节切片，并返回新的字节切片 Appendf 以指定格式进行格式化，格式化结果追加到指定的字节切片，并返回新的字节切片 Appendln 以默认格式进行格式化，并在末尾添加换行符，格式化结果追加到指定的字节切片，并返回新的字节切片 Errorf 以指定格式进行格式化，格式化结果转为error接口并返回 ","title":"Go fmt包"},{"content":"格式化动词 常规 格式化动词 含义 %v 默认格式 %T 数据的类型 %% %本身 使用%v时不同类型默认对应的格式化动词如下：\n数据类型 格式化动词 说明 bool %t int int8 等 %d uint uint8 等 %d %#v时对应%#x float32 complex64 等 %g string %s chan %p pointer %p 布尔型 格式化动词 含义 示例 结果 %t true或false 1\u0026gt;2 false 整型 格式化动词 含义 示例 结果 %b 二进制 90 1011010 %c 对应的 Unicode 字符 90 Z %d 十进制 90 90 %o 八进制 90 132 %O 带0o前缀的八进制 90 0o132 %q 用单引号包括的对应的 Unicode 字符，并且特殊字符会进行转义 90 \u0026lsquo;Z\u0026rsquo; %x 小写的十六进制 90 5a %X 大写的十六进制 90 5A %U Unicode 格式：U+1234；与U+%04X相同 90 U+005A 浮点型和复数型 格式化动词 含义 示例 结果 %b 十进制无小数的科学计数法表示浮点数，指数部分是2的幂次方 3.14 7070651414971679p-51 %e 小写e科学记数法 3.14 3.140000e+00 %E 大写E科学记数法 3.14 3.140000E+00 %f 常规的小数 3.14 3.140000 %F 同%f 3.14 3.140000 %g 大指数时同%e，否则同%f %G 大指数时同%E，否则同%F %x 小写的十六进制 3.14 0x1.91eb851eb851fp+01 %X 大写的十六进制 3.14 0X1.91EB851EB851FP+01 字符串和字节切片 格式化动词 含义 示例 结果 %s 原样 abc\t中国（中间是 tab） abc\t中国 %q 加双引号，并且特殊字符会进行转义 abc\t中国（中间是 tab） \u0026ldquo;abc\\t中国\u0026rdquo; %x 小写的十六进制，带前缀0x abc\t中国（中间是 tab） 61626309e4b8ade59bbd %X 大写的十六进制，带前缀0X abc\t中国（中间是 tab） 61626309E4b8EDE59BBD 切片 格式化动词 含义 %p 首元素地址，用加前缀0x的小写十六进制数表示 指针 格式化动词 含义 示例 结果 %p 加前缀0x的小写十六进制 %b、%d、%o、%x和%X也可用于指针。\n其它标志 + 格式化动词 含义 %+d %+f等 对于数值型，总是打印符号+/- %+v 对于结构体将显示对应字段名 - 默认是左对齐，加上-后则右对齐。\n# 格式化动词 含义 %#b 加前缀0b %#o 加前缀0o %#x 加前缀0x %#X 加前缀0X %#p 去掉前缀0x %#q 如果字符串可以用反引号括起来，则打印原始（用反引号括起来的）字符串 %#e %#E %#f %#F 总是打印小数点 %#g %#G 总是打印小数点，且不删除尾部的0 %#U 如果字符是可打印的，会以U+0078 'x'的形式输出。 %#v 对于复合类型，会显示其完整的创建表达式。对于浮点数中的无穷大（Inf）和非数字（NaN），会以+Inf、-Inf和NaN的形式输出 空格 格式化动词 含义 % d % f 等 对于数值类型，如果是正数，在前面留一个空格代替正号，实现与负数在符号上的对齐 % x % X 在打印字符串或切片时，会在字节之间添加空格 w.p宽度和精度 w和p分别为宽度和精度的具体数值。\n格式化动词 含义 %wd 仅指定宽度，实际宽度超出时按实际宽度显示，不足时左边用空格补齐 %.pd 仅指定精度，实际宽度超出时按实际宽度显示，不足时左边用0补齐 %w.pd 同时指定宽度和精度，先用%.pd格式化，再用%wd格式化 %wf 仅指定宽度，精度默认，实际宽度（含小数点及小数部分）超出时按实际宽度显示，不足时左边用空格补齐 %w.f 指定宽度，精度为0，实际宽度（不含小数点及小数部分）超出时按实际宽度显示，不足时左边用空格补齐 %.pf 仅指定精度，小数部分超出时截断，不足时右边用0补齐 %w.pf 同时指定宽度和精度，先格式化精度，再格式化宽度，宽度不足时左边用空格补齐 * *可对w.p中的w或/和p进行占位，解决/简化运行时对数据进行不同宽度、精度的格式化。\n1 2 3 fmt.Printf(\u0026#34;%*.*f\\n\u0026#34;, 8, 2, f) //与以下等效 fmt.Printf(\u0026#34;%8.2f\\n\u0026#34;, f) 0前缀 0需要在指定了w.p且w\u0026gt;0时使用才有效。\n格式化动词 含义 %0w.pd 实际宽度超出时按实际宽度显示，不足时左边用0补齐 %0w.pf 先格式化精度，再格式化宽度，宽度不足时左边用0补齐 [n]索引 默认情况下，一个格式化动词对应一个操作数，且顺序固定。\n若使用[n]索引，则可不必拘泥于操作数的顺序，且在同一条格式化语句中可以多次对同一个值进行格式化。示例如下：\n1 2 fmt.Printf(\u0026#34;%[2]d,%[1]d\\n\u0026#34;, a, b) //显示为 b,a fmt.Printf(\u0026#34;%[1]T,%[1]d\\n\u0026#34;, a) //显示为 a的类型,a的值 特别注意 1：n是从1开始！\n特别注意 2：[n]会影响后续索引！\n1 fmt.Printf(\u0026#34;%d %d %#[1]x %#x\u0026#34;, 16, 17) //输出 16 17 0x10 0x11 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_learn_format/","summary":"格式化动词 常规 格式化动词 含义 %v 默认格式 %T 数据的类型 %% %本身 使用%v时不同类型默认对应的格式化动词如下：\n数据类型 格式化动词 说明 bool %t int int8 等 %d uint uint8 等 %d %#v时对应%#x float32 complex64 等 %g string %s chan %p pointer %p 布尔型 格式化动词 含义 示例 结果 %t true或false 1\u0026gt;2 false 整型 格式化动词 含义 示例 结果 %b 二进制 90 1011010 %c 对应的 Unicode 字符 90 Z %d 十进制 90 90 %o 八进制 90 132 %O 带0o前缀的八进制 90 0o132 %q 用单引号包括的对应的 Unicode 字符，并且特殊字符会进行转义 90 \u0026lsquo;Z\u0026rsquo; %x 小写的十六进制 90 5a %X 大写的十六进制 90 5A %U Unicode 格式：U+1234；与U+%04X相同 90 U+005A 浮点型和复数型 格式化动词 含义 示例 结果 %b 十进制无小数的科学计数法表示浮点数，指数部分是2的幂次方 3.","title":"Go 格式化"},{"content":"背景 最近在改写一个加密算法，算法不可避免用到了随机数，但是Lazarus默认的随机种子初始化函数Randomize是依赖于GetTickCount的，而GetTickCount的时间精度是毫秒级的（windows平台实际大约是16ms级），日常是够用的，但在加密算法中就显得太过粗糙了。\n关于GetTickCount的时间精度，详见Delphi中的延时和在Lazarus中分析Windows和Linux的延时。\n在以上文章中有提到，windows平台下可以使用QueryPerformanceFrequency和QueryPerformanceCounter获取高精度的时间，事实上是微秒级的时间（本机实测是0.1微秒级，即百纳秒）。\n考虑跨平台的话，如何获取非windows平台的高精度时间就变得很有必要了。\n解决方案 搜索资料及查看Lazarus源码，找到了fpgettimeofday和clock_gettime两个函数。\nfpgettimeofday fpgettimeofday实际上就是UNIX平台的gettimeofday，只引用unix单元即可。其定义如下：\n1 function fpgettimeofday(tp: ptimeval;tzp:ptimezone):cint; external name \u0026#39;FPC_SYSC_GETTIMEOFDAY\u0026#39;; 其参数ptimeval的定义如下：\n1 2 3 4 5 6 7 8 9 10 timeval = record tv_sec:time_t; {$ifdef CPUSPARC64} tv_usec:cint; {$else CPUSPARC64} tv_usec:clong; {$endif CPUSPARC64} end; ptimeval = ^timeval; TTimeVal = timeval; 另外，unix平台的GetTickCount64用到了fpgettimeofday：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function GetTickCount64: QWord; var tp: TTimeVal; {$IFDEF HAVECLOCKGETTIME} ts: TTimeSpec; {$ENDIF} begin {$IFDEF HAVECLOCKGETTIME} if clock_gettime(CLOCK_MONOTONIC, @ts)=0 then begin Result := (Int64(ts.tv_sec) * 1000) + (ts.tv_nsec div 1000000); exit; end; {$ENDIF} fpgettimeofday(@tp, nil); Result := (Int64(tp.tv_sec) * 1000) + (tp.tv_usec div 1000); end; 从其命名及使用中可确定，使用fpgettimeofday获取到的时间精度为微秒级。\nclock_gettime GetTickCount64也用到了clock_gettime，其参数ptimespec的定义如下：\n1 2 3 4 5 6 timespec = record tv_sec : time_t; tv_nsec : clong; end; ptimespec = ^timespec; TTimeSpec = timespec; 从其命名及使用从其命名及使用中可确定，使用clock_gettime获取到的时间精度为纳秒级。\n注意：clock_gettime并非是在unix单元中定义的，反而是在linux和freebsd中分别定义的，因此，使用入要配合合适的编译指令共同使用。\n关于Randomize 在查看源码过程中发现，linux平台的Randomize并非是依赖于GetTickCount，实现如下：\n1 2 3 4 Procedure Randomize; Begin randseed:=longint(Fptime(nil)); End; Fptime的实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function Fptime(tloc:pTime_t): Time_t; [public, alias : \u0026#39;FPC_SYSC_TIME\u0026#39;]; {$if defined(generic_linux_syscalls) or defined(FPC_USEGETTIMEOFDAY)} VAR tv : timeval; tz : timezone; retval : longint; begin Retval:=do_syscall(syscall_nr_gettimeofday,TSysParam(@tv),TSysParam(@tz)); If retval=-1 then Fptime:=-1 else Begin If Assigned(tloc) Then TLoc^:=tv.tv_sec; Fptime:=tv.tv_sec; End; End; {$else FPC_USEGETTIMEOFDAY} begin Fptime:=do_syscall(syscall_nr_time,TSysParam(tloc)); end; {$endif FPC_USEGETTIMEOFDAY} 从中可以看出，其时间精度也是微秒级的。\n疑问：Fptime虽然是System单元通过多层{$I}指令引入的，但却无法直接调用，具体原因尚未进行深入探究。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_nanosecond/","summary":"背景 最近在改写一个加密算法，算法不可避免用到了随机数，但是Lazarus默认的随机种子初始化函数Randomize是依赖于GetTickCount的，而GetTickCount的时间精度是毫秒级的（windows平台实际大约是16ms级），日常是够用的，但在加密算法中就显得太过粗糙了。\n关于GetTickCount的时间精度，详见Delphi中的延时和在Lazarus中分析Windows和Linux的延时。\n在以上文章中有提到，windows平台下可以使用QueryPerformanceFrequency和QueryPerformanceCounter获取高精度的时间，事实上是微秒级的时间（本机实测是0.1微秒级，即百纳秒）。\n考虑跨平台的话，如何获取非windows平台的高精度时间就变得很有必要了。\n解决方案 搜索资料及查看Lazarus源码，找到了fpgettimeofday和clock_gettime两个函数。\nfpgettimeofday fpgettimeofday实际上就是UNIX平台的gettimeofday，只引用unix单元即可。其定义如下：\n1 function fpgettimeofday(tp: ptimeval;tzp:ptimezone):cint; external name \u0026#39;FPC_SYSC_GETTIMEOFDAY\u0026#39;; 其参数ptimeval的定义如下：\n1 2 3 4 5 6 7 8 9 10 timeval = record tv_sec:time_t; {$ifdef CPUSPARC64} tv_usec:cint; {$else CPUSPARC64} tv_usec:clong; {$endif CPUSPARC64} end; ptimeval = ^timeval; TTimeVal = timeval; 另外，unix平台的GetTickCount64用到了fpgettimeofday：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function GetTickCount64: QWord; var tp: TTimeVal; {$IFDEF HAVECLOCKGETTIME} ts: TTimeSpec; {$ENDIF} begin {$IFDEF HAVECLOCKGETTIME} if clock_gettime(CLOCK_MONOTONIC, @ts)=0 then begin Result := (Int64(ts.","title":"Lazarus获取纳秒级时间"},{"content":"起因 公司一个小项目，java组封了一个jar包，主要是封一个http的服务，提供几个接口，包含加密/解密和签名/验签的中间件，具体业务在数据库的存储过程里完成。\n由于没怎么接触过java，所以对如何修改配置完全不清楚，问人家，结果得到一句充满不屑和鄙视的回复——用解压工具打开直接改就行。\n呃~某些java仔还是一如既往的让人无力吐槽。算了，还是自己想办法吧。\n方法 网上搜了一下，然后试了试，嗯，可以了！\n列出jar包里的文件和文件夹，找到需要修改的文件 1 jar tf test.jar 提取文件并编辑保存 1 jar xf test.jar BOOT-INF/classes/application.yml 更新jar包 1 jar uf test.jar BOOT-INF/classes/application.yml 网上也有介绍与那个java仔说的方法类似的，不过有声明，说是可能会损坏jar包，所以并未尝试。\n题外话 java的生态确实很强，准确说是spring家族\n","permalink":"https://afrusrsc.github.io/posts/program/misc/java_jar_rebuild/","summary":"起因 公司一个小项目，java组封了一个jar包，主要是封一个http的服务，提供几个接口，包含加密/解密和签名/验签的中间件，具体业务在数据库的存储过程里完成。\n由于没怎么接触过java，所以对如何修改配置完全不清楚，问人家，结果得到一句充满不屑和鄙视的回复——用解压工具打开直接改就行。\n呃~某些java仔还是一如既往的让人无力吐槽。算了，还是自己想办法吧。\n方法 网上搜了一下，然后试了试，嗯，可以了！\n列出jar包里的文件和文件夹，找到需要修改的文件 1 jar tf test.jar 提取文件并编辑保存 1 jar xf test.jar BOOT-INF/classes/application.yml 更新jar包 1 jar uf test.jar BOOT-INF/classes/application.yml 网上也有介绍与那个java仔说的方法类似的，不过有声明，说是可能会损坏jar包，所以并未尝试。\n题外话 java的生态确实很强，准确说是spring家族","title":"修改jar包内配置并重新构建"},{"content":"前言 对于Lazarus跨平台开发接触有一段时间了，虽然踩了不坑，但仍觉得已踩过的坑不过是九牛一毛。不过还是应该记录一下，以备忘，以后又踩新坑了再补充吧。\n环境 项目 Linux Windows 操作系统 Debian 12 Win10 CPU架构 x86_64 x86_64 桌面环境 xfce 4 / 输入法 fcitx 5 系统自带 GUI环境 gtk2/qt5/qt6 win32/gtk2/qt5 目标程序 64位 32位/64位 Qt6Pas1.dll未能得到，win + qt6未测试\nlinux 64位系统未能设置好32位运行环境，未测试\nqt5未能得到64位的dll，未测试\n坑 windows Application.MessageBox按钮文字英文，无法直接本地化，Windows.MessageBoxAPI可以\nTPageControl组件自带的关闭按钮在win32下不可用，gtk2和qt5正常\nqt5下，某些组件会有很诡异的现象\ngtk2下，64位目标程序运行时报错\ngtk2下，默认界面很丑，需要用皮肤\n带GUI的dll机制和行为与delphi不一致\n使用ShareMem单元需要自行构建fpcmemdll.dll\nlinux gtk2版IDE无法输入中文；目标程序可正常输入（SynEdit不可以，必须修改相关源码）\nqt5和qt6版IDE可输入中文，但部分字无法输入，也无法正常输入多于两个字的词组；目标程序存在相同的问题\nqt5版IDE及目标程序所需要的libqt5pas一定要和编译用的IDE版本匹配\n总结 基于有限的测试经验，得出了以下结论：\n虽然Lazarus是跨平台的，并且号称一次编写，到处编译，但GUI的跨平台表现是不完全一致的，需要分别处理\n整体上，gtk2兼容性和稳定性优于qt\n最佳的开发方案：在windows系统上开发，然后交叉编译或在目标环境下进行编译（若使用了SynEdit，必须修改相关源码）\n保持跨平台一致性的方案：windows平台采用32位的gtk2+皮肤，linux平台采用gtk2+皮肤\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_cross_platform/","summary":"前言 对于Lazarus跨平台开发接触有一段时间了，虽然踩了不坑，但仍觉得已踩过的坑不过是九牛一毛。不过还是应该记录一下，以备忘，以后又踩新坑了再补充吧。\n环境 项目 Linux Windows 操作系统 Debian 12 Win10 CPU架构 x86_64 x86_64 桌面环境 xfce 4 / 输入法 fcitx 5 系统自带 GUI环境 gtk2/qt5/qt6 win32/gtk2/qt5 目标程序 64位 32位/64位 Qt6Pas1.dll未能得到，win + qt6未测试\nlinux 64位系统未能设置好32位运行环境，未测试\nqt5未能得到64位的dll，未测试\n坑 windows Application.MessageBox按钮文字英文，无法直接本地化，Windows.MessageBoxAPI可以\nTPageControl组件自带的关闭按钮在win32下不可用，gtk2和qt5正常\nqt5下，某些组件会有很诡异的现象\ngtk2下，64位目标程序运行时报错\ngtk2下，默认界面很丑，需要用皮肤\n带GUI的dll机制和行为与delphi不一致\n使用ShareMem单元需要自行构建fpcmemdll.dll\nlinux gtk2版IDE无法输入中文；目标程序可正常输入（SynEdit不可以，必须修改相关源码）\nqt5和qt6版IDE可输入中文，但部分字无法输入，也无法正常输入多于两个字的词组；目标程序存在相同的问题\nqt5版IDE及目标程序所需要的libqt5pas一定要和编译用的IDE版本匹配\n总结 基于有限的测试经验，得出了以下结论：\n虽然Lazarus是跨平台的，并且号称一次编写，到处编译，但GUI的跨平台表现是不完全一致的，需要分别处理\n整体上，gtk2兼容性和稳定性优于qt\n最佳的开发方案：在windows系统上开发，然后交叉编译或在目标环境下进行编译（若使用了SynEdit，必须修改相关源码）\n保持跨平台一致性的方案：windows平台采用32位的gtk2+皮肤，linux平台采用gtk2+皮肤","title":"Lazarus跨平台方案总结"},{"content":"事件 环境 项目 值 操作系统 Debian 12 桌面环境 xfce 4 输入法 fcitx 5 背景 最早在Debian上安装Lazarus是直接sudo apt install lazarus，即使用的是官方仓库的版本，也是戏称为万年不更新版。默认安装的是Gtk2版，该版存在中文输入法问题（输入法问题可参照解决Debian上Lazarus输入法问题）；也可以把IDE改为Qt5版，同样可以使用中文输入法。\n想用最新版Lazarus 3.4，直接在官网下载最新的deb包，没有安装成功。\n后来使用的是fpcupdeluxe-x86_64-linux安装，即Gtk2版，但是由于官方并没有合并中文输入法的解决方案，每次升级都要再做一遍，麻烦。\n现在，准备使用fpcupdeluxe-x86_64-linux-qt5直接安装Qt5版。\n问题 直接使用fpcupdeluxe-x86_64-linux-qt5安装，报错：\n1 ./fpcupdeluxe-x86_64-linux-qt5: error while loading shared libraries: libQt5Pas.so.1: cannot open shared object file: No such file or directory 是因为缺少libQt5Pas.so.1，安装libqt5pas-dev包：\n1 sudo apt install libqt5pas-dev 再次安装，又报错：\n1 ./fpcupdeluxe-x86_64-linux-qt5: symbol lookup error: ./fpcupdeluxe-x86_64-linux-qt5: undefined symbol: QGuiApplication_setFallbackSessionManagementEnabled 先安装Gtk2版，再修改为Qt5版，编译还报错。编写普通的应用，编译为Qt5版，同样报错。\n安装官方仓库的Lazarus 2.2，一切正常。\n解决 去github上查看fpcupdeluxe相关的issues，说是要下载1.2.15版的libqt5pas，并安装：\n1 sudo apt install ./libqt5pas1_2.15-1_amd64.deb ./libqt5pas-dev_2.15-1_amd64.deb 进一步查看，其实是因为Qt5删除/更新了部分接口导致不兼容了，而Debian 12的官方仓库中并未包含该更新，所以需要手动下载安装，Debian 13的官方仓库中已经包含了，像以前一样直接安装即可。\n其它相关 Qt6版同样需要手动安装对应的包，下载地址\n已知Qt5和Qt6中无法输入汉字不和有，词组最多只能输入两个字，多余的会截断。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_debian_qt5/","summary":"事件 环境 项目 值 操作系统 Debian 12 桌面环境 xfce 4 输入法 fcitx 5 背景 最早在Debian上安装Lazarus是直接sudo apt install lazarus，即使用的是官方仓库的版本，也是戏称为万年不更新版。默认安装的是Gtk2版，该版存在中文输入法问题（输入法问题可参照解决Debian上Lazarus输入法问题）；也可以把IDE改为Qt5版，同样可以使用中文输入法。\n想用最新版Lazarus 3.4，直接在官网下载最新的deb包，没有安装成功。\n后来使用的是fpcupdeluxe-x86_64-linux安装，即Gtk2版，但是由于官方并没有合并中文输入法的解决方案，每次升级都要再做一遍，麻烦。\n现在，准备使用fpcupdeluxe-x86_64-linux-qt5直接安装Qt5版。\n问题 直接使用fpcupdeluxe-x86_64-linux-qt5安装，报错：\n1 ./fpcupdeluxe-x86_64-linux-qt5: error while loading shared libraries: libQt5Pas.so.1: cannot open shared object file: No such file or directory 是因为缺少libQt5Pas.so.1，安装libqt5pas-dev包：\n1 sudo apt install libqt5pas-dev 再次安装，又报错：\n1 ./fpcupdeluxe-x86_64-linux-qt5: symbol lookup error: ./fpcupdeluxe-x86_64-linux-qt5: undefined symbol: QGuiApplication_setFallbackSessionManagementEnabled 先安装Gtk2版，再修改为Qt5版，编译还报错。编写普通的应用，编译为Qt5版，同样报错。\n安装官方仓库的Lazarus 2.2，一切正常。\n解决 去github上查看fpcupdeluxe相关的issues，说是要下载1.2.15版的libqt5pas，并安装：\n1 sudo apt install ./libqt5pas1_2.15-1_amd64.deb ./libqt5pas-dev_2.15-1_amd64.deb 进一步查看，其实是因为Qt5删除/更新了部分接口导致不兼容了，而Debian 12的官方仓库中并未包含该更新，所以需要手动下载安装，Debian 13的官方仓库中已经包含了，像以前一样直接安装即可。","title":"在Debian上使用Lazarus的Qt5问题"},{"content":"安装脚本 windows上安装PostgreSQL还是比较麻烦的，又是安装又是配置，还要设为系统服务，远不像linux上一条命令就搞定，所以参考网上其它资料整理后形成批处理文件，直接放在解压出来的pgsql根目录下执行即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ::****************************************************************************** :: 注意：需要放到 PostgreSQL 根目录下执行！！ ::****************************************************************************** @echo off ::============================================================================== set pgpath=%cd% echo 1. 安装服务 echo 2. 卸载服务 set /p op=\u0026#34;请选择操作: \u0026#34; if %op%==1 goto :Install if %op%==2 goto :Uninstall ::============================================================================== :Install echo **************************** echo * 注意：输入密码时不可见！ * echo **************************** ::初始化数据库簇 bin\\initdb -D data -U postgres -A password -E utf8 -W ::是否开启局域网访问 set /p lan=\u0026#34;是否开启局域网访问？[y/n]：\u0026#34; if %lan%==y ( echo host all all 0.0.0.0/0 password\u0026gt;\u0026gt; data\\pg_hba.conf echo listen_addresses = \u0026#39;*\u0026#39;\u0026gt;\u0026gt; data\\postgresql.conf ) ::设置端口 set /p pt=\u0026#34;设置端口(默认 5432)：\u0026#34; if not defined pt set pt=5432 if not %pt%==5432 echo port = %pt%\u0026gt;\u0026gt; data\\postgresql.conf ::注册为windows服务 bin\\pg_ctl register -D data -N PostgreSQL ::启动服务 sc start PostgreSQL goto :eof ::------------------------------------------------------------------------------ :Uninstall ::停止服务 sc stop PostgreSQL ::注销服务 bin\\pg_ctl unregister -N PostgreSQL ::删除数据 set /p d=\u0026#34;是否删除 data 目录？[y/n]: \u0026#34; if /i %d%==y rd /s /q \u0026#34;%pgpath%\\data\u0026#34; goto :eof ","permalink":"https://afrusrsc.github.io/posts/db/pgsql_zip_install/","summary":"安装脚本 windows上安装PostgreSQL还是比较麻烦的，又是安装又是配置，还要设为系统服务，远不像linux上一条命令就搞定，所以参考网上其它资料整理后形成批处理文件，直接放在解压出来的pgsql根目录下执行即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ::****************************************************************************** :: 注意：需要放到 PostgreSQL 根目录下执行！！ ::****************************************************************************** @echo off ::============================================================================== set pgpath=%cd% echo 1. 安装服务 echo 2. 卸载服务 set /p op=\u0026#34;请选择操作: \u0026#34; if %op%==1 goto :Install if %op%==2 goto :Uninstall ::============================================================================== :Install echo **************************** echo * 注意：输入密码时不可见！ * echo **************************** ::初始化数据库簇 bin\\initdb -D data -U postgres -A password -E utf8 -W ::是否开启局域网访问 set /p lan=\u0026#34;是否开启局域网访问？[y/n]：\u0026#34; if %lan%==y ( echo host all all 0.","title":"PostgreSQL zip 安装"},{"content":"前言 之前用Delphi时，研究过延时及其时间精度，并写了篇文章——Delphi中的延时，当时是仅在windows平台下测试的，现在想用Lazarus分别在windows和linux平台测试对比下。\n测试 测试环境 CPU：x86_64\nwin：win10\nlinux：debian 12.6 + xfce\nide：Lazarus 3.4 + fpc 3.2.2\n测试设计 整体与之前的设计保持一致，增加了GetTickCount64的测试，Timer的测试有改动，具体如下：\n假定系统时间是足够精确的，因此使用Now分别在延时前后获取系统当前时间来进行耗时评估。\n为使测试更具代表性，每个测试点连续测试100次，取算术平均值。\n在1ms~100ms内，测试点步长为1ms，在100ms~1000ms内，测试点步长为10ms。\n为尽可能减小干扰，测试过程中未使用并行，Sleep、GetTickCount和GetTickCount64未使用Application.ProcessMessages;，Timer绕不开事件触发，使用了Application.ProcessMessages;。\n测试结果 windows 延时(ms) Sleep GetTickCount GetTickCount64 Timer 1 1.93 15.51 15.63 15.62 2 2.93 16.59 15.62 15.63 3 3.95 15.58 15.62 15.66 4 5.10 15.49 15.94 15.61 5 5.86 15.55 15.62 15.65 6 6.83 15.50 15.62 15.63 7 7.81 15.62 15.63 15.67 8 8.77 15.55 15.63 15.68 9 9.76 15.50 15.63 15.64 10 10.77 15.59 15.63 15.62 11 11.71 15.48 15.63 15.63 12 12.71 15.56 15.63 15.63 13 13.68 15.54 15.61 15.63 14 14.69 15.63 15.62 15.62 15 15.70 15.56 15.62 15.62 16 16.59 24.82 25.00 25.02 17 17.60 31.11 31.25 31.26 18 18.59 31.24 31.25 31.24 19 19.56 31.22 31.26 31.25 20 20.56 31.16 31.25 31.26 21 21.53 31.11 31.25 31.27 22 22.50 31.21 31.26 31.24 23 23.45 31.21 31.24 31.29 24 24.58 31.16 31.25 31.25 25 25.44 31.12 31.26 31.24 26 27.20 31.23 31.24 31.25 27 27.54 31.21 31.25 31.24 28 28.34 31.19 31.26 31.26 29 30.06 31.15 31.25 31.25 30 30.38 31.18 31.25 31.27 31 31.34 31.14 31.25 31.26 32 32.31 41.59 41.72 41.56 33 33.33 46.83 46.88 46.87 34 34.30 46.78 46.87 46.89 35 35.29 46.72 46.88 46.88 36 36.35 46.77 46.88 46.86 37 37.43 46.78 46.87 46.91 38 38.51 46.75 46.88 46.89 39 39.56 46.80 46.86 46.88 40 40.79 46.86 46.87 46.91 41 41.92 46.79 46.87 46.88 42 42.92 46.75 46.87 47.23 43 44.03 48.28 46.87 46.87 44 47.16 46.74 46.88 46.91 45 46.67 46.72 46.87 46.92 46 48.00 46.81 46.89 46.84 47 47.85 49.92 50.01 50.00 48 48.98 62.41 62.50 62.50 49 49.68 62.98 63.59 62.50 50 50.73 63.18 62.65 62.51 51 51.90 62.46 62.50 62.54 52 52.75 62.37 62.47 62.50 53 57.09 63.79 62.41 62.50 54 55.96 63.22 64.07 62.50 55 58.24 63.64 63.44 62.49 56 56.64 62.56 62.51 62.53 57 59.31 62.36 62.49 62.61 58 58.86 62.45 62.50 62.51 59 59.61 62.41 63.26 62.52 60 60.63 62.46 62.50 62.83 61 68.70 64.06 66.70 62.51 62 63.70 62.36 62.65 62.55 63 66.46 75.67 75.00 75.00 64 65.40 80.31 78.13 78.11 65 65.59 78.75 78.11 78.14 66 67.53 78.08 78.28 78.13 67 67.42 78.04 78.01 78.13 68 68.45 78.11 80.20 78.11 69 70.19 78.21 79.77 78.08 70 72.36 78.07 78.13 78.14 71 71.68 77.98 78.60 78.12 72 72.54 78.09 78.12 78.16 73 73.31 78.06 78.12 78.12 74 74.31 78.04 78.43 78.16 75 75.42 82.67 81.39 78.17 76 76.39 78.25 78.13 78.11 77 78.34 78.06 78.28 78.14 78 80.03 78.42 78.11 78.13 79 79.38 93.73 93.75 93.76 80 80.58 93.63 93.75 93.76 81 81.37 93.61 93.74 93.96 82 95.52 93.90 94.51 94.08 83 89.44 94.43 93.76 93.89 84 85.00 97.95 94.04 93.75 85 87.29 93.68 93.72 93.79 86 88.90 94.03 93.75 93.90 87 87.92 93.61 93.75 93.91 88 89.34 93.63 93.74 93.75 89 89.78 93.65 93.75 93.76 90 90.90 95.81 93.90 96.11 91 91.69 93.52 93.81 93.79 92 92.71 93.66 93.75 93.71 93 93.71 93.64 94.30 93.82 94 94.76 99.93 102.50 100.02 95 95.72 109.55 110.47 109.53 96 114.63 109.25 111.25 109.69 97 97.64 109.59 109.38 109.38 98 98.78 109.81 109.69 109.37 99 99.58 109.48 109.37 109.39 100 100.67 109.30 109.38 109.43 110 110.56 124.69 125.00 125.01 120 120.28 125.03 125.14 125.01 130 130.84 140.70 141.24 140.67 140 144.30 140.66 140.63 140.66 150 150.49 156.18 156.25 156.29 160 160.38 171.76 172.66 171.90 170 174.50 172.81 171.88 171.87 180 180.58 187.39 187.50 187.50 190 190.55 203.04 203.19 203.06 200 200.89 203.32 203.12 203.12 210 210.93 218.76 218.75 218.75 220 220.72 234.28 234.37 235.16 230 230.93 234.23 234.38 234.39 240 240.86 249.89 249.98 250.03 250 250.85 249.91 250.00 249.99 260 261.73 266.03 265.63 265.60 270 270.52 281.20 281.25 281.23 280 280.56 281.16 281.24 281.24 290 290.63 296.86 296.87 296.86 300 300.77 312.35 312.49 312.50 310 310.53 312.43 312.50 312.51 320 320.62 328.13 328.12 328.12 330 330.43 343.64 343.75 343.74 340 340.75 343.63 343.75 343.81 350 350.57 359.36 359.37 359.48 360 360.85 374.83 375.00 375.01 370 370.53 374.93 375.00 375.01 380 380.80 390.60 390.63 390.64 390 390.51 390.56 390.62 390.63 400 400.59 406.28 406.26 406.25 410 410.53 421.81 421.88 421.88 420 420.67 421.82 421.88 421.94 430 430.51 437.39 437.50 437.53 440 440.56 453.00 453.13 453.12 450 450.90 453.01 453.12 453.12 460 460.67 468.71 468.74 468.73 470 470.56 484.29 484.37 484.37 480 480.61 484.24 484.37 484.38 490 490.58 499.88 500.01 500.03 500 500.59 499.85 500.00 500.02 510 510.64 515.59 515.62 515.63 520 520.52 531.17 531.26 531.27 530 530.78 531.22 531.26 531.26 540 540.54 546.79 546.88 546.92 550 550.83 562.40 562.50 562.50 560 560.48 562.49 562.50 562.53 570 570.57 578.00 578.12 578.13 580 580.58 593.63 593.75 593.76 590 590.58 593.63 593.75 593.75 600 600.51 609.34 609.37 609.43 610 610.67 624.90 625.00 625.00 620 620.53 624.94 624.99 625.04 630 630.61 640.59 640.63 640.66 640 640.91 640.61 640.63 640.63 650 650.99 656.19 656.25 656.29 660 660.58 671.88 671.88 671.87 670 670.65 671.85 671.88 671.89 680 680.55 687.40 687.50 687.53 690 690.72 703.00 703.13 703.12 700 700.59 703.00 703.13 703.13 710 710.66 718.71 718.75 718.75 720 720.68 734.30 734.38 734.36 730 730.59 734.25 734.37 734.44 740 740.51 749.90 750.00 750.04 750 750.71 749.88 749.89 750.01 760 767.71 767.43 765.60 765.71 770 772.40 782.20 785.29 783.42 780 782.34 781.16 781.20 781.26 790 791.15 796.82 798.25 796.92 800 802.97 814.65 814.25 812.50 810 821.12 860.42 814.70 813.61 820 822.23 828.34 828.12 828.17 830 832.87 843.64 843.90 843.75 840 842.62 843.48 843.90 843.74 850 851.14 859.29 859.38 859.37 860 865.43 874.82 874.91 875.00 870 870.97 874.97 874.98 874.99 880 881.05 891.12 890.63 890.62 890 891.07 890.59 890.61 890.88 900 901.54 906.18 906.40 906.29 910 911.32 924.00 922.41 922.03 920 921.20 921.88 923.91 922.05 930 930.63 937.62 937.51 937.50 940 940.81 953.09 953.12 953.12 950 950.94 953.12 953.13 953.14 960 960.62 968.90 968.74 968.79 970 970.56 984.24 984.38 984.36 980 980.67 984.33 984.37 984.44 990 990.63 999.93 1000.00 1000.00 1000 1000.60 999.86 1000.00 1000.00 linux 延时(ms) Sleep GetTickCount GetTickCount64 Timer 1 1.38 1.03 1.11 1.48 2 2.67 2.10 2.16 2.15 3 3.57 3.23 3.18 3.36 4 4.49 4.02 4.32 4.13 5 5.54 5.27 5.52 5.38 6 6.73 6.12 6.20 6.33 7 7.57 7.41 7.27 7.28 8 8.52 8.16 8.11 8.21 9 9.52 9.17 9.16 9.51 10 10.46 10.40 10.28 10.65 11 11.52 11.17 11.29 11.48 12 12.70 12.06 12.13 12.65 13 13.50 13.61 13.27 13.29 14 14.83 14.32 14.08 16.12 15 15.50 15.07 15.54 15.45 16 16.51 16.09 16.08 16.10 17 17.60 17.15 17.06 17.31 18 18.47 18.15 18.10 18.88 19 19.46 19.23 19.15 19.49 20 20.47 20.20 20.07 20.47 21 21.50 21.21 21.47 21.45 22 22.42 22.08 22.08 22.32 23 23.59 23.13 23.30 23.36 24 24.43 24.19 24.10 24.25 25 25.46 25.11 25.13 25.35 26 26.50 26.23 26.10 26.33 27 27.43 27.08 27.09 27.32 28 28.39 28.32 28.05 28.26 29 29.57 29.15 29.20 29.14 30 30.55 30.27 30.21 30.37 31 31.41 31.37 31.42 31.45 32 32.42 32.11 32.08 32.25 33 33.48 33.07 33.16 33.20 34 34.40 34.10 34.10 34.41 35 35.54 35.09 35.03 35.35 36 36.40 36.01 36.07 36.29 37 37.46 37.16 37.19 37.29 38 38.59 38.12 38.23 38.30 39 39.47 39.19 39.19 39.48 40 40.40 40.04 40.05 40.32 41 41.49 41.27 41.20 41.45 42 42.52 42.14 42.16 42.41 43 43.54 43.03 43.04 43.14 44 44.48 44.10 44.03 44.22 45 45.60 45.10 45.11 45.20 46 46.50 46.16 46.18 46.53 47 47.57 47.16 47.18 47.25 48 48.53 48.09 48.22 48.36 49 49.60 49.24 49.44 49.18 50 50.44 50.10 50.09 50.24 51 51.50 51.55 51.11 51.69 52 52.54 52.17 52.36 52.45 53 53.45 53.36 53.43 53.64 54 54.47 54.14 54.31 54.30 55 55.60 55.13 55.24 55.22 56 56.56 56.03 56.19 56.17 57 57.54 57.08 57.53 57.36 58 58.58 58.18 58.08 58.63 59 59.54 59.05 59.14 59.04 60 60.49 60.03 60.07 60.54 61 61.62 61.74 61.47 61.46 62 62.53 62.25 62.93 62.91 63 63.56 64.00 63.40 63.72 64 64.44 64.25 64.58 65.36 65 65.56 65.25 65.11 65.15 66 66.50 66.14 66.12 66.24 67 67.43 67.65 67.15 67.32 68 68.38 68.05 68.36 68.59 69 70.16 70.39 70.13 69.78 70 70.58 70.78 70.56 70.78 71 71.45 71.58 71.24 72.08 72 72.48 72.16 72.03 72.81 73 73.43 73.12 73.18 73.28 74 74.49 74.13 74.37 74.47 75 75.35 75.09 75.12 75.13 76 76.44 76.40 76.10 76.32 77 77.50 77.46 77.12 77.57 78 78.40 78.27 78.12 78.31 79 79.47 79.13 79.11 79.45 80 80.41 80.13 80.12 80.37 81 81.44 81.14 81.23 81.34 82 82.55 82.19 82.25 84.44 83 83.71 83.34 83.19 83.45 84 84.50 84.11 84.42 84.85 85 85.74 85.58 85.44 85.70 86 86.58 86.03 86.14 86.15 87 87.69 87.18 87.12 87.23 88 88.46 88.04 97.47 88.22 89 89.55 90.00 89.64 89.70 90 91.42 91.01 90.71 90.37 91 91.64 91.16 92.14 91.42 92 92.49 92.15 92.07 92.17 93 93.49 93.23 93.57 93.47 94 94.52 94.19 94.38 94.47 95 95.57 95.30 95.28 95.31 96 96.55 96.11 96.06 96.48 97 97.52 97.09 97.73 97.46 98 98.71 98.07 98.35 98.55 99 99.60 99.13 99.18 99.71 100 100.83 100.16 100.30 100.78 110 110.49 110.31 110.42 110.22 120 120.47 120.19 121.13 121.35 130 130.70 130.48 130.26 130.21 140 140.69 140.56 140.07 140.85 150 150.48 150.27 150.28 150.23 160 160.52 160.07 160.07 160.41 170 170.43 170.20 170.58 170.41 180 180.52 180.05 180.24 180.87 190 190.41 190.21 190.12 190.25 200 200.40 200.09 200.27 200.30 210 210.55 210.60 210.46 210.43 220 220.54 220.09 220.05 220.27 230 230.47 230.14 230.20 230.71 240 240.68 240.22 240.08 240.21 250 250.51 250.56 250.06 250.30 260 260.45 260.22 260.10 260.30 270 270.43 270.06 270.14 270.32 280 280.41 280.12 280.09 280.22 290 290.48 290.48 290.40 290.23 300 300.53 300.10 300.24 300.22 310 310.50 310.24 310.14 310.45 320 320.44 320.12 320.15 320.19 330 330.46 330.10 330.18 330.27 340 340.41 340.11 340.05 340.40 350 350.48 350.19 350.14 350.44 360 360.45 360.13 360.12 360.20 370 370.50 370.20 370.13 370.22 380 380.43 380.07 380.05 380.27 390 390.44 390.05 390.08 390.26 400 400.42 400.15 400.03 400.20 410 410.46 410.12 410.10 410.28 420 420.45 420.00 420.12 420.28 430 430.48 430.10 430.08 430.21 440 440.45 440.02 440.09 440.11 450 450.51 450.22 450.11 450.39 460 460.48 460.10 460.14 460.29 470 470.55 470.28 470.08 470.62 480 480.50 480.24 480.37 480.61 490 490.56 490.06 490.08 490.17 500 500.54 500.13 500.03 500.40 510 510.56 510.13 510.18 510.35 520 520.43 520.09 520.09 520.23 530 530.51 530.18 530.19 530.26 540 540.51 540.10 540.16 540.40 550 550.52 550.13 550.20 550.30 560 560.45 560.08 560.15 560.20 570 570.44 570.12 570.33 570.30 580 580.38 580.19 580.05 580.18 590 590.41 590.08 590.05 590.27 600 600.41 600.08 600.07 600.26 610 610.49 610.33 610.20 610.27 620 620.50 619.99 620.14 620.36 630 630.45 630.11 630.08 630.32 640 640.41 640.18 640.08 640.13 650 650.51 650.19 650.19 650.23 660 660.39 660.04 660.04 660.16 670 670.49 670.37 670.18 670.25 680 680.39 680.13 680.21 680.24 690 690.45 690.30 690.10 690.26 700 700.41 700.23 700.08 700.19 710 710.44 710.09 710.21 710.28 720 720.45 720.06 720.04 720.16 730 730.45 730.07 730.13 730.23 740 740.44 740.19 740.11 740.08 750 750.42 750.12 750.26 750.41 760 760.46 760.06 760.15 760.28 770 770.74 770.45 770.42 770.58 780 780.90 780.30 780.33 780.63 790 792.37 790.56 790.35 790.54 800 800.57 800.29 800.37 800.33 810 810.71 810.34 810.49 812.78 820 820.70 820.41 821.46 823.84 830 830.63 830.22 830.50 830.55 840 840.55 840.19 840.26 840.52 850 850.67 850.37 850.27 850.47 860 860.48 860.25 860.58 860.41 870 870.52 870.73 870.84 870.86 880 880.51 880.22 880.15 880.55 890 890.59 890.27 890.30 890.53 900 902.35 900.28 900.28 900.38 910 910.54 910.27 910.51 910.55 920 920.56 920.58 920.28 920.57 930 930.70 930.29 930.33 930.61 940 941.74 940.11 940.20 940.76 950 950.74 950.09 950.19 950.26 960 960.44 960.09 960.17 960.39 970 970.46 970.09 970.12 970.39 980 980.44 980.11 980.14 980.29 990 990.52 990.06 990.44 990.33 1000 1000.46 1000.03 1000.23 1000.13 结论 windows平台，GetTickCount、GetTickCount64、Timer三者差别不大，都是以大约15.6ms为一个梯度；Sleep相对精度更高一些。\nlinux平台，Sleep、GetTickCount、GetTickCount64、Timer四者差别都不大，但Sleep和Timer的线性（即精度）略不如GetTickCount和GetTickCount64。\n精度级别 方法 1 linux平台的GetTickCount和GetTickCount64 2 两个平台的Sleep和linux平台的Timer 3 windows平台的GetTickCount、GetTickCount64、Timer ","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_delay/","summary":"前言 之前用Delphi时，研究过延时及其时间精度，并写了篇文章——Delphi中的延时，当时是仅在windows平台下测试的，现在想用Lazarus分别在windows和linux平台测试对比下。\n测试 测试环境 CPU：x86_64\nwin：win10\nlinux：debian 12.6 + xfce\nide：Lazarus 3.4 + fpc 3.2.2\n测试设计 整体与之前的设计保持一致，增加了GetTickCount64的测试，Timer的测试有改动，具体如下：\n假定系统时间是足够精确的，因此使用Now分别在延时前后获取系统当前时间来进行耗时评估。\n为使测试更具代表性，每个测试点连续测试100次，取算术平均值。\n在1ms~100ms内，测试点步长为1ms，在100ms~1000ms内，测试点步长为10ms。\n为尽可能减小干扰，测试过程中未使用并行，Sleep、GetTickCount和GetTickCount64未使用Application.ProcessMessages;，Timer绕不开事件触发，使用了Application.ProcessMessages;。\n测试结果 windows 延时(ms) Sleep GetTickCount GetTickCount64 Timer 1 1.93 15.51 15.63 15.62 2 2.93 16.59 15.62 15.63 3 3.95 15.58 15.62 15.66 4 5.10 15.49 15.94 15.61 5 5.86 15.55 15.62 15.65 6 6.83 15.50 15.62 15.63 7 7.81 15.62 15.63 15.67 8 8.77 15.55 15.63 15.68 9 9.76 15.","title":"在Lazarus中分析Windows和Linux的延时"},{"content":"问题 使用Delphi开发应用时，如果要在主程序和dll间传递字符串、对象等不兼容C的类型时，通常需要在主程序和dll工程的uses区第一个位置引用ShareMem单元，并将borlndmm.dll随应用一起发布使用。\nLazarus中也有ShareMem单元，说明也可以采用相同的策略解决同样的需求，但是并不是使用borlndmm.dll。\n在源码sharemem.pp中可以看到const fpcmemdll = 'fpcmemdll.dll';，说明使用的是fpcmemdll.dll，但是这个dll实际上是并不存在的！\n解决 全盘搜索并没有找到fpcmemdll.dll，但是却找到了fpcmemdll.pp。\n打开fpcmemdll.pp后发现，其实这并不是一个普通的用于uses的单元，而是一个library工程单元，那么问题就好办了。\n创建一个空白library工程，并命名为fpcmemdll\n复制fpcmemdll.pp内容到fpcmemdll.lpr\n构建fpcmemdll.lpr得到fpcmemdll.dll\n其它 linux平台似乎并没有ShareMem单元，也不存在以上用法，应该是只有windows平台才要这样用。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_sharemem/","summary":"问题 使用Delphi开发应用时，如果要在主程序和dll间传递字符串、对象等不兼容C的类型时，通常需要在主程序和dll工程的uses区第一个位置引用ShareMem单元，并将borlndmm.dll随应用一起发布使用。\nLazarus中也有ShareMem单元，说明也可以采用相同的策略解决同样的需求，但是并不是使用borlndmm.dll。\n在源码sharemem.pp中可以看到const fpcmemdll = 'fpcmemdll.dll';，说明使用的是fpcmemdll.dll，但是这个dll实际上是并不存在的！\n解决 全盘搜索并没有找到fpcmemdll.dll，但是却找到了fpcmemdll.pp。\n打开fpcmemdll.pp后发现，其实这并不是一个普通的用于uses的单元，而是一个library工程单元，那么问题就好办了。\n创建一个空白library工程，并命名为fpcmemdll\n复制fpcmemdll.pp内容到fpcmemdll.lpr\n构建fpcmemdll.lpr得到fpcmemdll.dll\n其它 linux平台似乎并没有ShareMem单元，也不存在以上用法，应该是只有windows平台才要这样用。","title":"在Lazarus中使用ShareMem"},{"content":"前言 之前的配置Lazarus免重装和Lazarus开发环境配置主要是针对windows平台的，同样也适用于linux平台，只是需要稍微变通一些。当然，由于linux平台本身的多样性，自然也会有一些特殊的坑，例如：解决Debian上Lazarus输入法问题。\n在交流中，群友们也多次提到并推荐用fpcupdeluxe，体验了下，直观的感受就是——非常适合折腾！当然，不用来折腾的话也是非常方便的。\n准备工作 访问GitHub 该问题请自行解决。\n安装Git fpcupdeluxe是直接从源码构建Lazarus的，而Lazarus及fpc的源码是托管在GitLab上的，其本身依赖的工具又是在GitHub上，因此Git是必不可少的。安装可参考Git的基本使用。\n下载fpcupdeluxe 可以在fpcupdeluxe的Releases页选择合适的版本下载fpcupdeluxe。linux平台注意要给予执行权限。\n安装 核心IDE安装 建议专门建一个目录用于安装，例如就叫fpcupdeluxe，然后把下载的fpcupdeluxe文件放入，并运行。首次运行会有是否记录日志的提示，依据自己情况选择。 配置界面语言及安装路径，建议与fpcupdeluxe安装文件相同。\n点Stable/稳定版本（也可选择其它版本），确认后即可自动下载依赖，然后完成基本IDE的安装。如果安装失败了，排除问题后，再次操作3.即可。\n对于linux，可能会提示缺少依赖，如：\n1 2 3 4 5 6 7 8 9 10 [Info] Checking dev-libs for gtk2 LCLWidgetType. [Error] Missing library: [Error] libX11.so [Error] libgdk_pixbuf-2.0.so [Error] libpango-1.0.so [Error] libcairo.so [Error] libgdk-x11-2.0.so [Warning] You need to install at least libx11-dev libgtk2.0-dev libcairo2-dev libpango1.0-dev libxtst-dev libgdk-pixbuf2.0-dev libatk1.0-dev libghc-x11-dev to build Lazarus !! [Warning] Make, binutils and git are also required !! [Warning] Gdb is optional, but recommended. 此时，根据提示安装对应的包，然后再次操作3.即可。对于上面这个提示：\n1 sudo apt install libx11-dev libgtk2.0-dev libcairo2-dev libpango1.0-dev libxtst-dev libgdk-pixbuf2.0-dev libatk1.0-dev libghc-x11-dev 注意：此时安装完的IDE可以说是相当精简的了，部分标准安装包安装的内容可以按需进行单独安装。\n可选包安装 对于喜欢一体式窗口的人来说，可以直接在fpcupdeluxe中Modules/模块页点Dock按钮完成。\n对于喜欢在IDE里安装第三方在线组件包的人，可以直接在fpcupdeluxe中Modules/模块页点OPM/在线包管理器按钮完成。\n对于使用第三方在线组件的人，可以直接在fpcupdeluxe中Modules/模块页选择要安装的组件，点Install module/安装模块按钮完成；也可在IDE中进行安装。\n交叉编译器安装 对于有交叉编译需求的人来说，这应该算是使用fpcupdeluxe安装最亮眼的功能。\n在fpcupdeluxe中Cross/交叉页选择CPU和OS/操作系统，点Install compiler/安装编译器按钮完成。\n2025-08-19补充 补充1 debian 13会提示libgdk-pixbuf2.0-dev可能已废弃，需用libgdk-pixbuf-xlib-2.0-dev替代\n1 sudo apt install libx11-dev libgtk2.0-dev libcairo2-dev libpango1.0-dev libxtst-dev libgdk-pixbuf-xlib-2.0-dev libatk1.0-dev libghc-x11-dev 补充2 fpcupdeluxe已经很久没更新了，lazarus官方已经到4.2了，fpcupdeluxe还停留在3.6，中间差了3.8、4.0两个版本，但是可以通过修改fpcup.ini文件来安装，毕竟fpcupdeluxe是通过编译源码来安装lazarus的。\n在fpcup.ini文件中的[ALIASlazURL]节添加以下内容：\n1 2 3 4.2.zip=https://gitlab.com/freepascal.org/lazarus/lazarus/-/archive/lazarus_4_2/lazarus-lazarus_4_2.zip 4.0.zip=https://gitlab.com/freepascal.org/lazarus/lazarus/-/archive/lazarus_4_0/lazarus-lazarus_4_0.zip 3.8.zip=https://gitlab.com/freepascal.org/lazarus/lazarus/-/archive/lazarus_3_8/lazarus-lazarus_3_8.zip 然后在[ALIASlazTAG]节添加以下内容：\n1 2 3 4.2.gitlab=lazarus_4_2 4.0.gitlab=lazarus_4_0 3.8.gitlab=lazarus_3_8 之后，即可在fpcupdeluxe中选择指定的版本进行安装了。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_fpcupdeluxe_install/","summary":"前言 之前的配置Lazarus免重装和Lazarus开发环境配置主要是针对windows平台的，同样也适用于linux平台，只是需要稍微变通一些。当然，由于linux平台本身的多样性，自然也会有一些特殊的坑，例如：解决Debian上Lazarus输入法问题。\n在交流中，群友们也多次提到并推荐用fpcupdeluxe，体验了下，直观的感受就是——非常适合折腾！当然，不用来折腾的话也是非常方便的。\n准备工作 访问GitHub 该问题请自行解决。\n安装Git fpcupdeluxe是直接从源码构建Lazarus的，而Lazarus及fpc的源码是托管在GitLab上的，其本身依赖的工具又是在GitHub上，因此Git是必不可少的。安装可参考Git的基本使用。\n下载fpcupdeluxe 可以在fpcupdeluxe的Releases页选择合适的版本下载fpcupdeluxe。linux平台注意要给予执行权限。\n安装 核心IDE安装 建议专门建一个目录用于安装，例如就叫fpcupdeluxe，然后把下载的fpcupdeluxe文件放入，并运行。首次运行会有是否记录日志的提示，依据自己情况选择。 配置界面语言及安装路径，建议与fpcupdeluxe安装文件相同。\n点Stable/稳定版本（也可选择其它版本），确认后即可自动下载依赖，然后完成基本IDE的安装。如果安装失败了，排除问题后，再次操作3.即可。\n对于linux，可能会提示缺少依赖，如：\n1 2 3 4 5 6 7 8 9 10 [Info] Checking dev-libs for gtk2 LCLWidgetType. [Error] Missing library: [Error] libX11.so [Error] libgdk_pixbuf-2.0.so [Error] libpango-1.0.so [Error] libcairo.so [Error] libgdk-x11-2.0.so [Warning] You need to install at least libx11-dev libgtk2.0-dev libcairo2-dev libpango1.0-dev libxtst-dev libgdk-pixbuf2.0-dev libatk1.0-dev libghc-x11-dev to build Lazarus !! [Warning] Make, binutils and git are also required !","title":"使用fpcupdeluxe安装配置Lazarus"},{"content":" 文章参考了Hugo博客目录放在侧边\n修改配置 文章较长时，能够显示可直接跳转的目录是极好的，PaperMod原生就支持目录，只需简单修改配置即可。\n在config.yml中，添加或修改params对应的配置为以下内容：\n1 2 3 params: ShowToc: true TocOpen: true 目录移至侧边 虽然PaperMod原生就有目录，但是却是在顶部，便捷性几乎为0，放在侧边就会方便许多。\n在项目目录layouts/partials下添加toc.html文件，内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 {{- $headers := findRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;(.|\\n])+?\u0026lt;/h[1-6]\u0026gt;\u0026#34; .Content -}} {{- $has_headers := ge (len $headers) 1 -}} {{- if $has_headers -}} \u0026lt;aside id=\u0026#34;toc-container\u0026#34; class=\u0026#34;toc-container wide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;toc\u0026#34;\u0026gt; \u0026lt;details {{if (.Param \u0026#34;TocOpen\u0026#34;) }} open{{ end }}\u0026gt; \u0026lt;summary accesskey=\u0026#34;c\u0026#34; title=\u0026#34;(Alt + C)\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;details\u0026#34;\u0026gt;{{- i18n \u0026#34;toc\u0026#34; | default \u0026#34;Table of Contents\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/summary\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; {{- $largest := 6 -}} {{- range $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{- if lt $headerLevel $largest -}} {{- $largest = $headerLevel -}} {{- end -}} {{- end -}} {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice -}} \u0026lt;ul\u0026gt; {{- range seq (sub $firstHeaderLevel $largest) -}} \u0026lt;ul\u0026gt; {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (sub (add $largest .) 1) -}} {{- end -}} {{- range $i, $header := $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{/* get id=\u0026#34;xyz\u0026#34; */}} {{- $id := index (findRE \u0026#34;(id=\\\u0026#34;(.*?)\\\u0026#34;)\u0026#34; $header 9) 0 }} {{- /* strip id=\u0026#34;\u0026#34; to leave xyz, no way to get regex capturing groups in hugo */ -}} {{- $cleanedID := replace (replace $id \u0026#34;id=\\\u0026#34;\u0026#34; \u0026#34;\u0026#34;) \u0026#34;\\\u0026#34;\u0026#34; \u0026#34;\u0026#34; }} {{- $header := replaceRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;((.|\\n])+?)\u0026lt;/h[1-6]\u0026gt;\u0026#34; \u0026#34;$1\u0026#34; $header -}} {{- if ne $i 0 -}} {{- $prevHeaderLevel := index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub $i 1)) 1) 0 -}} {{- $prevHeaderLevel := len (seq $prevHeaderLevel) -}} {{- if gt $headerLevel $prevHeaderLevel -}} {{- range seq $prevHeaderLevel (sub $headerLevel 1) -}} \u0026lt;ul\u0026gt; {{/* the first should not be recorded */}} {{- if ne $prevHeaderLevel . -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; . -}} {{- end -}} {{- end -}} {{- else -}} \u0026lt;/li\u0026gt; {{- if lt $headerLevel $prevHeaderLevel -}} {{- range seq (sub $prevHeaderLevel 1) -1 $headerLevel -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) . -}} \u0026lt;/ul\u0026gt; {{/* manually do pop item */}} {{- $tmp := $.Scratch.Get \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Delete \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice}} {{- range seq (sub (len $tmp) 1) -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (index $tmp (sub . 1)) -}} {{- end -}} {{- else -}} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end -}} {{- end -}} {{- end }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- else }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- end -}} {{- end -}} \u0026lt;!-- {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} --\u0026gt; {{- $firstHeaderLevel := $largest }} {{- $lastHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub (len $headers) 1)) 1) 0)) }} \u0026lt;/li\u0026gt; {{- range seq (sub $lastHeaderLevel $firstHeaderLevel) -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) (add . $firstHeaderLevel) }} \u0026lt;/ul\u0026gt; {{- else }} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end }} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/details\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; \u0026lt;script\u0026gt; let activeElement; let elements; window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function (event) { checkTocPosition(); elements = document.querySelectorAll(\u0026#39;h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]\u0026#39;); // Make the first header active activeElement = elements[0]; const id = encodeURI(activeElement.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); }, false); window.addEventListener(\u0026#39;resize\u0026#39;, function(event) { checkTocPosition(); }, false); window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; { // Check if there is an object in the top half of the screen or keep the last item active activeElement = Array.from(elements).find((element) =\u0026gt; { if ((getOffsetTop(element) - window.pageYOffset) \u0026gt; 0 \u0026amp;\u0026amp; (getOffsetTop(element) - window.pageYOffset) \u0026lt; window.innerHeight/2) { return element; } }) || activeElement elements.forEach(element =\u0026gt; { const id = encodeURI(element.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); if (element === activeElement){ document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); } else { document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.remove(\u0026#39;active\u0026#39;); } }) }, false); const main = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--article-width\u0026#39;), 10); const toc = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--toc-width\u0026#39;), 10); const gap = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--gap\u0026#39;), 10); function checkTocPosition() { const width = document.body.scrollWidth; if (width - main - (toc * 2) - (gap * 4) \u0026gt; 0) { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.add(\u0026#34;wide\u0026#34;); } else { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.remove(\u0026#34;wide\u0026#34;); } } function getOffsetTop(element) { if (!element.getClientRects().length) { return 0; } let rect = element.getBoundingClientRect(); let win = element.ownerDocument.defaultView; return rect.top + win.pageYOffset; } \u0026lt;/script\u0026gt; {{- end }} 在项目目录assets/css/extended下添加blank.css文件，内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 :root { --nav-width: 1380px; --article-width: 650px; --toc-width: 300px; } .toc { margin: 0 2px 40px 2px; border: 1px solid var(--border); background: var(--entry); border-radius: var(--radius); padding: 0.4em; } .toc-container.wide { position: absolute; height: 100%; border-right: 1px solid var(--border); left: calc((var(--toc-width) + var(--gap)) * -1); top: calc(var(--gap) * 2); width: var(--toc-width); } .wide .toc { position: sticky; top: var(--gap); border: unset; background: unset; border-radius: unset; width: 100%; margin: 0 2px 40px 2px; } .toc details summary { cursor: zoom-in; margin-inline-start: 20px; padding: 12px 0; } .toc details[open] summary { font-weight: 500; } .toc-container.wide .toc .inner { margin: 0; } .active { font-size: 110%; font-weight: 600; } .toc ul { list-style-type: circle; } .toc .inner { margin: 0 0 0 20px; padding: 0px 15px 15px 20px; font-size: 16px; /*目录显示高度*/ max-height: 83vh; overflow-y: auto; } .toc .inner::-webkit-scrollbar-thumb { /*滚动条*/ background: var(--border); border: 7px solid var(--theme); border-radius: var(--radius); } .toc li ul { margin-inline-start: calc(var(--gap) * 0.5); list-style-type: none; } .toc li { list-style: none; font-size: 0.95rem; padding-bottom: 5px; } .toc li a:hover { color: var(--secondary); } ","permalink":"https://afrusrsc.github.io/posts/blog/hugo04/","summary":"文章参考了Hugo博客目录放在侧边\n修改配置 文章较长时，能够显示可直接跳转的目录是极好的，PaperMod原生就支持目录，只需简单修改配置即可。\n在config.yml中，添加或修改params对应的配置为以下内容：\n1 2 3 params: ShowToc: true TocOpen: true 目录移至侧边 虽然PaperMod原生就有目录，但是却是在顶部，便捷性几乎为0，放在侧边就会方便许多。\n在项目目录layouts/partials下添加toc.html文件，内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 {{- $headers := findRE \u0026#34;\u0026lt;h[1-6].","title":"用Hugo搭建个人博客——显示目录"},{"content":" 文章参考了Hugo博客添加mermaid作图\n文章可以使用Mermaid添加流程图等，来增强信息传递效率和阅读体验，但PaperMod原生似乎并不支持（或者支持得不好？）Mermaid。\n修改方法 在项目目录layouts/shortcodes下添加mermaid.html，内容如下： 1 2 3 \u0026lt;div class=\u0026#34;mermaid\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt; {{.Inner}} \u0026lt;/div\u0026gt; 复制主题目录themes/hugo-PaperMod/layouts/partials下的header.html到项目目录layouts/partials，然后在开头插入以下内容： 1 2 3 {{ if (.Params.mermaid) }} \u0026lt;script async src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} 在archetypes/default.md或者对应的模板头里添加以下内容： 1 mermaid: true 使用方法 把Markdown的语法标识替换为用{{}}包换的\u0026lt;mermaid\u0026gt;和\u0026lt;/mermaid\u0026gt;标签（由于会直接被识别成shortcode进行解析，只能用语言描述），包括住实际的mermaid代码。\ngraph LR a--\u003eb-.-\u003ec ","permalink":"https://afrusrsc.github.io/posts/blog/hugo03/","summary":" 文章参考了Hugo博客添加mermaid作图\n文章可以使用Mermaid添加流程图等，来增强信息传递效率和阅读体验，但PaperMod原生似乎并不支持（或者支持得不好？）Mermaid。\n修改方法 在项目目录layouts/shortcodes下添加mermaid.html，内容如下： 1 2 3 \u0026lt;div class=\u0026#34;mermaid\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt; {{.Inner}} \u0026lt;/div\u0026gt; 复制主题目录themes/hugo-PaperMod/layouts/partials下的header.html到项目目录layouts/partials，然后在开头插入以下内容： 1 2 3 {{ if (.Params.mermaid) }} \u0026lt;script async src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} 在archetypes/default.md或者对应的模板头里添加以下内容： 1 mermaid: true 使用方法 把Markdown的语法标识替换为用{{}}包换的\u0026lt;mermaid\u0026gt;和\u0026lt;/mermaid\u0026gt;标签（由于会直接被识别成shortcode进行解析，只能用语言描述），包括住实际的mermaid代码。\ngraph LR a--\u003eb-.-\u003ec ","title":"用Hugo搭建个人博客——支持Mermaid"},{"content":"空空如也的页面，需要好好配置一番才能丰富多彩。\n配置config.yml 隐性配置 在上一篇config.yml的基础上先加入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 copyright: \u0026#34;© 20xx [xxx](https://github.com/xxx)\u0026#34; # 版权说明 paginate: 5 # 每页文章数 enableInlineShortcodes: true # 是否使用短码 enableRobotsTXT: true # 是否允许被搜索引擎收录 buildDrafts: false buildFuture: false buildExpired: false enableEmoji: true # 是否使用emoji表情 pygmentsUseClasses: true mainsections: [\u0026#34;posts\u0026#34;, \u0026#34;papermod\u0026#34;] minify: disableXML: true outputs: home: - HTML - RSS - JSON markup: goldmark: renderer: unsafe: true highlight: noClasses: false codeFences: true guessSyntax: true lineNos: true services: instagram: disableInlineCSS: true twitter: disableInlineCSS: true params: env: production description: \u0026#34;xxx\u0026#39;s blog\u0026#34; author: xxx # 作者 defaultTheme: auto ShowShareButtons: false # 是否显示分享按钮 ShowReadingTime: true # 是否显示阅读时间 displayFullLangName: true ShowPostNavLinks: true # 是否显示上一页下一页 ShowBreadCrumbs: true ShowCodeCopyButtons: true # 是否在代码上显示复制按钮 ShowRssButtonInSectionTermList: false ShowAllPagesInArchive: true ShowPageNums: true # 是否显示页数 ShowToc: false # 是否显示目录 DateFormat: \u0026#34;2006-01-02 15:04:05\u0026#34; # 时间格式 socialIcons: - name: github title: View Source on Github url: \u0026#34;https://github.com/xxx\u0026#34; label: text: \u0026#34;xxx\u0026#34; icon: icon.png iconHeight: 35 assets: disableHLJS: true 以上的xxx换成自己的内容。当然，此时看到的页面不会有太大的变化，因为这些都是相对比较隐性的设置。\n后期一些细节上的调整基本上是在这一部分进行修改。\n首页配置 然后再加入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 defaultContentLanguage: zh languages: zh: languageName: \u0026#34;简体中文\u0026#34; weight: 1 taxonomies: category: categories tag: tags series: series menu: # 导航菜单 main: - name: 搜索 url: search/ weight: 1 - name: 主页 url: / weight: 2 - name: 文章 url: posts/ weight: 3 - name: 时间轴 url: archives/ weight: 998 - name: 关于 url: about/ weight: 999 params: profileMode: enabled: true title: \u0026#34;这是个大标题\u0026#34; imageUrl: \u0026#34;\u0026#34; # 头像地址 imageTitle: 头像 imageWidth: 320 # 头像尺寸 imageHeight: 320 # 头像尺寸 subtitle: \u0026#34;这是个小标题\u0026#34; buttons: # 首页展示的按钮 - name: 分类 url: categories/ - name: 标签 url: tag/ - name: 系列 url: series/ 此时的页面已经像那么回事了，后期的维护也主要是调整这一部分的内容。\n目录维护 经过以上配置，页面是有了，不过只是徒有其表罢了，因为还没有内容框架的支撑，点菜单、按钮还是会没内容或显示404。\n按如下目录结构创建文件夹及文件：\n1 2 3 4 5 6 7 8 9 10 11 12 content/ ├── about.md ├── archives.md ├── categories │ └── _index.md ├── posts │ └── _index.md ├── search.md ├── series │ └── _index.md └── tags └── _index.md about.md 加入以下内容，并在其后写上具体的自我介绍，点关于菜单即可看到具体内容。\n1 2 3 4 5 --- title: \u0026#34;关于\u0026#34; layout: about hidemeta: true --- archives.md 加入以下内容，不需要写其它内容，以后添加的文章会自动按时间倒序显示在此处。\n1 2 3 4 5 --- title: \u0026#34;时间轴\u0026#34; layout: archives summary: archives --- search.md 加入以下内容，不需要写其它内容，搜索功能即可使用\n1 2 3 4 --- title: \u0026#34;搜索\u0026#34; layout: search --- categories/_index.md 加入以下内容，不需要写其它内容，文章指定了categories即可按categories的内容自动分类，点分类按钮即查看具体分类。\n1 2 3 4 5 --- title: \u0026#34;分类\u0026#34; layout: categories summary: categories --- series/_index.md 加入以下内容，不需要写其它内容，文章指定了series即可按series的内容自动分类，点系列按钮即查看具体分组。\n1 2 3 4 5 --- title: \u0026#34;系列\u0026#34; layout: series summary: series --- tags/_index.md 加入以下内容，不需要写其它内容，文章指定了tags即可按tags的内容自动分类，点标签按钮即查看具体分组。\n1 2 3 4 5 --- title: \u0026#34;标签\u0026#34; layout: tags summary: tags --- posts posts是以后存放文章的根目录，可以根据需要再建子目录，子目录内也可继续建子目录，但要求每个目录下都要有一个_index.md文件，内容如下，根据实际情况进行调整。\n1 2 3 4 --- title: \u0026#34;文章\u0026#34; hidemeta: true --- 模板维护 修改archetypes/default.md内容为：\n1 2 3 4 5 6 7 8 9 --- title: \u0026#34;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} weight: 0 categories: [] tags: [] series: [] draft: true --- 使用hugo new content content/posts/*.md创建文章时，默认使用的就是该模板。\nweight：权重，同一目录下，值越小（不含0）排名越靠前，类似置顶功能。\ncategories、tags、series：分别对应分类、标签、系列，可填0~n个词或短语，注意要用\u0026quot;\u0026quot;括起来，并用,进行分隔。\ndraft：草稿，为true时，运行hugo server加-D可看到，不加看不到，hugo编译时也看不到；为false时都能看到，文章确定没问题后记得修改为false，否则最终是看不到的。\n以上配置完之后，就可以正式开启写博文之路了。至于一些更加个性化的配置，详见PaperMod wiki或搜索引擎。\n","permalink":"https://afrusrsc.github.io/posts/blog/hugo02/","summary":"空空如也的页面，需要好好配置一番才能丰富多彩。\n配置config.yml 隐性配置 在上一篇config.yml的基础上先加入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 copyright: \u0026#34;© 20xx [xxx](https://github.com/xxx)\u0026#34; # 版权说明 paginate: 5 # 每页文章数 enableInlineShortcodes: true # 是否使用短码 enableRobotsTXT: true # 是否允许被搜索引擎收录 buildDrafts: false buildFuture: false buildExpired: false enableEmoji: true # 是否使用emoji表情 pygmentsUseClasses: true mainsections: [\u0026#34;posts\u0026#34;, \u0026#34;papermod\u0026#34;] minify: disableXML: true outputs: home: - HTML - RSS - JSON markup: goldmark: renderer: unsafe: true highlight: noClasses: false codeFences: true guessSyntax: true lineNos: true services: instagram: disableInlineCSS: true twitter: disableInlineCSS: true params: env: production description: \u0026#34;xxx\u0026#39;s blog\u0026#34; author: xxx # 作者 defaultTheme: auto ShowShareButtons: false # 是否显示分享按钮 ShowReadingTime: true # 是否显示阅读时间 displayFullLangName: true ShowPostNavLinks: true # 是否显示上一页下一页 ShowBreadCrumbs: true ShowCodeCopyButtons: true # 是否在代码上显示复制按钮 ShowRssButtonInSectionTermList: false ShowAllPagesInArchive: true ShowPageNums: true # 是否显示页数 ShowToc: false # 是否显示目录 DateFormat: \u0026#34;2006-01-02 15:04:05\u0026#34; # 时间格式 socialIcons: - name: github title: View Source on Github url: \u0026#34;https://github.","title":"用Hugo搭建个人博客——配置"},{"content":"方案制定 使用hugo（笔者使用的是v0.126.1）进行构建\n使用PaperMod主题，前言提到的基本需求都能满足\n因为hugo是命令行工具，所以使用Linux系统或Win10+的wsl比较方便\n使用Github Pages，服务器和域名问题就一并解决了，不过代价就是访问速度一言难尽。\n使用两个仓库，一个公开仓库用于部署页面，一个私有仓库用于管理源码（内容）\n工具准备 安装Git 用于源码（内容、配置）管理，也用于向Githug仓库进行推送。Git的安装、配置请自行解决。\n安装hugo 打开hugo的下载地址（自行解决科学上网），注意正确选择对应自己操作系统和架构的版本。由于使用的是PaperMod主题，基础版就够了。当然，下载扩展版也没问题，只是听说好像需要go环境，没有验证过。\n下载之后解压，只需要一个可执行的hugo即可。\n1 tar -xzf hugo_0.126.1_linux-amd64.tar.gz # 适用于linux系统amd64架构的不带扩展的0.126.1版hugo 为了方便使用，可以把hugo放到一个已有的默认搜索路径中，也可以把hugo所在的路径加入环境变量。\n在Linux环境下，运行hugo completion -h查看如何为hugo添加自动完成功能。\n仓库准备 Github 无Github账号的，自行申请一个。\n目标仓库 目标仓库即将来用于部署页面的仓库，新建名为xxx.github.io的仓库（xxx为用户名），仓库更新后会自动部署，直接访问https://xxx.github.io即可。如果想部署第二或更多的仓库，那就只能新建普通仓库，手动开启Github Pages，通过https://xxx.github.io/yyy（xxx为用户名，yyy为仓库名）访问。\n源码仓库 源码仓库即将来用于管理*.md的仓库，新建一个普通私有仓库即可，例如名为blog-src。\n本地仓库 克隆源码仓库 1 2 git clone https://github.com/xxx/blog-src.git cd blog-src # 切到仓库根目录，无特殊说明时，所有命令都在该目录下执行 添加.gitignore 1 2 echo \u0026#39;public/\u0026#39; \u0026gt; .gitignore echo \u0026#39;.hugo_build.lock\u0026#39; \u0026gt;\u0026gt; .gitignore 克隆目标仓库 1 2 mkdir public git clone git@github.com:xxx/xxx.github.io.git public 添加部署脚本 新建文本文件pushpage.sh，并赋予执行权限，然后写入以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/bash mpath=$(dirname $(readlink -f $0)) spath=$mpath\u0026#39;/public\u0026#39; cd $spath # 清空除git版本库外的所有文件 ls | grep -v .git | xargs rm -rf ./* # 生成页面 cd $mpath \u0026amp;\u0026amp; hugo # 强制提交 cd $spath \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit --amend -m \u0026#39;pages\u0026#39; \u0026amp;\u0026amp; git push -f origin master 以后在本地测试没问题后，可直接运行该脚本，实现一键部署。\n项目准备 初始化项目 1 hugo new site . # 注意带上【.】，表示当前目录 生成的默认内容如下：\n1 2 3 4 5 6 7 8 9 10 archetypes └── default.md assets content data hugo.toml i18n layouts static themes 添加主题仓库 1 git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/hugo-PaperMod 将hugo.toml重命名为config.yml，并改为以下内容 1 2 3 baseURL: \u0026#34;https://xxx.github.io\u0026#34; title: \u0026#34;My blog\u0026#34; theme: [hugo-PaperMod] 修改archetypes下的default.md，改为以下内容 1 2 3 4 5 --- title: \u0026#34;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true --- 至此，准备工作就差不多了，运行hugo server -D，然后就可以访问http://localhost:1313/查看效果了，当然，看到的页面几乎没什么内容，因为还没添加内容，更没进行更细致的配置。\n","permalink":"https://afrusrsc.github.io/posts/blog/hugo01/","summary":"方案制定 使用hugo（笔者使用的是v0.126.1）进行构建\n使用PaperMod主题，前言提到的基本需求都能满足\n因为hugo是命令行工具，所以使用Linux系统或Win10+的wsl比较方便\n使用Github Pages，服务器和域名问题就一并解决了，不过代价就是访问速度一言难尽。\n使用两个仓库，一个公开仓库用于部署页面，一个私有仓库用于管理源码（内容）\n工具准备 安装Git 用于源码（内容、配置）管理，也用于向Githug仓库进行推送。Git的安装、配置请自行解决。\n安装hugo 打开hugo的下载地址（自行解决科学上网），注意正确选择对应自己操作系统和架构的版本。由于使用的是PaperMod主题，基础版就够了。当然，下载扩展版也没问题，只是听说好像需要go环境，没有验证过。\n下载之后解压，只需要一个可执行的hugo即可。\n1 tar -xzf hugo_0.126.1_linux-amd64.tar.gz # 适用于linux系统amd64架构的不带扩展的0.126.1版hugo 为了方便使用，可以把hugo放到一个已有的默认搜索路径中，也可以把hugo所在的路径加入环境变量。\n在Linux环境下，运行hugo completion -h查看如何为hugo添加自动完成功能。\n仓库准备 Github 无Github账号的，自行申请一个。\n目标仓库 目标仓库即将来用于部署页面的仓库，新建名为xxx.github.io的仓库（xxx为用户名），仓库更新后会自动部署，直接访问https://xxx.github.io即可。如果想部署第二或更多的仓库，那就只能新建普通仓库，手动开启Github Pages，通过https://xxx.github.io/yyy（xxx为用户名，yyy为仓库名）访问。\n源码仓库 源码仓库即将来用于管理*.md的仓库，新建一个普通私有仓库即可，例如名为blog-src。\n本地仓库 克隆源码仓库 1 2 git clone https://github.com/xxx/blog-src.git cd blog-src # 切到仓库根目录，无特殊说明时，所有命令都在该目录下执行 添加.gitignore 1 2 echo \u0026#39;public/\u0026#39; \u0026gt; .gitignore echo \u0026#39;.hugo_build.lock\u0026#39; \u0026gt;\u0026gt; .gitignore 克隆目标仓库 1 2 mkdir public git clone git@github.com:xxx/xxx.github.io.git public 添加部署脚本 新建文本文件pushpage.sh，并赋予执行权限，然后写入以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!","title":"用Hugo搭建个人博客——准备"},{"content":"全是废话 注意：本篇全是废话，无任何技术性内容！\n忆往昔 想当年，能有个属于自己的博客或网站，那是件很有面儿的事，可惜那时的自己是个纯纯的小白，只有眼馋的份儿。\n后来，在某些门户网站提供的博客功能里写那么些仨瓜俩枣的，也算是过把小瘾。\n再后来，自己写的东西慢慢开始有了些含金量，碰巧那阵子的门户网站也陆陆续续开始关停博客功能，无奈也就随之辗转迁移，几番下来，丢了不少东西。\n想过自己建站，不过那些前端、后端、域名之类的，搞得头大，再加上囊中羞涩，还是罢了。\n期间，了解到Markdown，简单明了，一下子就喜欢上了这种格式，随后也逐渐迁移到了几个相对靠谱并且支持Markdown的平台上。\n慢慢的，发现这些平台，不是河蟹就是死板，写起文章来束手束脚，难受得不能行。\n无意间发现，Github或Gitee对Markdown的渲染还是不错的，直接在git里写Markdown，效果有了，还不拘束，而且东西还掌握在自己手里，完美！\n看今朝 如今，随着写的东西越来越多，GitXX+Markdown的不足也慢慢暴露出来：刀耕火种不够灵活。于是，建站的想法又冒出来了，兜兜转转又盯上hugo+Githug Pages了。\n其实，当初选择GitXX+Markdown方案前，已经考虑过hugo+GitXX Pages了，不过当时没有选到合适的主题，再加上Github感人的访问速度和Gitee感人的存储空间，以及没有合适的图床，一直都是备用方案。\n如今再次盯上hugo+Githug Pages，仔细试了几个主题，最后发现如今的PaperMod还是挺符合个人需求的。\n简洁、轻量\n支持暗黑模式\n中文支持比较好\n移动端适配良好\n缺点嘛，自然也是有的，不过目前还能接受。\n望未来 暂时是决定用hugo+Githug Pages方案的，未来会不会再变，等未来再说吧。\n至于以前写的文章，看情况吧，可能会部分迁移过来，也可能全部备份完就罢了，写文章嘛，是个舒爽的活，不能给自己设限。\n","permalink":"https://afrusrsc.github.io/posts/blog/hugo00/","summary":"全是废话 注意：本篇全是废话，无任何技术性内容！\n忆往昔 想当年，能有个属于自己的博客或网站，那是件很有面儿的事，可惜那时的自己是个纯纯的小白，只有眼馋的份儿。\n后来，在某些门户网站提供的博客功能里写那么些仨瓜俩枣的，也算是过把小瘾。\n再后来，自己写的东西慢慢开始有了些含金量，碰巧那阵子的门户网站也陆陆续续开始关停博客功能，无奈也就随之辗转迁移，几番下来，丢了不少东西。\n想过自己建站，不过那些前端、后端、域名之类的，搞得头大，再加上囊中羞涩，还是罢了。\n期间，了解到Markdown，简单明了，一下子就喜欢上了这种格式，随后也逐渐迁移到了几个相对靠谱并且支持Markdown的平台上。\n慢慢的，发现这些平台，不是河蟹就是死板，写起文章来束手束脚，难受得不能行。\n无意间发现，Github或Gitee对Markdown的渲染还是不错的，直接在git里写Markdown，效果有了，还不拘束，而且东西还掌握在自己手里，完美！\n看今朝 如今，随着写的东西越来越多，GitXX+Markdown的不足也慢慢暴露出来：刀耕火种不够灵活。于是，建站的想法又冒出来了，兜兜转转又盯上hugo+Githug Pages了。\n其实，当初选择GitXX+Markdown方案前，已经考虑过hugo+GitXX Pages了，不过当时没有选到合适的主题，再加上Github感人的访问速度和Gitee感人的存储空间，以及没有合适的图床，一直都是备用方案。\n如今再次盯上hugo+Githug Pages，仔细试了几个主题，最后发现如今的PaperMod还是挺符合个人需求的。\n简洁、轻量\n支持暗黑模式\n中文支持比较好\n移动端适配良好\n缺点嘛，自然也是有的，不过目前还能接受。\n望未来 暂时是决定用hugo+Githug Pages方案的，未来会不会再变，等未来再说吧。\n至于以前写的文章，看情况吧，可能会部分迁移过来，也可能全部备份完就罢了，写文章嘛，是个舒爽的活，不能给自己设限。","title":"用Hugo搭建个人博客——前言"},{"content":" 从其它平台迁移而来\n环境 项目 值 操作系统 Debian 12 桌面环境 xfce 4 输入法 fcitx 5 问题 在Lazarus的代码编辑器中，快速录入时会出现连击现象\n在Lazarus的代码编辑器中无法输入中文\n解决 问题1 安装fcitx5-frontend-gtk2即可，详见fcitx5 issues #1006\n问题2 参照秋·风大佬中文输入法的解决方案。如果使用的是搜狗输入法的话，参照秋·风大佬搜狗输入法输入词组的解决方案。\n补充1 使用fpcupdeluxe安装Lazarus，源码修改后使用git diff生成补丁文件，后期升级Lazarus后若输入法不能用可直接应用补丁，避免重复修改。\n生成补丁文件 1 2 cd lazarus git diff \u0026gt; ~/linux_gtk2_ime.diff 应用补丁 如下图进行设置后，更新FPC+Lazarus即可。\n以下是Lazarus 3.4的补丁文件内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 diff --git a/components/synedit/lazsyngtk2imm.pas b/components/synedit/lazsyngtk2imm.pas index 25b48fa0..02337318 100644 --- a/components/synedit/lazsyngtk2imm.pas +++ b/components/synedit/lazsyngtk2imm.pas @@ -2,6 +2,10 @@ unit LazSynGtk2IMM; {$mode objfpc}{$H+} +{$IFDEF LCLGTK2} + {$DEFINE WITH_GTK2_IM} +{$ENDIF} + interface uses diff --git a/components/synedit/synedit.inc b/components/synedit/synedit.inc index 5aa6930c..31edc908 100644 --- a/components/synedit/synedit.inc +++ b/components/synedit/synedit.inc @@ -19,6 +19,10 @@ {$MODE OBJFPC} {$ENDIF} +{$IFDEF LCLGTK2} + {$DEFINE GTK2IME} +{$ENDIF} + {$DEFINE SYNEDIT_INCLUDE} {$IFdef MSWindows} diff --git a/lcl/interfaces/gtk2/gtk2globals.pp b/lcl/interfaces/gtk2/gtk2globals.pp index 5821b5d6..396084a8 100644 --- a/lcl/interfaces/gtk2/gtk2globals.pp +++ b/lcl/interfaces/gtk2/gtk2globals.pp @@ -10,6 +10,10 @@ unit Gtk2Globals; {$mode objfpc}{$H+} +{$IFDEF UNIX} + {$DEFINE WITH_GTK2_IM} +{$ENDIF} + interface uses diff --git a/lcl/interfaces/gtk2/gtk2proc.inc b/lcl/interfaces/gtk2/gtk2proc.inc index 7c5fc7bc..a31d4dec 100644 --- a/lcl/interfaces/gtk2/gtk2proc.inc +++ b/lcl/interfaces/gtk2/gtk2proc.inc @@ -19,6 +19,10 @@ {off $DEFINE VerboseAccelerator} {off $DEFINE VerboseUpdateSysColorMap} +{$IFDEF UNIX} + {$DEFINE WITH_GTK2_IM} +{$ENDIF} + {$IFOPT C-} // Uncomment for local trace //{$C+} diff --git a/lcl/interfaces/gtk2/gtk2widgetset.inc b/lcl/interfaces/gtk2/gtk2widgetset.inc index c66dfcdb..6f9a93d0 100644 --- a/lcl/interfaces/gtk2/gtk2widgetset.inc +++ b/lcl/interfaces/gtk2/gtk2widgetset.inc @@ -17,6 +17,10 @@ // {$DEFINE ASSERT_IS_ON} {$ENDIF} +{$IFDEF UNIX} + {$DEFINE WITH_GTK2_IM} +{$ENDIF} + {$IFNDEF USE_GTK_MAIN_OLD_ITERATION} var Gtk2MPF: TGPollFunc; 补充2 在Q群交流中，有群友提供了另一种解决方案，无需修改源码，且不限于使用fpcupdeluxe安装。\n测试后发现，该方案有相当大的限制：仅限于Linux gtk2的本机环境编译，且不适用于交叉编译。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_debian_ime/","summary":"从其它平台迁移而来\n环境 项目 值 操作系统 Debian 12 桌面环境 xfce 4 输入法 fcitx 5 问题 在Lazarus的代码编辑器中，快速录入时会出现连击现象\n在Lazarus的代码编辑器中无法输入中文\n解决 问题1 安装fcitx5-frontend-gtk2即可，详见fcitx5 issues #1006\n问题2 参照秋·风大佬中文输入法的解决方案。如果使用的是搜狗输入法的话，参照秋·风大佬搜狗输入法输入词组的解决方案。\n补充1 使用fpcupdeluxe安装Lazarus，源码修改后使用git diff生成补丁文件，后期升级Lazarus后若输入法不能用可直接应用补丁，避免重复修改。\n生成补丁文件 1 2 cd lazarus git diff \u0026gt; ~/linux_gtk2_ime.diff 应用补丁 如下图进行设置后，更新FPC+Lazarus即可。\n以下是Lazarus 3.4的补丁文件内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 diff --git a/components/synedit/lazsyngtk2imm.","title":"解决Debian上Lazarus输入法问题"},{"content":" 从其它平台迁移而来\n安装ntpdate 1 sudo apt install ntpdate 手动校时 1 sudo ntpdate -u ntp.ntsc.ac.cn -u：可越过防火墙与主机同步\nntp.ntsc.ac.cn：国家授时中心的服务地址\n同步硬件时间 1 sudo hwclock -w 定时校时 校时脚本 1 vi ntp.sh 写入以下内容：\n1 2 3 #!/bin/bash /usr/sbin/ntpdate -u ntp.ntsc.ac.cn; /usr/sbin/hwclock -w; 授予执行权限\n1 chmod +x ntp.sh 创建定时任务 1 sudo crontab -e 加入以下内容：\n1 */30 * * * * /root/ntp.sh # 表示每30分钟执行一次 ","permalink":"https://afrusrsc.github.io/posts/os/debian_ntp/","summary":" 从其它平台迁移而来\n安装ntpdate 1 sudo apt install ntpdate 手动校时 1 sudo ntpdate -u ntp.ntsc.ac.cn -u：可越过防火墙与主机同步\nntp.ntsc.ac.cn：国家授时中心的服务地址\n同步硬件时间 1 sudo hwclock -w 定时校时 校时脚本 1 vi ntp.sh 写入以下内容：\n1 2 3 #!/bin/bash /usr/sbin/ntpdate -u ntp.ntsc.ac.cn; /usr/sbin/hwclock -w; 授予执行权限\n1 chmod +x ntp.sh 创建定时任务 1 sudo crontab -e 加入以下内容：\n1 */30 * * * * /root/ntp.sh # 表示每30分钟执行一次 ","title":"配置校时服务"},{"content":" 从其它平台迁移而来\n用户 取消密码生命周期 1 ALTER profile default limit password_life_time unlimited; 修改用户密码 1 ALTER USER xxx IDENTIFIED BY xxx; 文件夹 查看文件夹 1 SELECT * FROM All_Directories; 表空间 查询表空间 1 SELECT * FROM Dba_Data_Files; 创建表空间 1 2 3 4 5 6 7 CREATE TABLESPACE 表空间名 DATAFILE \u0026#39;文件名\u0026#39; SIZE 初始大小 --单位k或m AUTOEXTEND ON --自动扩展 NEXT 扩展大小 MAXSIZE 最大大小 ; 表空间追加数据文件 1 2 3 4 5 6 7 ALTER TABLESPACE 表空间名 ADD DATAFILE \u0026#39;文件名\u0026#39; SIZE 初始大小 --单位k或m AUTOEXTEND ON --自动扩展 NEXT 扩展大小 MAXSIZE 最大大小 ; 删除表空间 1 2 DROP TABLESPACE 表空间名; --仅删除表空间 DROP TABLESPACE 表空间名 INCLUDING CONTENTS AND DATAFILES; --删除表空间及数据文件 导入数据 1 2 3 4 5 6 7 8 --原模式(用户名)导入 IMPDP 登录名/密码 DIRECTORY=泵导文件夹 DUMPFILE=泵导文件 LOGFILE=日志文件 SCHEMAS=模式名 --指定模式(用户名)导入 IMPDP 登录名/密码 DIRECTORY=泵导文件夹 DUMPFILE=泵导文件 LOGFILE=日志文件 SCHEMAS=原模式名:新模式名 --多模式(用户名)导入 IMPDP 登录名/密码 DIRECTORY=泵导文件夹 DUMPFILE=泵导文件 LOGFILE=日志文件 SCHEMAS=模式名1,模式名2 导出数据 1 EXPDP 登录名/密码@SID名 DIRECTORY=泵导文件夹 DUMPFILE=泵导文件 SCHEMAS=模式名 ","permalink":"https://afrusrsc.github.io/posts/db/oracle_base/","summary":" 从其它平台迁移而来\n用户 取消密码生命周期 1 ALTER profile default limit password_life_time unlimited; 修改用户密码 1 ALTER USER xxx IDENTIFIED BY xxx; 文件夹 查看文件夹 1 SELECT * FROM All_Directories; 表空间 查询表空间 1 SELECT * FROM Dba_Data_Files; 创建表空间 1 2 3 4 5 6 7 CREATE TABLESPACE 表空间名 DATAFILE \u0026#39;文件名\u0026#39; SIZE 初始大小 --单位k或m AUTOEXTEND ON --自动扩展 NEXT 扩展大小 MAXSIZE 最大大小 ; 表空间追加数据文件 1 2 3 4 5 6 7 ALTER TABLESPACE 表空间名 ADD DATAFILE \u0026#39;文件名\u0026#39; SIZE 初始大小 --单位k或m AUTOEXTEND ON --自动扩展 NEXT 扩展大小 MAXSIZE 最大大小 ; 删除表空间 1 2 DROP TABLESPACE 表空间名; --仅删除表空间 DROP TABLESPACE 表空间名 INCLUDING CONTENTS AND DATAFILES; --删除表空间及数据文件 导入数据 1 2 3 4 5 6 7 8 --原模式(用户名)导入 IMPDP 登录名/密码 DIRECTORY=泵导文件夹 DUMPFILE=泵导文件 LOGFILE=日志文件 SCHEMAS=模式名 --指定模式(用户名)导入 IMPDP 登录名/密码 DIRECTORY=泵导文件夹 DUMPFILE=泵导文件 LOGFILE=日志文件 SCHEMAS=原模式名:新模式名 --多模式(用户名)导入 IMPDP 登录名/密码 DIRECTORY=泵导文件夹 DUMPFILE=泵导文件 LOGFILE=日志文件 SCHEMAS=模式名1,模式名2 导出数据 1 EXPDP 登录名/密码@SID名 DIRECTORY=泵导文件夹 DUMPFILE=泵导文件 SCHEMAS=模式名 ","title":"Oracle基础使用"},{"content":" 从其它平台迁移而来\n安装驱动\n安装蓝牙管理工具blueman\n1 sudo apt install blueman 此时连接蓝牙音响报br-connection-profile-unavailable\n编辑/etc/pulse/default.pa，找到并注释掉load-module module-bluetooth-discover行\n编辑/usr/bin/start-pulseaudio-x11，在如下位置添加/usr/bin/pactl load-module module-bluetooth-discover\n1 2 3 4 5 if [ x\u0026#34;$SESSION_MANAGER\u0026#34; != x ] ; then /usr/bin/pactl load-module module-x11-xsmp \u0026#34;display=$DISPLAY xauthority=$XAUTHORITY session_manager=$SESSION_MANAGER\u0026#34; \u0026gt; /dev/null # 添加下面一行 /usr/bin/pactl load-module module-bluetooth-discover fi 重启 ","permalink":"https://afrusrsc.github.io/posts/os/debian_bluetooth/","summary":" 从其它平台迁移而来\n安装驱动\n安装蓝牙管理工具blueman\n1 sudo apt install blueman 此时连接蓝牙音响报br-connection-profile-unavailable\n编辑/etc/pulse/default.pa，找到并注释掉load-module module-bluetooth-discover行\n编辑/usr/bin/start-pulseaudio-x11，在如下位置添加/usr/bin/pactl load-module module-bluetooth-discover\n1 2 3 4 5 if [ x\u0026#34;$SESSION_MANAGER\u0026#34; != x ] ; then /usr/bin/pactl load-module module-x11-xsmp \u0026#34;display=$DISPLAY xauthority=$XAUTHORITY session_manager=$SESSION_MANAGER\u0026#34; \u0026gt; /dev/null # 添加下面一行 /usr/bin/pactl load-module module-bluetooth-discover fi 重启 ","title":"Debian上使用蓝牙音响"},{"content":" 从其它平台迁移而来\n有时候我们会期望所编写的应用只运行一个实例，比如监听网络端口或串口，用Lazarus有两种不同的实现方案。\nSingleInstanceEnabled属性 SingleInstanceEnabled是TCustomApplication的属性，在初始化之前设置为True即可轻松实现单实例应用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 program project1; {$mode objfpc}{$H+} uses AdvancedSingleInstance, //注意：必须引用该单元！！！ Interfaces, Forms, ...; {$R *.res} begin Application.SingleInstanceEnabled := True; //注意：必须在调用 Initialize 前赋值！！！ Application.Initialize; ... Application.Run; end. 特别注意 必须引用AdvancedSingleInstance单元，且该单元必须在Interfaces单元和Forms单元前\n必须在调用Application.Initialize前赋值\n该方法仅针对同一个可执行文件生效，并非系统全局生效\n互斥对象 利用操作系统的互斥对象可实现系统级的单例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var AppMutex: THandle; begin Application.Initialize; if OpenMutex(MUTEX_ALL_ACCESS, False, PChar(\u0026#39;唯一标识\u0026#39;)) = 0 then begin AppMutex := CreateMutex(nil, False, PChar(\u0026#39;唯一标识\u0026#39;)); ... Application.Run; CloseHandle(AppMutex); end else Application.Terminate; end. 特别注意 唯一标识必须唯一，否则，即使完全不同的应用也只能运行其中一个 ","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_single_instance/","summary":"从其它平台迁移而来\n有时候我们会期望所编写的应用只运行一个实例，比如监听网络端口或串口，用Lazarus有两种不同的实现方案。\nSingleInstanceEnabled属性 SingleInstanceEnabled是TCustomApplication的属性，在初始化之前设置为True即可轻松实现单实例应用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 program project1; {$mode objfpc}{$H+} uses AdvancedSingleInstance, //注意：必须引用该单元！！！ Interfaces, Forms, ...; {$R *.res} begin Application.SingleInstanceEnabled := True; //注意：必须在调用 Initialize 前赋值！！！ Application.Initialize; ... Application.Run; end. 特别注意 必须引用AdvancedSingleInstance单元，且该单元必须在Interfaces单元和Forms单元前\n必须在调用Application.Initialize前赋值\n该方法仅针对同一个可执行文件生效，并非系统全局生效\n互斥对象 利用操作系统的互斥对象可实现系统级的单例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var AppMutex: THandle; begin Application.","title":"让应用以单例运行"},{"content":" 从其它平台迁移而来\n背景 有一台旧笔记本电脑，电池鼓包已拆除，显示器画面乱跳（暂未查出原因，外接显示器正常），闲置已久，计划改为家用服务器使用。\n系统安装及配置 安装系统 冒着闪瞎眼的风险，安装Debian，安装过程尽可能简化。\n注意事项：\n特别注意下网卡是否需要另外下载驱动（本机刚好不需要，忽略）\n安装过程中会提示选择源，但Debian 软件安全更新源并不会采用所选源，所以，安装过程可能会因此变得很漫长\n由于是做服务器用，所以不需要安装桌面环境，本着最小安装原则，什么都不安装（包括标准系统工具，因为很多用不上）\n配置系统 安装ssh服务 由于显示问题，先安装ssh服务，然后远程进行其它配置\n1 2 3 # root登录 apt update apt install openssh-server -y 安装并配置sudo 1 2 apt install sudo -y usermod -aG sudo xxx # xxx为用户名 查看ip，并远程登录 由于显示问题，直接通过路由器查得。\n1 ssh 用户名@ip地址 修改ssh端口 1 sudo vi /etc/ssh/sshd_config 取消Port 22的注释，再添加一行Port xxx\n重启ssh服务\n1 sudo systemctl restart sshd.service 退出ssh并用新端口登录\n1 ssh -p 新端口 用户名@ip地址 登录成功后再注释Port 22，再次重启ssh服务\n修改源 1 sudo vi /etc/apt/sources.list 用#注释掉 deb-src 开头的行，然后把security.debian.org替换为mirrors.ustc.edu.cn，把main non-free-firmware替换为main contrib non-free non-free-firmware。\n1 2 :%s/security.debian.org/mirrors.ustc.edu.cn/g :%s/main non-free-firmware/main contrib non-free non-free-firmware/g 保存配置并更新系统\n1 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y 安装补全工具 1 sudo apt install bash-completion 安装配置防火墙 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 安装 ufw sudo apt install ufw -y # 查看规则状态 sudo ufw status # 设置默认规则 sudo ufw default allow outgoing sudo ufw default deny incoming # 重置规则 sudo ufw reset # 开放ssh端口 sudo ufw allow xxx/tcp # xxx为前面设置的ssh端口 # 启用 sudo ufw enable # 停用 sudo ufw disable 注意：一定要允许ssh端口后再启用！\n设置笔记本合盖不休眠 1 sudo vi /etc/systemd/logind.conf 修改#HandleLidSwitch=suspend为HandleLidSwitch=ignore，或直接添加一行，重启电脑后即可直接合盖运行。\n其它个性化设置 如设置别名等。\n至此，基本系统已配置完成。\n","permalink":"https://afrusrsc.github.io/posts/os/debian_server_install/","summary":"从其它平台迁移而来\n背景 有一台旧笔记本电脑，电池鼓包已拆除，显示器画面乱跳（暂未查出原因，外接显示器正常），闲置已久，计划改为家用服务器使用。\n系统安装及配置 安装系统 冒着闪瞎眼的风险，安装Debian，安装过程尽可能简化。\n注意事项：\n特别注意下网卡是否需要另外下载驱动（本机刚好不需要，忽略）\n安装过程中会提示选择源，但Debian 软件安全更新源并不会采用所选源，所以，安装过程可能会因此变得很漫长\n由于是做服务器用，所以不需要安装桌面环境，本着最小安装原则，什么都不安装（包括标准系统工具，因为很多用不上）\n配置系统 安装ssh服务 由于显示问题，先安装ssh服务，然后远程进行其它配置\n1 2 3 # root登录 apt update apt install openssh-server -y 安装并配置sudo 1 2 apt install sudo -y usermod -aG sudo xxx # xxx为用户名 查看ip，并远程登录 由于显示问题，直接通过路由器查得。\n1 ssh 用户名@ip地址 修改ssh端口 1 sudo vi /etc/ssh/sshd_config 取消Port 22的注释，再添加一行Port xxx\n重启ssh服务\n1 sudo systemctl restart sshd.service 退出ssh并用新端口登录\n1 ssh -p 新端口 用户名@ip地址 登录成功后再注释Port 22，再次重启ssh服务\n修改源 1 sudo vi /etc/apt/sources.","title":"把旧笔记本电脑改为家用服务器"},{"content":" 从其它平台迁移而来\n安装 Debian仓库中已包含PostgreSQL，所以，直接安装即可：\n1 sudo apt install postgresql 若想使用pg官方源，则执行：\n1 2 3 4 sudo sh -c \u0026#39;echo \u0026#34;deb https://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main\u0026#34; \u0026gt; /etc/apt/sources.list.d/pgdg.list\u0026#39; wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - sudo apt-get update sudo apt-get -y install postgresql 配置 重置密码 曾经安装又卸载N多次，都没能像在win上一样正常使用，其实就是安装时默认生成的是随机密码，重置下密码即可使用。\n删除linux系统的postgres用户密码 1 sudo passwd -d postgres 设置linux系统的postgres用户密码 1 sudo -u postgres passwd 登录数据库 1 sudo -u postgres psql 修改数据库的postgres用户密码 1 ALTER USER postgres WITH PASSWORD \u0026#39;xxxxxx\u0026#39;; # 注意带分号 退出psql并重启服务 1 2 \\q # 退出 psql sudo systemctl restart postgresql.service # 可能还会有带版本号的服务，一并重启 局域网访问设置 安装完默认只能本机访问。\n修改pg_hba.conf 1 sudo vi /etc/postgresql/15/main/pg_hba.conf 在# IPv4 local connections:段下面增加类似下面的内容：\n1 host all all 0.0.0.0/0 scram-sha-256 修改postgresql.conf 1 sudo vi /etc/postgresql/15/main/postgresql.conf 将\n1 #listen_addresses = \u0026#39;localhost\u0026#39;\t# what IP address(es) to listen on; 修改为\n1 listen_addresses = \u0026#39;*\u0026#39;\t# what IP address(es) to listen on; 重启服务 ","permalink":"https://afrusrsc.github.io/posts/os/debian_pg_install/","summary":"从其它平台迁移而来\n安装 Debian仓库中已包含PostgreSQL，所以，直接安装即可：\n1 sudo apt install postgresql 若想使用pg官方源，则执行：\n1 2 3 4 sudo sh -c \u0026#39;echo \u0026#34;deb https://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main\u0026#34; \u0026gt; /etc/apt/sources.list.d/pgdg.list\u0026#39; wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - sudo apt-get update sudo apt-get -y install postgresql 配置 重置密码 曾经安装又卸载N多次，都没能像在win上一样正常使用，其实就是安装时默认生成的是随机密码，重置下密码即可使用。\n删除linux系统的postgres用户密码 1 sudo passwd -d postgres 设置linux系统的postgres用户密码 1 sudo -u postgres passwd 登录数据库 1 sudo -u postgres psql 修改数据库的postgres用户密码 1 ALTER USER postgres WITH PASSWORD \u0026#39;xxxxxx\u0026#39;; # 注意带分号 退出psql并重启服务 1 2 \\q # 退出 psql sudo systemctl restart postgresql.","title":"Debian上安装PostgreSQL"},{"content":" 从其它平台迁移而来\n起因 基本信息 平台：windows\nIDE：Lazarus 2.2.6\njson包：FPC自带的fpjson\n背景 最近在搞一个小工具，数据文件采用的是json格式，其中一个节点存放的是一组文件的基本信息的清单，这个节点自然就是个json数组，元素就是每个文件基本信息的json对象。界面展示用的是经典的DBGrid + DataSource + DataSet方案，所以会把json数组转为DataSet。\n操作过程中会比对磁盘上的文件，该添的添，该删的的删，该改的改，该标记的标记。一番操作下来，顺序自然是乱的，虽然可以操作DataSet或者换用带排序功能的DBGridEh达到排序的目的，但直接看json数据的话，依然是乱序的。因此，期望直接对json数组进行排序。\n解决过程 习惯先看源码，如果没有原生解决方案了，或者原生解决方案太别扭了，才会选择第三方解决方案或自己造轮子。\n一看源码 1 2 3 4 TJSONArray = class(TJSONData) public ... Procedure Sort(Compare: TListSortCompare); TJSONArray已经提供了排序方法，不过这个参数是什么东西？\n1 TListSortCompare = function (Item1, Item2: Pointer): Integer; 嗯，是个函数声明，也就是说具体的算法实现要自己写，可以先找找看有默认的实现没。结果是：没有！那就自己写吧。\n看声明，这个函数是要比较两个指针指向的东西，并返回一个整数。嗯，看上去很简单，不过：\n到底是怎么实现排序的？\n参数是指针，指向的又是什么东西？\n返回一个什么样的整数才能实现排序呢？\n没懂！！！\n还是接着看源码吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 procedure TJSONArray.Sort(Compare: TListSortCompare); begin FList.Sort(Compare); end; Procedure TFPObjectList.Sort(Compare: TListSortCompare); begin FList.Sort(Compare); end; procedure TFPList.Sort(Compare: TListSortCompare); begin if Not Assigned(FList) or (FCount \u0026lt; 2) then exit; QuickSort(Flist, 0, FCount-1, Compare); end; Procedure QuickSort(FList: PPointerList; L, R : Longint; Compare: TListSortCompare); var I, J : Longint; P, Q : Pointer; begin repeat I := L; J := R; P := FList^[ (L + R) div 2 ]; repeat while Compare(P, FList^[i]) \u0026gt; 0 do I := I + 1; while Compare(P, FList^[J]) \u0026lt; 0 do J := J - 1; If I \u0026lt;= J then begin Q := FList^[I]; Flist^[I] := FList^[J]; FList^[J] := Q; I := I + 1; J := J - 1; end; until I \u0026gt; J; // sort the smaller range recursively // sort the bigger range via the loop // Reasons: memory usage is O(log(n)) instead of O(n) and loop is faster than recursion if J - L \u0026lt; R - I then begin if L \u0026lt; J then QuickSort(FList, L, J, Compare); L := I; end else begin if I \u0026lt; R then QuickSort(FList, I, R, Compare); R := J; end; until L \u0026gt;= R; end; 嗯，原来调用了一个快排算法，算法中用到的比较两个元素的函数就是需要实现的函数。\n再看源码 印象中，TStringList好像可以直接排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 procedure TStringList.Sort; begin CustomSort(@StringListAnsiCompare); end; procedure TStringList.CustomSort(CompareFn: TStringListSortCompare); begin If (FCount\u0026gt;1) and (FForceSort or (FSortStyle\u0026lt;\u0026gt;sslAuto)) then begin Changing; QuickSort(0,FCount-1, CompareFn); Changed; end; end; 嗯，同样是调用了一个快排算法，而且比较函数也是实现了的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function StringListAnsiCompare(List: TStringList; Index1, Index: Integer): Integer; begin Result := List.DoCompareText(List.FList^[Index1].FString, List.FList^[Index].FString); end; function TStringList.DoCompareText(const s1, s2: string): PtrInt; begin if FCaseSensitive then begin if UseLocale then result:=AnsiCompareStr(s1,s2) else result:=CompareStr(s1,s2); end else begin if UseLocale then result:=AnsiCompareText(s1,s2) else result:=CompareText(s1,s2); end; end; 原来如此！比较函数只要实现类似CompareText或CompareStr的效果就能被快排算法调用从而实现排序功能。\n自己实现 由于json数组里的元素全部都是相同结构的json对象，那就简单粗暴点：\n1 2 3 4 5 6 7 8 function DefaltJsonCompare(Item1, Item2: Pointer): integer; var s1, s2: string; begin s1 := TJSONObject(Item1).Get(\u0026#39;key\u0026#39;, \u0026#39;\u0026#39;); s2 := TJSONObject(Item2).Get(\u0026#39;key\u0026#39;, \u0026#39;\u0026#39;); Result := CompareText(s1, s2); end; 测试一下，嗯，确实是期望的效果，完美收工！\n总结 继承于TFPList的类，本质上都已实现了快排算法，也就是可以直接排序，所需要的仅仅是提供一个类似CompareText的比较函数的实现即可\n基于TFPList组合并且以TFPList为主的类，也可以像TStringList一样封装一个方法实现排序，或者提供一个Helper实现排序\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_json_order/","summary":"从其它平台迁移而来\n起因 基本信息 平台：windows\nIDE：Lazarus 2.2.6\njson包：FPC自带的fpjson\n背景 最近在搞一个小工具，数据文件采用的是json格式，其中一个节点存放的是一组文件的基本信息的清单，这个节点自然就是个json数组，元素就是每个文件基本信息的json对象。界面展示用的是经典的DBGrid + DataSource + DataSet方案，所以会把json数组转为DataSet。\n操作过程中会比对磁盘上的文件，该添的添，该删的的删，该改的改，该标记的标记。一番操作下来，顺序自然是乱的，虽然可以操作DataSet或者换用带排序功能的DBGridEh达到排序的目的，但直接看json数据的话，依然是乱序的。因此，期望直接对json数组进行排序。\n解决过程 习惯先看源码，如果没有原生解决方案了，或者原生解决方案太别扭了，才会选择第三方解决方案或自己造轮子。\n一看源码 1 2 3 4 TJSONArray = class(TJSONData) public ... Procedure Sort(Compare: TListSortCompare); TJSONArray已经提供了排序方法，不过这个参数是什么东西？\n1 TListSortCompare = function (Item1, Item2: Pointer): Integer; 嗯，是个函数声明，也就是说具体的算法实现要自己写，可以先找找看有默认的实现没。结果是：没有！那就自己写吧。\n看声明，这个函数是要比较两个指针指向的东西，并返回一个整数。嗯，看上去很简单，不过：\n到底是怎么实现排序的？\n参数是指针，指向的又是什么东西？\n返回一个什么样的整数才能实现排序呢？\n没懂！！！\n还是接着看源码吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 procedure TJSONArray.","title":"给json数组中的元素排序"},{"content":" 从其它平台迁移而来\nLinux发行版多如牛毛，多年来的浅尝辄止，最终还是觉得Debian最合心意。\n有wsl、虚拟机、物理机三种方式：其中前两种适合初期学习用，或者需要win/linux混合用的情形，同样也都需要开启硬件虚拟化；后一种适合实践演练或双系统用，当然也适用于纯linux用户使用。\nwsl wsl有wsl1和wsl2之分，具体差异参考官方文档。当然，也可直接参考其安装步骤。\n准备工作 win10/win11操作系统，启动自动更新并更新到最新补丁\n下载Linux内核更新包\n下载发行版Debian（注：离线包安装可自主控制安装路径，方便管理）\n安装 开启硬件虚拟化\n开启适用于Linux的Windows子系统\n安装Linux内核更新包\n重启，手动进行windows更新\n在命令提示符中执行wsl --set-default-version 2设置默认版本\n解压下载的发行版到待安装的路径（注：*.AppxBundle是包的集合，*.appx是包，本质上都是*.zip包）\n进入路径中，运行debian.exe\n根据提示输入用户名和密码\n配置 更换源\n更新系统sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y\n安装补全工具sudo apt install bash-completion\n进行其它个性化配置\n虚拟机 准备工作 开启硬件虚拟化\n安装虚拟机软件vbox\n下载iso镜像（选择网络安装镜像即可）\n安装 创建虚拟机\n启动虚拟机，选择下载的iso启动\n选择Install\n选择语言（但凡有一丁点中文需求，都建议选择简体中文）\n设置主机名\n设置root密码，创建用户并设置密码\n分区（新手可使用整个磁盘并将所有文件放在同一个分区）\n选择源\n选择桌面环境及其它软件\n选择GRUB安装位置（启用UEFI的情况不需要）\n配置 安装有桌面环境的直接在GUI下配置即可，以下为无桌面环境的配置：\n以root用户登录\n更新系统apt update \u0026amp;\u0026amp; apt upgrade -y\n安装工具apt install bash-completion sudo\n设置用户sudo权限usermod -aG sudo xxx\n退出登录\n以xxx用户登录\n修改语言配置，解决终端中文显示为方块sudo dpkg-reconfigure locales-\u0026gt;选择en_US.UTF-8\n进行其它个性化配置\n物理机 准备工作 安装规划，如双系统、分区方案等\n了解硬件详细信息，并下载对应驱动（尤其是网卡、显卡）到U盘2\n下载iso并制作启动光盘或U盘1\n安装 安装大致与虚拟机安装一致，根据提示插入U盘2安装驱动（主要是网卡）。\n","permalink":"https://afrusrsc.github.io/posts/os/debian_install/","summary":"从其它平台迁移而来\nLinux发行版多如牛毛，多年来的浅尝辄止，最终还是觉得Debian最合心意。\n有wsl、虚拟机、物理机三种方式：其中前两种适合初期学习用，或者需要win/linux混合用的情形，同样也都需要开启硬件虚拟化；后一种适合实践演练或双系统用，当然也适用于纯linux用户使用。\nwsl wsl有wsl1和wsl2之分，具体差异参考官方文档。当然，也可直接参考其安装步骤。\n准备工作 win10/win11操作系统，启动自动更新并更新到最新补丁\n下载Linux内核更新包\n下载发行版Debian（注：离线包安装可自主控制安装路径，方便管理）\n安装 开启硬件虚拟化\n开启适用于Linux的Windows子系统\n安装Linux内核更新包\n重启，手动进行windows更新\n在命令提示符中执行wsl --set-default-version 2设置默认版本\n解压下载的发行版到待安装的路径（注：*.AppxBundle是包的集合，*.appx是包，本质上都是*.zip包）\n进入路径中，运行debian.exe\n根据提示输入用户名和密码\n配置 更换源\n更新系统sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y\n安装补全工具sudo apt install bash-completion\n进行其它个性化配置\n虚拟机 准备工作 开启硬件虚拟化\n安装虚拟机软件vbox\n下载iso镜像（选择网络安装镜像即可）\n安装 创建虚拟机\n启动虚拟机，选择下载的iso启动\n选择Install\n选择语言（但凡有一丁点中文需求，都建议选择简体中文）\n设置主机名\n设置root密码，创建用户并设置密码\n分区（新手可使用整个磁盘并将所有文件放在同一个分区）\n选择源\n选择桌面环境及其它软件\n选择GRUB安装位置（启用UEFI的情况不需要）\n配置 安装有桌面环境的直接在GUI下配置即可，以下为无桌面环境的配置：\n以root用户登录\n更新系统apt update \u0026amp;\u0026amp; apt upgrade -y\n安装工具apt install bash-completion sudo\n设置用户sudo权限usermod -aG sudo xxx\n退出登录","title":"安装Debian"},{"content":" 从其它平台迁移而来\n通常情况下，类型和记录是没有方法的，只有类有方法，但是可以通过给类型和记录添加助手来达到类似于类的方法的功能，当然，也可以给类添加助手。\n语法 1 2 3 HelperName = class|record|type helper[(OptionalBaseHelper)] for TypeName [properties, procedures, functions, constructors, consts, vars] end [hint modifiers]; 类助手 FPC 2.6+版本可用，ObjFPC模式下无需特别设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //定义 TObjectHelper = class helper for TObject function SomeFunc: string; end; //实现 function TObjectHelper.SomeFunc: string; begin Result := \u0026#39;类名:\u0026#39; + Self.ClassName; end; //使用 var o: TObject; begin Writeln(o.SomeFunc); end. 一般情况下，给类添加方法可直接在类中添加，但这样添加的方法会直接在所有后代类中显示，如果只是想在特定的范围内添加方法，就可以使用类助手。\n记录助手 FPC 2.6+版本可用，ObjFPC模式下需打开ADVANCEDRECORDS编译开关，Delphi模式无需特别设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 {$mode objfpc}{$H+} {$MODESWITCH ADVANCEDRECORDS} //打开编译开关 //记录定义 TTest = record x: integer; end; //记录助手定义 TTestHelper = record helper for TTest procedure SomeMethod; end; //使用 var t: TTest; begin t.SomeMethod; end; 也可以像类一样直接定义方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 {$mode objfpc}{$H+} {$MODESWITCH ADVANCEDRECORDS} //打开编译开关 //直接定义 TTest = record x: integer; procedure SomeMethod; end; //使用 var t: TTest; begin t.SomeMethod; end; 记录助手可以把与记录相关的方法/函数集中管理，同时也可避开方法重名的问题，一般用在对记录进行构造、清理、转换/变换等场景。\n类型助手 FPC 3.0+版本可用，所有模式下均需打开TYPEHELPERS编译开关。\n1 2 3 4 5 6 7 8 9 {$mode objfpc}{$H+} {$MODESWITCH TYPEHELPERS} //打开编译开关 //自定义类型 type TIntArray = array of integer; //定义助手 HIntArray = type helper for TIntArray procedure Clear; end; 类型助手可以把与类型（通常是自定义类型）相关的方法/函数集中管理，同时也可避开方法重名的问题，一般用在对自定义类型进行初始化、类型转换等场景。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_helper/","summary":"从其它平台迁移而来\n通常情况下，类型和记录是没有方法的，只有类有方法，但是可以通过给类型和记录添加助手来达到类似于类的方法的功能，当然，也可以给类添加助手。\n语法 1 2 3 HelperName = class|record|type helper[(OptionalBaseHelper)] for TypeName [properties, procedures, functions, constructors, consts, vars] end [hint modifiers]; 类助手 FPC 2.6+版本可用，ObjFPC模式下无需特别设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //定义 TObjectHelper = class helper for TObject function SomeFunc: string; end; //实现 function TObjectHelper.SomeFunc: string; begin Result := \u0026#39;类名:\u0026#39; + Self.ClassName; end; //使用 var o: TObject; begin Writeln(o.SomeFunc); end. 一般情况下，给类添加方法可直接在类中添加，但这样添加的方法会直接在所有后代类中显示，如果只是想在特定的范围内添加方法，就可以使用类助手。","title":"给类型、记录、类添加助手"},{"content":" 从其它平台迁移而来\n问题 以前，单纯的做windows桌面应用的开发，wsl里装git，完全按照windows平台进行配置即可。但是现在，想入手golang了，一番了解下来，果然开源的还是linux环境最合适，wsl2目前看是最合适的了，不过，唯一的问题就是要用git同时管理windows和linux项目（其实主要是golang项目，虽然是跨平台的）比较麻烦，麻烦的根源首当其冲的自然是换行符了。\n纯windows开发时，git一般是这样配置：\n1 2 git config --global core.safecrlf true git config --global core.autocrlf true 纯linux开发时，自然可以这样配置：\n1 2 git config --global core.safecrlf true git config --global core.autocrlf input 那既要做windows开发保住饭碗，又要做linux开发提升自我，这git要怎样配置呢？\n解决方案 一番尝试下来，问题解决了，不过有几个前提：\nwindows开发依然在windows环境下进行，linux开发在wsl2下进行\nwindows项目基本固定，就那么几个，偶尔写个demo什么的也用不上git，而linux开发主要是学习的，肯定会频繁创建项目，还要多看别人的项目，所以git的配置要以linux为主\n所以，全局配置按linux来，即：\n1 git config --global core.autocrlf input 具体的windows项目内：\n1 git config --local core.autocrlf true 新clone出的windows项目，需要删除工作区的内容重新checkout：\n1 git checkout -f xxx ","permalink":"https://afrusrsc.github.io/posts/git/git_wsl_win_linux/","summary":" 从其它平台迁移而来\n问题 以前，单纯的做windows桌面应用的开发，wsl里装git，完全按照windows平台进行配置即可。但是现在，想入手golang了，一番了解下来，果然开源的还是linux环境最合适，wsl2目前看是最合适的了，不过，唯一的问题就是要用git同时管理windows和linux项目（其实主要是golang项目，虽然是跨平台的）比较麻烦，麻烦的根源首当其冲的自然是换行符了。\n纯windows开发时，git一般是这样配置：\n1 2 git config --global core.safecrlf true git config --global core.autocrlf true 纯linux开发时，自然可以这样配置：\n1 2 git config --global core.safecrlf true git config --global core.autocrlf input 那既要做windows开发保住饭碗，又要做linux开发提升自我，这git要怎样配置呢？\n解决方案 一番尝试下来，问题解决了，不过有几个前提：\nwindows开发依然在windows环境下进行，linux开发在wsl2下进行\nwindows项目基本固定，就那么几个，偶尔写个demo什么的也用不上git，而linux开发主要是学习的，肯定会频繁创建项目，还要多看别人的项目，所以git的配置要以linux为主\n所以，全局配置按linux来，即：\n1 git config --global core.autocrlf input 具体的windows项目内：\n1 git config --local core.autocrlf true 新clone出的windows项目，需要删除工作区的内容重新checkout：\n1 git checkout -f xxx ","title":"在wsl中使用Git同时管理windows项目和linux项目"},{"content":" 从其它平台迁移而来\n个性配置 纯文本复制 设置-\u0026gt;搜索copy-\u0026gt;取消Editor:Copy With Syntax Highlighting前的勾\n列分隔线 设置-\u0026gt;搜索rulers-\u0026gt;点Editor:Rulers项下的在settings.json中编辑-\u0026gt;如下填入分隔线位置（可设置多个，多个值之间用,隔开）\n1 2 3 \u0026#34;editor.rulers\u0026#34;: [ 80, 120 ], 显示空格 设置-\u0026gt;搜索whitespace-\u0026gt;找到Editor:Render Whitespace-\u0026gt;选择all\n自动换行 设置-\u0026gt;搜索word-\u0026gt;找到Editor:Word Wrap-\u0026gt;选择on\n使用技巧 列模式 ALT+鼠标左击：选择不连续的列进行列编辑，列可不对齐\nALT+鼠标拖动：选择连续的列进行列编辑，列会对齐\n","permalink":"https://afrusrsc.github.io/posts/other/vscode/","summary":"从其它平台迁移而来\n个性配置 纯文本复制 设置-\u0026gt;搜索copy-\u0026gt;取消Editor:Copy With Syntax Highlighting前的勾\n列分隔线 设置-\u0026gt;搜索rulers-\u0026gt;点Editor:Rulers项下的在settings.json中编辑-\u0026gt;如下填入分隔线位置（可设置多个，多个值之间用,隔开）\n1 2 3 \u0026#34;editor.rulers\u0026#34;: [ 80, 120 ], 显示空格 设置-\u0026gt;搜索whitespace-\u0026gt;找到Editor:Render Whitespace-\u0026gt;选择all\n自动换行 设置-\u0026gt;搜索word-\u0026gt;找到Editor:Word Wrap-\u0026gt;选择on\n使用技巧 列模式 ALT+鼠标左击：选择不连续的列进行列编辑，列可不对齐\nALT+鼠标拖动：选择连续的列进行列编辑，列会对齐","title":"VSCode基本使用"},{"content":" 从其它平台迁移而来\n基础知识 后缀名一般为.md\n只关注于内容，渲染交给页面或软件来实现\n语法 标题 1 2 3 4 5 6 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 段落 连续两个回车或连续两个空格一个回车表示一个段落的结束。\n有序列表 1 2 3 4 5 1. 有序列表1 2. 有序列表2 3. 有序列表3 无序列表 1 2 3 4 5 - 无序列表1 - 无序列表2 - 无序列表3 任务列表 1 2 3 - [ ] 这是未完成 - [x] 这是已完成 这是扩展语法，部分渲染可能不支持。 引用 1 2 3 \u0026gt; 这是引用的内容 \u0026gt; \u0026gt; 这是又一行的引用内容 格式 1 2 3 *这是斜体* **这是加粗** ~~这是删除线~~ 分隔线 1 2 3 --- *** ___ 代码块 1 `这是行内代码块` 1 2 3 ``` 这是多行代码块 ``` 1 2 3 4 5 6 7 ```c //在```之后加语言名可进行语法高亮，具体看渲染如何实现 # include \u0026lt;stdio.h\u0026gt; int main(){ return 0; } ``` 表格 1 2 3 |列标题1|列标题2|列标题3| |-------|-------|-------| |列内容1|列内容2|列内容3| 两端的|可以省略\n中间连续的---可以只用一个-\n单独的-或:-表示左对齐\n-:表示右对齐\n:-:表示居中\n超链接 1 [超链接显示名称](超链接地址 \u0026#34;超链接提示\u0026#34;) 图片 1 ![图片显示名称](图片地址 \u0026#34;图片提示\u0026#34;) 脚注 1 2 3 4 5 这是文档内容，加个脚注[^1]看看。 [^1]: 这是脚注内容，不一定非要写到文章末尾。 这里是接着的内容。 这是扩展语法，部分渲染可能不支持。 其它 部分语法之间可以进行互相嵌套。\n可以嵌套html标签，但个人不建议使用，除非有必要且Markdown不支持。\n多行代码块也可以使用Mermaid语法来表示流程图、饼图、甘特图等，但需要渲染支持。\n详情请看官方教程。\n","permalink":"https://afrusrsc.github.io/posts/other/markdown/","summary":"从其它平台迁移而来\n基础知识 后缀名一般为.md\n只关注于内容，渲染交给页面或软件来实现\n语法 标题 1 2 3 4 5 6 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 段落 连续两个回车或连续两个空格一个回车表示一个段落的结束。\n有序列表 1 2 3 4 5 1. 有序列表1 2. 有序列表2 3. 有序列表3 无序列表 1 2 3 4 5 - 无序列表1 - 无序列表2 - 无序列表3 任务列表 1 2 3 - [ ] 这是未完成 - [x] 这是已完成 这是扩展语法，部分渲染可能不支持。 引用 1 2 3 \u0026gt; 这是引用的内容 \u0026gt; \u0026gt; 这是又一行的引用内容 格式 1 2 3 *这是斜体* **这是加粗** ~~这是删除线~~ 分隔线 1 2 3 --- *** ___ 代码块 1 `这是行内代码块` 1 2 3 ``` 这是多行代码块 ``` 1 2 3 4 5 6 7 ```c //在```之后加语言名可进行语法高亮，具体看渲染如何实现 # include \u0026lt;stdio.","title":"Markdown基础"},{"content":" 从其它平台迁移而来\n一直以来，都是用git commit -m来提交代码的，结果就是看提交历史时一点儿都不赏心悦目！既然别人已经有好的实践了，那么就来学习一下吧。\n提交消息格式 1 2 3 4 5 修改类型(影响范围):\u0026lt;--空格--\u0026gt;标题 \u0026lt;--空行--\u0026gt; [正文] \u0026lt;--空行--\u0026gt; [页脚] 任何一行都不能超过100个字符，以便在各种git工具中方便阅读 修改类型 以下选其一：\n值 含义 feat 添加新功能 fix 修复bug docs 只修改了文档 style 调整代码格式，未修改代码逻辑（如：调整空白、格式化等） refactor 代码重构，既没修复bug也没添加新功能 perf 性能优化，提高性能的代码修改 test 添加或修改代码测试 chore 对构建流程或辅助工具和依赖库（如文档生成等）的更改 revert 代码回滚 影响范围 内容不固定，可以是代码影响到的任何内容，但要足够简要。如果影响到多个范围可以用*表示。\n标题 必需，能简要描述本次提交的信息。\n不要大写首字母\n结尾不要使用句号\n正文 非必需，是对标题的补充说明。\n页脚 任何破坏性变更、不向下兼容都应在页脚中说明。也经常用来引用本次解决的issue。\n破坏性变更应以BREAKING CHANGE开头 1 BREAKING CHANGE:\u0026lt;--空格--\u0026gt;页脚内容 代码回滚 1 2 3 4 5 revert(影响范围):\u0026lt;--空格--\u0026gt;要恢复到的那个提交的标题 \u0026lt;--空行--\u0026gt; This reverts commit \u0026lt;要恢复到的那个提交的hash\u0026gt; \u0026lt;--空行--\u0026gt; [页脚] ","permalink":"https://afrusrsc.github.io/posts/git/git_commit_specification/","summary":" 从其它平台迁移而来\n一直以来，都是用git commit -m来提交代码的，结果就是看提交历史时一点儿都不赏心悦目！既然别人已经有好的实践了，那么就来学习一下吧。\n提交消息格式 1 2 3 4 5 修改类型(影响范围):\u0026lt;--空格--\u0026gt;标题 \u0026lt;--空行--\u0026gt; [正文] \u0026lt;--空行--\u0026gt; [页脚] 任何一行都不能超过100个字符，以便在各种git工具中方便阅读 修改类型 以下选其一：\n值 含义 feat 添加新功能 fix 修复bug docs 只修改了文档 style 调整代码格式，未修改代码逻辑（如：调整空白、格式化等） refactor 代码重构，既没修复bug也没添加新功能 perf 性能优化，提高性能的代码修改 test 添加或修改代码测试 chore 对构建流程或辅助工具和依赖库（如文档生成等）的更改 revert 代码回滚 影响范围 内容不固定，可以是代码影响到的任何内容，但要足够简要。如果影响到多个范围可以用*表示。\n标题 必需，能简要描述本次提交的信息。\n不要大写首字母\n结尾不要使用句号\n正文 非必需，是对标题的补充说明。\n页脚 任何破坏性变更、不向下兼容都应在页脚中说明。也经常用来引用本次解决的issue。\n破坏性变更应以BREAKING CHANGE开头 1 BREAKING CHANGE:\u0026lt;--空格--\u0026gt;页脚内容 代码回滚 1 2 3 4 5 revert(影响范围):\u0026lt;--空格--\u0026gt;要恢复到的那个提交的标题 \u0026lt;--空行--\u0026gt; This reverts commit \u0026lt;要恢复到的那个提交的hash\u0026gt; \u0026lt;--空行--\u0026gt; [页脚] ","title":"Git提交规范"},{"content":" 从其它平台迁移而来\n安装 Windows 下载git，由于某些原因，建议去镜像站点下载对应的版本（建议下载便携版）。\n便携版进行自解压，选择合适路径，建议路径不要有中文。\n在环境变量中修改Path的值，增加git路径\\bin。\n若有需要，也可以安装TortoiseGit图形操作界面。\n其实Win10+启用wsl，然后在wsl里安装使用git是最爽的。\nLinux 1 sudo apt update \u0026amp;\u0026amp; sudo apt install git 基本配置 1 2 3 4 5 6 7 8 9 10 11 # 用户名和邮箱 git config --global user.name \u0026#34;XXX\u0026#34; git config --global user.email XXXXXX@XXX.com # 换行符 git config --global core.safecrlf true git config --global core.autocrlf input # Windows 平台设为 true # 记住密码 git config --global credential.helper store # 别名设置 git config --global alias.lga \u0026#34;log --color --graph --pretty=format:\u0026#39;%C(auto)%h%C(auto)%d%Creset %s %C(bold blue)\u0026lt;%an\u0026gt; %C(yellow)%cd%Creset\u0026#39; --date=format:\u0026#39;%Y-%m-%d %H:%M\u0026#39; --abbrev-commit --all\u0026#34; git config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%C(auto)%h%C(auto)%d%Creset %s %C(bold blue)\u0026lt;%an\u0026gt; %C(yellow)%cd%Creset\u0026#39; --date=format:\u0026#39;%Y-%m-%d %H:%M\u0026#39; --abbrev-commit\u0026#34; 本地操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 初始化仓库 git init # 查看状态 git status # 添加修改到暂存区 git add . # 添加当前目前下所有文件修改 git add xxx # 添加指定文件 # 提交到仓库 git commit # 进入交互界面填写提交信息后提交 git commit -m \u0026#39;提交信息\u0026#39; # 直接填写提交信息并提交 # 创建分支 git branch xxx # 创建并切换到新分支 git checkout -b xxx # 检出分支 git checkout xxx # 切换分支 git switch xxx # 合并分支 git merge xxx # 删除分支 git branch -d xxx # 删除前检查 merge 状态 git branch -D xxx # 直接强制删除 # 查看提交日志 git log 远程操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 克隆仓库 git clone 远程仓库地址 本地路径 # 查看远程仓库信息 git remote -v # 添加远程仓库地址 git remote add 仓库别名 仓库地址 # 修改远程仓库别名 git remote rename 旧名称 新名称 # 移除远程仓库 git remote remove 仓库别名 # 获取远程仓库提交信息 git fetch # 加 --all 表示遍历全部远程仓库 # 拉取远程提交的代码 git pull # 默认与本地代码进行 merge # 推送本地提交到远程仓库 git push # 删除远程分支 git push 仓库别名 :分支名 # 推送空分支即删除 ","permalink":"https://afrusrsc.github.io/posts/git/git_base/","summary":"从其它平台迁移而来\n安装 Windows 下载git，由于某些原因，建议去镜像站点下载对应的版本（建议下载便携版）。\n便携版进行自解压，选择合适路径，建议路径不要有中文。\n在环境变量中修改Path的值，增加git路径\\bin。\n若有需要，也可以安装TortoiseGit图形操作界面。\n其实Win10+启用wsl，然后在wsl里安装使用git是最爽的。\nLinux 1 sudo apt update \u0026amp;\u0026amp; sudo apt install git 基本配置 1 2 3 4 5 6 7 8 9 10 11 # 用户名和邮箱 git config --global user.name \u0026#34;XXX\u0026#34; git config --global user.email XXXXXX@XXX.com # 换行符 git config --global core.safecrlf true git config --global core.autocrlf input # Windows 平台设为 true # 记住密码 git config --global credential.helper store # 别名设置 git config --global alias.","title":"Git的基本使用"},{"content":" 从其它平台迁移而来\nLazarus默认已经提供了zip文件的压缩和解压功能，在Zipper单元中，不过，使用过程中还是有一些细节需要注意。\n压缩 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 uses Zipper; { 使用类方法进行压缩 } //压缩单个文件 TZipper.Zip(\u0026#39;压缩后的文件.zip\u0026#39;, \u0026#39;待压缩的文件.txt\u0026#39;); //压缩多个文件 TZipper.Zip(\u0026#39;压缩后的文件.zip\u0026#39;, [\u0026#39;待压缩的文件1.txt\u0026#39;, \u0026#39;待压缩的文件2.pdf\u0026#39;]); { 使用实例对象进行压缩 } var zip: TZipper; zip := TZipper.Create; try //压缩单个文件 zip.ZipFile(\u0026#39;压缩后的文件.zip\u0026#39;, \u0026#39;待压缩的文件.txt\u0026#39;); //压缩多个文件 zip.ZipFiles(\u0026#39;压缩后的文件.zip\u0026#39;, [\u0026#39;待压缩的文件1.txt\u0026#39;, \u0026#39;待压缩的文件2.pdf\u0026#39;]); finally zip.Free; end; 以上为比较方便的使用方法，但是还存在一些问题：\n以上仅限于文件名为英文的情况，若文件名为中文则会出现乱码（主要是在windows平台上，用专门的压缩/解压工具打开查看列表和解压时）。查看解决方案。\n若待压缩的文件包括路径，则压缩后的文件内也会包含传参时传入的路径。查看解决方案。\n另外，也可以配合FileName（压缩后的文件名）和Entries（待压缩的文件）属性使用ZipAllFiles方法；或者配合Entries（待压缩的文件）属性使用SaveToFile方法。不过，多次调用前一定要调用Clear方法，否则就会受前一次压缩操作的影响。\n解压 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 uses Zipper; { 使用类方法进行解压 } //解压出全部文件 TUnZipper.Unzip(\u0026#39;待解压文件.zip\u0026#39;); //解压出指定的多个文件 TUnZipper.Unzip(\u0026#39;待解压文件.zip\u0026#39;, [\u0026#39;指定解压出的文件1.txt\u0026#39;, \u0026#39;指定解压出的文件2.pdf\u0026#39;]); //解压出指定的一个文件 TUnZipper.Unzip(\u0026#39;待解压文件.zip\u0026#39;, \u0026#39;指定解压出的文件.txt\u0026#39;); { 使用实例对象进行解压 } var unzip: TUnZipper; unzip := TUnZipper.Create; try //解压出全部文件 unzip.UnZipAllFiles(\u0026#39;待解压文件.zip\u0026#39;); //解压出指定的多个文件 unzip.UnZipFiles(\u0026#39;待解压文件.zip\u0026#39;, [\u0026#39;指定解压出的文件1.txt\u0026#39;, \u0026#39;指定解压出的文件2.pdf\u0026#39;]); //解压出指定的一个文件 unzip.UnZipFile(\u0026#39;待解压文件.zip\u0026#39;, \u0026#39;指定解压出的文件.txt\u0026#39;); finally unzip.Free; end; 以上为比较方便的使用方法，另外，也可以配合FileName（待解压的压缩文件名）属性使用UnZipAllFiles或UnZipFiles方法。\n与压缩类似，同样也存在中文乱码。查看解决方案。\n中文乱码问题 使用类方法是无法解决中文乱码问题的。\n使用实例对象，对于压缩，只需在压缩前把UseLanguageEncoding属性设置为True即可；对于解压，只需在解压前把UseUTF8属性设置为True即可。\n路径问题 如果压缩时传入的待压缩文件是包含绝对路径的文件名，则生成的zip文件也包含了完整的目录结构，直接解压也会按照对应的目录生成对应的文件。\n如果压缩时传入的待压缩文件包含部分路径，即相对路径，那么，在该相对路径下必须存在对应的待压缩文件，否则将报错；而生成的zip文件也将包含该相对路径，解压时也会按该相对路径生成对应的文件。\n如果压缩时传入的待压缩文件不包含任何路径，则表示相对路径为当前路径，压缩/解压规则与相对路径的规则完全一样。\n注意事项 以上提及的相对路径都是对于当前路径来说的。默认情况下，当前路径是指程序所在的路径，除非程序运行时执行过ChDir，那么当前路径就是指最后一次执行过ChDir之后所在的路径。\n解压时也可给OutputPath属性赋值指定路径，该路径即为解压输出时的路径，若不指定，则默认当前路径为输出路径。\n当解压指定的文件时，若压缩文件中包含有路径，那么路径分隔符应使用Linux路径分隔符即/，即使在Windows上也是如此。\n压缩时，路径分隔符既可以使用\\（仅Windows平台），也可以使用/，甚至同时使用/和\\也没什么问题，但非常不建议混合使用；解压时，则只能使用/。\n1 2 3 4 5 6 7 //压缩 zip.ZipFiles(\u0026#39;test.zip\u0026#39;, [\u0026#39;a\\abc.txt\u0026#39;, \u0026#39;123.pdf\u0026#39;]); //or zip.ZipFiles(\u0026#39;test.zip\u0026#39;, [\u0026#39;a/abc.txt\u0026#39;, \u0026#39;123.pdf\u0026#39;]); //效果完全一样 //解压 a\\abc.txt unzip.UnZipFile(\u0026#39;test.zip\u0026#39;, \u0026#39;a/abc.txt\u0026#39;); ","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_zip02/","summary":"从其它平台迁移而来\nLazarus默认已经提供了zip文件的压缩和解压功能，在Zipper单元中，不过，使用过程中还是有一些细节需要注意。\n压缩 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 uses Zipper; { 使用类方法进行压缩 } //压缩单个文件 TZipper.Zip(\u0026#39;压缩后的文件.zip\u0026#39;, \u0026#39;待压缩的文件.txt\u0026#39;); //压缩多个文件 TZipper.Zip(\u0026#39;压缩后的文件.zip\u0026#39;, [\u0026#39;待压缩的文件1.txt\u0026#39;, \u0026#39;待压缩的文件2.pdf\u0026#39;]); { 使用实例对象进行压缩 } var zip: TZipper; zip := TZipper.Create; try //压缩单个文件 zip.ZipFile(\u0026#39;压缩后的文件.zip\u0026#39;, \u0026#39;待压缩的文件.txt\u0026#39;); //压缩多个文件 zip.ZipFiles(\u0026#39;压缩后的文件.zip\u0026#39;, [\u0026#39;待压缩的文件1.txt\u0026#39;, \u0026#39;待压缩的文件2.pdf\u0026#39;]); finally zip.Free; end; 以上为比较方便的使用方法，但是还存在一些问题：\n以上仅限于文件名为英文的情况，若文件名为中文则会出现乱码（主要是在windows平台上，用专门的压缩/解压工具打开查看列表和解压时）。查看解决方案。\n若待压缩的文件包括路径，则压缩后的文件内也会包含传参时传入的路径。查看解决方案。\n另外，也可以配合FileName（压缩后的文件名）和Entries（待压缩的文件）属性使用ZipAllFiles方法；或者配合Entries（待压缩的文件）属性使用SaveToFile方法。不过，多次调用前一定要调用Clear方法，否则就会受前一次压缩操作的影响。\n解压 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 uses Zipper; { 使用类方法进行解压 } //解压出全部文件 TUnZipper.","title":"使用Lazarus压缩/解压zip"},{"content":" 从其它平台迁移而来\n分析开机启动时间 1 sudo systemd-analyze 列出开机启动项 1 sudo systemd-analyze blame 关闭开机启动项 注意：不要随意关闭，查资料确定关闭会产生的影响，评估后再进行关闭！\n1 sudo systemctl disable xxx 恢复已关闭的开机启动项 1 sudo systemctl enable xxx ","permalink":"https://afrusrsc.github.io/posts/os/linux_sys_start_time/","summary":" 从其它平台迁移而来\n分析开机启动时间 1 sudo systemd-analyze 列出开机启动项 1 sudo systemd-analyze blame 关闭开机启动项 注意：不要随意关闭，查资料确定关闭会产生的影响，评估后再进行关闭！\n1 sudo systemctl disable xxx 恢复已关闭的开机启动项 1 sudo systemctl enable xxx ","title":"Linux开机时间优化"},{"content":" 从其它平台迁移而来\n背景 一般情况下，企业内部多数是使用SVN来进行版本控制的，原因通常也就两个字——简单：\n安装简单，无论服务端还是客户端\n操作简单，即使非技术人员也能很快学会\n管理简单，建目录、开账户、分权限，基本就能完成95%以上的需求\nSVN是很强大的，但是使用者的水平差距也是很巨大的，结果就是多数情况下只有一个分支，大家都往里面各种提交，当然，有好好管理的不含在内。\n不过，用过git的人，尤其是开发人员，估计都会喜欢git多一些，那么，同时使用SVN和git就会爽很多。\n以下就以企业内使用SVN，开发者使用git为例进行说明，其中：SVN遵守企业内的版本控制使用工作流程，git遵守git类的工作流程。\n环境配置 SVN 以使用ToroiseSVN为例：\n任意文件夹中（最好是非SVN项目，减少菜单干扰）右键-\u0026gt;ToroiseSVN-\u0026gt;设置-\u0026gt;常规设置-\u0026gt;Subversion-\u0026gt;全局忽略样式（全局设置不会提交到版本库，避免对仓库信息的修改而影响到别人），在原有基础上追加以下内容： 1 .git .gitignore .README.md 拉取SVN代码 git 配置git环境\n在要使用git的SVN项目下建git版本库的初始化\n1 2 cd 项目 git init 编写.gitignore文件，配置常规开发需忽略的文件，再加上SVN的版本库信息.svn/\n再次拉取SVN代码，确保代码最新\n把文件增加进git库\n1 git add . 提交初版代码 1 git commit 工作流 分支 master：主分支，与SVN保持一致\ndev：开发主分支，主要用于合并开发完成的内容\n...：任务分支（含BUG修复），具体的开发任务，开发完成后要合并到dev\n具体流程 --- title: SVN+git工作流程 --- graph TD subgraph m[master分支流程] direction TB m1[切到master分支] m2[检出SVN代码] m3[git提交] m4[合并dev代码] m5[SVN提交] m1 --\u003e m2 --\u003e m3 --\u003e m4 --\u003e m5 end subgraph d[dev分支流程] direction TB d1[切到dev分支] d2[合并工作分支内容] d3[合并master分支内容] d4[根据情况调整] d5[提交] d6[切回master] d1 --\u003e d2 --\u003e d4 d1 --\u003e d3 --\u003e d4 --\u003e d5 --\u003e d6 end subgraph w[工作分支流程] direction TB w1[新建/切到工作分支] w2[根据情况合并dev分支内容] w3[开发] w4[提交] w5[根据情况切对应分支] w1 --\u003e w2 --\u003e w4 --\u003e w5 w1 --\u003e w3 --\u003e w4 end m3 -.-\u003e d -.-\u003e m4 d1 -.-\u003e w -.-\u003e d2 注意：必须在master分支才能进行SVN的检出操作！\n","permalink":"https://afrusrsc.github.io/posts/git/git_svn/","summary":"从其它平台迁移而来\n背景 一般情况下，企业内部多数是使用SVN来进行版本控制的，原因通常也就两个字——简单：\n安装简单，无论服务端还是客户端\n操作简单，即使非技术人员也能很快学会\n管理简单，建目录、开账户、分权限，基本就能完成95%以上的需求\nSVN是很强大的，但是使用者的水平差距也是很巨大的，结果就是多数情况下只有一个分支，大家都往里面各种提交，当然，有好好管理的不含在内。\n不过，用过git的人，尤其是开发人员，估计都会喜欢git多一些，那么，同时使用SVN和git就会爽很多。\n以下就以企业内使用SVN，开发者使用git为例进行说明，其中：SVN遵守企业内的版本控制使用工作流程，git遵守git类的工作流程。\n环境配置 SVN 以使用ToroiseSVN为例：\n任意文件夹中（最好是非SVN项目，减少菜单干扰）右键-\u0026gt;ToroiseSVN-\u0026gt;设置-\u0026gt;常规设置-\u0026gt;Subversion-\u0026gt;全局忽略样式（全局设置不会提交到版本库，避免对仓库信息的修改而影响到别人），在原有基础上追加以下内容： 1 .git .gitignore .README.md 拉取SVN代码 git 配置git环境\n在要使用git的SVN项目下建git版本库的初始化\n1 2 cd 项目 git init 编写.gitignore文件，配置常规开发需忽略的文件，再加上SVN的版本库信息.svn/\n再次拉取SVN代码，确保代码最新\n把文件增加进git库\n1 git add . 提交初版代码 1 git commit 工作流 分支 master：主分支，与SVN保持一致\ndev：开发主分支，主要用于合并开发完成的内容\n...：任务分支（含BUG修复），具体的开发任务，开发完成后要合并到dev\n具体流程 --- title: SVN+git工作流程 --- graph TD subgraph m[master分支流程] direction TB m1[切到master分支] m2[检出SVN代码] m3[git提交] m4[合并dev代码] m5[SVN提交] m1 --\u003e m2 --\u003e m3 --\u003e m4 --\u003e m5 end subgraph d[dev分支流程] direction TB d1[切到dev分支] d2[合并工作分支内容] d3[合并master分支内容] d4[根据情况调整] d5[提交] d6[切回master] d1 --\u003e d2 --\u003e d4 d1 --\u003e d3 --\u003e d4 --\u003e d5 --\u003e d6 end subgraph w[工作分支流程] direction TB w1[新建/切到工作分支] w2[根据情况合并dev分支内容] w3[开发] w4[提交] w5[根据情况切对应分支] w1 --\u003e w2 --\u003e w4 --\u003e w5 w1 --\u003e w3 --\u003e w4 end m3 -.","title":"同时使用Git和SVN"},{"content":" 从其它平台迁移而来\n在Delphi中，可以使用CnPack中代码助手的功能，实现快速编写基础代码，专注于写具体业务、逻辑代码。在Lazarus中，也可以使用代码模板功能，实现相同的需求。\n使用方法 将光标移到需要录入代码的位置\n按Ctrl+J快捷键，弹出代码模板列表\n选择要使用的模板，Enter回车\n若模板需要填写参数，可在代码模板插入后，按Tab键在各参数间切换并修改，最后按Esc键或将光标移到其它位置\n在模板生成的代码的基础上继续编写代码\n注意：\n可以先输入部分/完整代码模板的Token，然后再按快捷键；也可以按过快捷键后，继续输入Token剩余部分进一步过滤；当然，也可以组合使用。\n先输入Token再按快捷键时，若可唯一确定模板，则会直接应用而不弹出模板列表。\n自定义模板 Lazarus默认了一批模板，可以在菜单Tools-\u0026gt;Code Templates ...中进行查看。\n若感觉默认模板不合适，可自行修改；若默认模板无法满足使用，也可自行添加。\n简要说明 Module：当前使用的代码模板，默认是主配置目录下的lazarus.dci，可点右侧按钮选用其它模板。\nTemplates：所选代码模板的具体清单，格式为：Token - \u0026quot;说明\u0026quot;。右侧三个按钮用于对模板清单进行维护。\n其余部分：所选模板项的详细信息。\n最下方的编辑区：代码模板的具体内容，$开头的表示使用的宏代码，|表示模板插入后光标的位置。\nKeep indentation：保持代码模板内容的缩进，勾选后代码模板首行在光标处插入，除首行外的缩进量保持原样插入（类似行模式插入）；否则模板首行外的内容与首行保持相对缩进（类似列模式插入）。\nEnable Macros：启用宏代码，点Insert Macro可插入预定义的宏。\nAuto complate on：自动完成，类似于事件触发，即满足条件后无需按Ctrl+J快捷键直接应用模板。\nline break：按回车键时触发\nspace：按空格键时触发\ntab：按Tab键时触发\nword end：输入结束字符时触发，可暂时理解为输入;时触发\ndo not complate selection：暂时还不清楚具体效果\ndo not add character：可与前四种结合使用，勾选后不会把用来触发的字符插入到代码中，否则会插入用来触发的字符\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_code_templates/","summary":"从其它平台迁移而来\n在Delphi中，可以使用CnPack中代码助手的功能，实现快速编写基础代码，专注于写具体业务、逻辑代码。在Lazarus中，也可以使用代码模板功能，实现相同的需求。\n使用方法 将光标移到需要录入代码的位置\n按Ctrl+J快捷键，弹出代码模板列表\n选择要使用的模板，Enter回车\n若模板需要填写参数，可在代码模板插入后，按Tab键在各参数间切换并修改，最后按Esc键或将光标移到其它位置\n在模板生成的代码的基础上继续编写代码\n注意：\n可以先输入部分/完整代码模板的Token，然后再按快捷键；也可以按过快捷键后，继续输入Token剩余部分进一步过滤；当然，也可以组合使用。\n先输入Token再按快捷键时，若可唯一确定模板，则会直接应用而不弹出模板列表。\n自定义模板 Lazarus默认了一批模板，可以在菜单Tools-\u0026gt;Code Templates ...中进行查看。\n若感觉默认模板不合适，可自行修改；若默认模板无法满足使用，也可自行添加。\n简要说明 Module：当前使用的代码模板，默认是主配置目录下的lazarus.dci，可点右侧按钮选用其它模板。\nTemplates：所选代码模板的具体清单，格式为：Token - \u0026quot;说明\u0026quot;。右侧三个按钮用于对模板清单进行维护。\n其余部分：所选模板项的详细信息。\n最下方的编辑区：代码模板的具体内容，$开头的表示使用的宏代码，|表示模板插入后光标的位置。\nKeep indentation：保持代码模板内容的缩进，勾选后代码模板首行在光标处插入，除首行外的缩进量保持原样插入（类似行模式插入）；否则模板首行外的内容与首行保持相对缩进（类似列模式插入）。\nEnable Macros：启用宏代码，点Insert Macro可插入预定义的宏。\nAuto complate on：自动完成，类似于事件触发，即满足条件后无需按Ctrl+J快捷键直接应用模板。\nline break：按回车键时触发\nspace：按空格键时触发\ntab：按Tab键时触发\nword end：输入结束字符时触发，可暂时理解为输入;时触发\ndo not complate selection：暂时还不清楚具体效果\ndo not add character：可与前四种结合使用，勾选后不会把用来触发的字符插入到代码中，否则会插入用来触发的字符","title":"在Lazarus中使用代码模板"},{"content":" 从其它平台迁移而来\n起因 以前使用Delphi调用海康SDK时，专门改写过HCNetSDK.h，当时大部分桌面应用还都是32位的，毕竟64位还没彻底普及开（即便现在，还是有一部分桌面考虑兼容性依然是32位）。后来也搞过64位版的，编译没问题，运行就不成功。虽然没成功，但心里还是清楚这基本上是数据类型的问题，由于对64位了解不多，也就一直搁置着。\n转Lazarus之后，又搞过一次64位版，还是没成功。后来知道有ctypes这个单元，也知道这是专门针对c语言数据类型的，但一直没去看过。近来又想起这个事，就想一探究竟。\n探 直接看源码，其实就是给pascal的数据类型取了个c的别名。要想了解透彻，自已撸码跑一下还是很有必要的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 program test; uses SysUtils, ctypes; begin writeln(Format(\u0026#39;%-16s%s\u0026#39;, [\u0026#39;type\u0026#39;, \u0026#39;size\u0026#39;])); writeln(\u0026#39;--------------------\u0026#39;); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cint8\u0026#39;, SizeOf(cint8)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cuint8\u0026#39;, SizeOf(cuint8)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cchar\u0026#39;, SizeOf(cchar)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cschar\u0026#39;, SizeOf(cschar)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cuchar\u0026#39;, SizeOf(cuchar)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cint16\u0026#39;, SizeOf(cint16)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cuint16\u0026#39;, SizeOf(cuint16)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cshort\u0026#39;, SizeOf(cshort)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;csshort\u0026#39;, SizeOf(csshort)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cushort\u0026#39;, SizeOf(cushort)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cint32\u0026#39;, SizeOf(cint32)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cuint32\u0026#39;, SizeOf(cuint32)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cint64\u0026#39;, SizeOf(cint64)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cuint64\u0026#39;, SizeOf(cuint64)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;clonglong\u0026#39;, SizeOf(clonglong)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cslonglong\u0026#39;, SizeOf(cslonglong)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;culonglong\u0026#39;, SizeOf(culonglong)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cbool\u0026#39;, SizeOf(cbool)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cint\u0026#39;, SizeOf(cint)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;csint\u0026#39;, SizeOf(csint)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cuint\u0026#39;, SizeOf(cuint)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;clong\u0026#39;, SizeOf(clong)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cslong\u0026#39;, SizeOf(cslong)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;culong\u0026#39;, SizeOf(culong)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;csigned\u0026#39;, SizeOf(csigned)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cunsigned\u0026#39;, SizeOf(cunsigned)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;csize_t\u0026#39;, SizeOf(csize_t)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cfloat\u0026#39;, SizeOf(cfloat)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cdouble\u0026#39;, SizeOf(cdouble)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;clongdouble\u0026#39;, SizeOf(clongdouble)])); Readln(); end. 做为对比，c的也来一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;int8_t\u0026#34;,sizeof(int8_t)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;uint8_t\u0026#34;,sizeof(uint8_t)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;char\u0026#34;,sizeof(char)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;signed char\u0026#34;,sizeof(signed char)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;unsigned char\u0026#34;,sizeof(unsigned char)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;int16_t\u0026#34;,sizeof(int16_t)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;uint16_t\u0026#34;,sizeof(uint16_t)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;short\u0026#34;,sizeof(short)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;signed short\u0026#34;,sizeof(signed short)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;unsigned short\u0026#34;,sizeof(unsigned short)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;int32_t\u0026#34;,sizeof(int32_t)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;uint32_t\u0026#34;,sizeof(uint32_t)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;int64_t\u0026#34;,sizeof(int64_t)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;uint64_t\u0026#34;,sizeof(uint64_t)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;long long\u0026#34;,sizeof(long long)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;signed long long\u0026#34;,sizeof(signed long long)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;unsigned long long\u0026#34;,sizeof(unsigned long long)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;bool\u0026#34;,sizeof(bool)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;int\u0026#34;,sizeof(int)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;signed int\u0026#34;,sizeof(signed int)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;unsigned int\u0026#34;,sizeof(unsigned int)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;long\u0026#34;,sizeof(long)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;signed long\u0026#34;,sizeof(signed long)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;unsigned long\u0026#34;,sizeof(unsigned long)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;signed\u0026#34;,sizeof(signed)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;unsigned\u0026#34;,sizeof(unsigned)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;size_t\u0026#34;,sizeof(size_t)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;float\u0026#34;,sizeof(float)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;double\u0026#34;,sizeof(double)); printf(\u0026#34;%s\\t %d\\n\u0026#34;,\u0026#34;long double\u0026#34;,sizeof(long double)); return 0; } 分别用32位和64位编译运行，然后，然后就凌乱了~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // Lazarus | // c // type 32bit 64bit | // type 32bit 64bit ----------------------- | ------------------------------ cint8 1 1 | int8_t 1 1 cuint8 1 1 | uint8_t 1 1 cchar 1 1 | char 1 1 cschar 1 1 | signed char 1 1 cuchar 1 1 | unsigned char 1 1 cint16 2 2 | int16_t 2 2 cuint16 2 2 | uint16_t 2 2 cshort 2 2 | short 2 2 csshort 2 2 | signed short 2 2 cushort 2 2 | unsigned short 2 2 cint32 4 4 | int32_t 4 4 cuint32 4 4 | uint32_t 4 4 cint64 8 8 | int64_t 8 8 cuint64 8 8 | uint64_t 8 8 clonglong 8 8 | long long 8 8 cslonglong 8 8 | signed long long 8 8 culonglong 8 8 | unsigned long long 8 8 cbool 4 4 | bool 1 1 cint 4 4 | int 4 4 csint 4 4 | signed int 4 4 cuint 4 4 | unsigned int 4 4 clong 4 4 | long 4 4 cslong 4 4 | signed long 4 4 culong 4 4 | unsigned long 4 4 csigned 4 4 | signed 4 4 cunsigned 4 4 | unsigned 4 4 csize_t 4 8 | size_t 4 8 cfloat 4 4 | float 4 4 cdouble 8 8 | double 8 8 clongdouble 12 8 | long double 12 16 cbool的差异大概知道是怎么回事，这clongdouble是个什么鬼？难道是bug？\n先说cbool，在win平台上，使用c的bool类型的很少，大多数都是用微软的BOOL，而32位平台上的BOOL确实是4B，64位的没研究过，想来为了可移植性应该也是4B。\n再说clongdouble，从感官上讲，64位类型比32位要大才是正常的，而Lazarus的clongdouble，64位比32位还小，似乎是有问题的。\n深深地怀疑这是个bug，然后提了Issues。大概一个小时后，大佬maynard philbrook回复了：\nFrom what I know, and that isn\u0026rsquo;t much. the Fpc 64-bit compiler does not use the Extended float type because it doesn\u0026rsquo;t use the FPU, just the 64-bit registers that exist to performs the double math.\nFrom what I understand it was decided that way because function API calls in the OS do it this way so local support for FPU isn\u0026rsquo;t there.\nBut is used in the 32-bit target.\nGood luck and have a good day.\n大意是说：fpc的64位编译器不使用扩展浮点类型，因为它不使用FPU浮点处理单元，只使用用于执行双精度数学运算的64位寄存器，这也是出于考虑到操作系统的API是这么调用的。但是32位的编译器还是使用FPU的。\n呃~这一下就扯到编译器上了，完全是咱的知识盲区嘛！既然大佬都这么说了，而且也这么多年了，肯定是不会错的，那么，就当是长了次见识了吧！\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_ctype/","summary":"从其它平台迁移而来\n起因 以前使用Delphi调用海康SDK时，专门改写过HCNetSDK.h，当时大部分桌面应用还都是32位的，毕竟64位还没彻底普及开（即便现在，还是有一部分桌面考虑兼容性依然是32位）。后来也搞过64位版的，编译没问题，运行就不成功。虽然没成功，但心里还是清楚这基本上是数据类型的问题，由于对64位了解不多，也就一直搁置着。\n转Lazarus之后，又搞过一次64位版，还是没成功。后来知道有ctypes这个单元，也知道这是专门针对c语言数据类型的，但一直没去看过。近来又想起这个事，就想一探究竟。\n探 直接看源码，其实就是给pascal的数据类型取了个c的别名。要想了解透彻，自已撸码跑一下还是很有必要的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 program test; uses SysUtils, ctypes; begin writeln(Format(\u0026#39;%-16s%s\u0026#39;, [\u0026#39;type\u0026#39;, \u0026#39;size\u0026#39;])); writeln(\u0026#39;--------------------\u0026#39;); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cint8\u0026#39;, SizeOf(cint8)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cuint8\u0026#39;, SizeOf(cuint8)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cchar\u0026#39;, SizeOf(cchar)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cschar\u0026#39;, SizeOf(cschar)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cuchar\u0026#39;, SizeOf(cuchar)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cint16\u0026#39;, SizeOf(cint16)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cuint16\u0026#39;, SizeOf(cuint16)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cshort\u0026#39;, SizeOf(cshort)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;csshort\u0026#39;, SizeOf(csshort)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cushort\u0026#39;, SizeOf(cushort)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cint32\u0026#39;, SizeOf(cint32)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cuint32\u0026#39;, SizeOf(cuint32)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cint64\u0026#39;, SizeOf(cint64)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cuint64\u0026#39;, SizeOf(cuint64)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;clonglong\u0026#39;, SizeOf(clonglong)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cslonglong\u0026#39;, SizeOf(cslonglong)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;culonglong\u0026#39;, SizeOf(culonglong)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cbool\u0026#39;, SizeOf(cbool)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cint\u0026#39;, SizeOf(cint)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;csint\u0026#39;, SizeOf(csint)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cuint\u0026#39;, SizeOf(cuint)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;clong\u0026#39;, SizeOf(clong)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cslong\u0026#39;, SizeOf(cslong)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;culong\u0026#39;, SizeOf(culong)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;csigned\u0026#39;, SizeOf(csigned)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cunsigned\u0026#39;, SizeOf(cunsigned)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;csize_t\u0026#39;, SizeOf(csize_t)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cfloat\u0026#39;, SizeOf(cfloat)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;cdouble\u0026#39;, SizeOf(cdouble)])); writeln(Format(\u0026#39;%-16s%d\u0026#39;, [\u0026#39;clongdouble\u0026#39;, SizeOf(clongdouble)])); Readln(); end.","title":"ctypes里的bug？"},{"content":" 从其它平台迁移而来\n2023-03-09，Lazarus 团队宣布发布 Lazarus 2.2.6 版本，这是一个错误修复版本，使用 FPC 3.2.2 构建。\n大概在Lazarus 2.2.6发布的第二天吧，就把自己电脑上的Lazarus升级到最新了，一直以来都是这个习惯，基本上从来没怎么关心过具体都更新了哪些内容。\n不过，这次心血来潮，把发行日志给大致看了下，看了之后还是有点小收获的，在此记录一二。\n版本号 Lazarus是IDE，最终完成编译的是FPC，两者的版本号管理策略和Linux内核的策略类似。以下为笔者总结，实际的版本号管理策略未考证。\n版本号格式如下：\n1 [主版本号].[次版本号].[修订版本号] 其中，次版本号和修订版本号，奇数为开发版，偶数为稳定版。\n发行日志 Lazarus 2.2.x发行日志原文。可以看到，这是2.2.0的发行日志，并非2.2.6的发行日志，说明这是按次版本号统一整理的。\n由于内容较多，而且部分内容笔者也没接触/使用过，所以，只拣熟悉的或感觉比较重要的拿出来分享一下。\nLazUtils包 移除PasWStr单元 原因：只有当编译器版本低于3.0才包含代码。\n补救：不要再使用PasWStr\nLCL包 TValueListEditor 旧行为：允许在键列中使用当前的NameValueSeparator（默认情况下：=）。\n新行为：不能在键列中使用名称值分隔符。如果在键列中键入名称值分隔符，焦点将移动到值列。如果将其粘贴到列中，它将被删除（没有任何反馈或警告）。\nScreen添加了三组新方法 BeginTempCursor / EndTempCursor、BeginWaitCursor / EndWaitCursor和BeginScreenCursor / EndScreenCursor用于临时光标更改，而不是直接设置Screen.Cursor属性。\nTGroupBox，TRadioGroup，TCheckGroup Win32旧行为：可以设置属性颜色，它直接显示。\nWin32新行为：如果要更改颜色，则必须设置ParentBackground := False;\nTFrame Win32旧行为：无法更改TFrame的颜色。\nWin32新行为：如果要更改颜色，则必须设置ParentBackground := False;\nT(Float)SpinEdit 新增了EditorEnabled属性，以禁用编辑中的直接用户输入。如果设置为False，则用户只能使用微调器或箭头键更改值。\nDebugger LazDebugger-FP (FpDebug) v1.0成为Windows和Linux默认的调试器。\nGDB(mo)使用修改版的GDB 9.2\n笔者补充：FpDebug无法调试dll，需要使用GDB\n组件 OpenGL全面支持Qt5的widgetset。\nTSpinEditEx 新属性ThousandSeparator允许显示插入了千位分隔符的值。\nTFloatSpinEditEx 支持以科学计数法形式的文本进行录入。\n新属性DisplayMode，用于控制是否使用科学记数法。\n新属性property控制以科学记数法显示值时使用的精度。\n还有其它许多更改，详细请看原文。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_v2_2_6/","summary":"从其它平台迁移而来\n2023-03-09，Lazarus 团队宣布发布 Lazarus 2.2.6 版本，这是一个错误修复版本，使用 FPC 3.2.2 构建。\n大概在Lazarus 2.2.6发布的第二天吧，就把自己电脑上的Lazarus升级到最新了，一直以来都是这个习惯，基本上从来没怎么关心过具体都更新了哪些内容。\n不过，这次心血来潮，把发行日志给大致看了下，看了之后还是有点小收获的，在此记录一二。\n版本号 Lazarus是IDE，最终完成编译的是FPC，两者的版本号管理策略和Linux内核的策略类似。以下为笔者总结，实际的版本号管理策略未考证。\n版本号格式如下：\n1 [主版本号].[次版本号].[修订版本号] 其中，次版本号和修订版本号，奇数为开发版，偶数为稳定版。\n发行日志 Lazarus 2.2.x发行日志原文。可以看到，这是2.2.0的发行日志，并非2.2.6的发行日志，说明这是按次版本号统一整理的。\n由于内容较多，而且部分内容笔者也没接触/使用过，所以，只拣熟悉的或感觉比较重要的拿出来分享一下。\nLazUtils包 移除PasWStr单元 原因：只有当编译器版本低于3.0才包含代码。\n补救：不要再使用PasWStr\nLCL包 TValueListEditor 旧行为：允许在键列中使用当前的NameValueSeparator（默认情况下：=）。\n新行为：不能在键列中使用名称值分隔符。如果在键列中键入名称值分隔符，焦点将移动到值列。如果将其粘贴到列中，它将被删除（没有任何反馈或警告）。\nScreen添加了三组新方法 BeginTempCursor / EndTempCursor、BeginWaitCursor / EndWaitCursor和BeginScreenCursor / EndScreenCursor用于临时光标更改，而不是直接设置Screen.Cursor属性。\nTGroupBox，TRadioGroup，TCheckGroup Win32旧行为：可以设置属性颜色，它直接显示。\nWin32新行为：如果要更改颜色，则必须设置ParentBackground := False;\nTFrame Win32旧行为：无法更改TFrame的颜色。\nWin32新行为：如果要更改颜色，则必须设置ParentBackground := False;\nT(Float)SpinEdit 新增了EditorEnabled属性，以禁用编辑中的直接用户输入。如果设置为False，则用户只能使用微调器或箭头键更改值。\nDebugger LazDebugger-FP (FpDebug) v1.0成为Windows和Linux默认的调试器。\nGDB(mo)使用修改版的GDB 9.2\n笔者补充：FpDebug无法调试dll，需要使用GDB\n组件 OpenGL全面支持Qt5的widgetset。\nTSpinEditEx 新属性ThousandSeparator允许显示插入了千位分隔符的值。\nTFloatSpinEditEx 支持以科学计数法形式的文本进行录入。\n新属性DisplayMode，用于控制是否使用科学记数法。\n新属性property控制以科学记数法显示值时使用的精度。\n还有其它许多更改，详细请看原文。","title":"Lazarus发布v2.2.6版本"},{"content":" 从其它平台迁移而来\n语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 gantt %注释 title 这是标题 %输入数据的时间格式 dateFormat YYYY-MM-DD %坐标轴的时间格式 axisFormat %m-%d %排除的时间 excludes weekends %坐标轴刻度，高版本支持 tickInterval 1day %是否显示当天的标记，默认on todayMarker off section 项目A %任务描述 : [任务状态,] [任务名称,] 开始时间, 时长或结束时间 任务1 : done, a1, 2023-03-01, 3d 任务2 : active, a2, after a1, 2023-03-08 里程碑 : milestone, a3, 2023-03-07, 1d section 项目B 任务1 : b1, 2023-03-07, 4000m 任务2 : crit, b2, after a2, 15h gantt %注释 title 这是标题 dateFormat YYYY-MM-DD axisFormat %m-%d excludes weekends %tickInterval 1day todayMarker off section 项目A 任务1 : done, a1, 2023-03-01, 3d 任务2 : active, a2, after a1, 2023-03-08 里程碑 : milestone, a3, 2023-03-07, 1d section 项目B 任务1 : b1, 2023-03-07, 4000m 任务2 : crit, b2, after a2, 15h 输入数据的时间格式 关键字dateFormat后的内容用于声明输入数据的时间格式，具体如下：\n标记 含义 YYYY 四位年 YY 两位年 M 无0补齐的月 MM 两位的月 D 无0补齐的日 DD 两位的日 H 无0补齐的时，24小时制 HH 两位的时，24小时制 h 无0补齐的时，12小时制 hh 两位的时，12小时制 m 无0补齐的分 mm 两位的分 s 无0补齐的秒 ss 两位的秒 Z ZZ UTC时区 坐标轴的时间格式 关键字axisFormat后的内容用于声明坐标轴的时间格式，具体如下：\n标记 含义 %Y 四位年 %y 两位年 %m 两位月 %d 0补齐的两位日 %e 空格补齐的两位日 %H 两位的时，24小时制 %I 两位的时，12小时制 %M 两位的分 %S 两位的秒 坐标轴刻度 关键字tickInterval后的内容用于设定坐标轴的时间刻度，由数字+单位组成：\n单位 含义 minute 分钟 hour 小时 day 天 week 周 month 月 排除的时间 关键字excludes后的内容用于设定排除的时间，weekends表示周末，多个时间用逗号,或空白 分隔。\n任务状态 状态 含义 done 已完成 active 激活，进行中 无 默认，未开始 crit 关键任务，可与其它叠加使用 里程碑 关键字milestone声明的任务为里程碑，实际显示的位置为任务时间段的正中间。\n","permalink":"https://afrusrsc.github.io/posts/other/mermaid_gantt/","summary":"从其它平台迁移而来\n语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 gantt %注释 title 这是标题 %输入数据的时间格式 dateFormat YYYY-MM-DD %坐标轴的时间格式 axisFormat %m-%d %排除的时间 excludes weekends %坐标轴刻度，高版本支持 tickInterval 1day %是否显示当天的标记，默认on todayMarker off section 项目A %任务描述 : [任务状态,] [任务名称,] 开始时间, 时长或结束时间 任务1 : done, a1, 2023-03-01, 3d 任务2 : active, a2, after a1, 2023-03-08 里程碑 : milestone, a3, 2023-03-07, 1d section 项目B 任务1 : b1, 2023-03-07, 4000m 任务2 : crit, b2, after a2, 15h gantt %注释 title 这是标题 dateFormat YYYY-MM-DD axisFormat %m-%d excludes weekends %tickInterval 1day todayMarker off section 项目A 任务1 : done, a1, 2023-03-01, 3d 任务2 : active, a2, after a1, 2023-03-08 里程碑 : milestone, a3, 2023-03-07, 1d section 项目B 任务1 : b1, 2023-03-07, 4000m 任务2 : crit, b2, after a2, 15h 输入数据的时间格式 关键字dateFormat后的内容用于声明输入数据的时间格式，具体如下：","title":"Mermaid学习笔记之——甘特图"},{"content":" 从其它平台迁移而来\n前言 做为一个桌面应用开发者，工作中一直使用的是Delphi（是语言，也是IDE，基于pascal语言），无论是经典的D7，还是现下最新的XE，都有着还算丰富的使用经验吧，虽然这两者都各有优缺点。做为团队开发成员之一，具体使用什么，几乎是没什么选择权的，毕竟公司有自己的技术栈，当然还有相应的技术债。\n但是，做为一个个人开发者，还是比较喜欢严谨的pascal语言的（其实Go的一些语法就是借鉴pascal的，比如：类型在变量右侧），而且还有着那么多年的开发经验，理论上来说，写个小工具啊什么的，还是应该选择熟悉的Delphi才是，但是Delphi并不符合个人的选择条件：\n不要太重量级\n有当前比较流行的特性\n有相对活跃的社区\nD7以现在的眼光来看，绝对算是足够轻量级的，整个环境（不含三方组件）安装完还不到1G，但是是毕竟是二十年前的东西了，不说新特性，一些陈年bug就够喝一壶了。\n相对来说，XE却是一直在更新着，新特性是有了，但是仅安装包就7~9G，只安装桌面开发必须的自带组件，安装完也有15G+，而且正版授权巨贵，社区版限制又巨多。\n至于有相对活跃的社区这条，国外应该还行，但对英文渣渣来说还是有点难了；而国内，Delphi都是快绝迹的语言了，当我什么都没说吧。\n所以，选来选去，也就只剩开源的Lazarus和CodeTyphon（基于Lazarus）了。原本是看中了CodeTyphon的，但是死活在Bug10上安装不成功，也就只能选Lazarus了，不过Lazarus倒也是越用越顺心了。\n虽说Lazarus标榜的一次编写，到处编译，不过，实际用到的几乎都是windows平台，至于其它平台，有机会再说吧。\n开发环境 以下以Lazarus 2.2.4为例。\n安装IDE Lazarus有32位版本和64位版本，而且都互相有对方架构的插件包，个人尝试后还是觉得分别安装两个版本比较合适（不要质疑，真的可以同时安装多个版本，不同架构、不同版本号都可以）。\n由于Bug10不愧是Bug10，所以个人还是喜欢整成免安装版本，万一哪天Bug10作妖，就不怕重新折腾了。\n在非系统盘下手动创建目录，比如D:\\lazarus和D:\\lazarus\\config，前者是IDE的安装目录，后者是IDE的配置目录\n下载并运行安装包\n在选择目标位置这一步时，选择之前手动创建的安装目录，同时勾选创建一个新的第二的安装（不要质疑，哪怕是第一次安装），下一步\n到选择配置文件夹这一步，选择之前手动创建的配置目录，然后一路下一步\n安装完之后，把安装目录备份一下，再把IDE卸载了，然后把安装目录恢复了（当然，这一步也可以不做）\n运行lazarus.exe，首次运行时（包括未来重装系统后）会弹出Welcom to Lazarus IDE的窗口，其中Fppkg项会有叹号（似乎是2.2版本之后才有的），点Restore Fppkg configuration，再点Write new configuration files，最后点Start IDE\n可以为lazarus.exe创建快捷方式\n至此，IDE就算是安装完了，需要的话可以把安装目录整个压缩备份，不过个人还是建议把IDE配置好了再备份\nIDE配置 构建配置 由于Lazarus每次安装三方组件都要重新build，如果三方组件装得多了，IDE的exe会很大（不是你自己写的exe），而个人又是比较喜欢小巧的，所以这一步是少不了的。\n菜单Tools-\u0026gt;Configure \u0026quot;Build Lazarus\u0026quot;\nProfile to build项选择Optimized IDE\n点Build会立即重新构建IDE；点Save Settings仅保存配置，下次构建时生效\n一体式窗口 安装完之后，IDE默认是D7那种分离式窗口，在小分辨率屏幕的时代很有用，不过现在嘛，个人感觉还是一体式窗口比较舒服。Lazarus已经提供了这样的包，只不过默认并没有启用。\n菜单Package-\u0026gt;Install/Uninstall Packages ...\n右侧选择AnchorDockingDsgn 1.0，点Install selection或双击\n点Save and rebuild IDE重新构建，IDE重启之后就是一体式的窗口了\n拖动子窗口的标题，会自动吸附，调整为自己喜欢的布局，重启IDE即可\n此时，若是不小心把布局调乱了，就不好恢复了，所以可以考虑把自动保存布局功能给关了：\n菜单Tools-\u0026gt;Desktops ...，去掉Auto save active desktop的勾，关闭 其它配置 菜单Tools-\u0026gt;Options ...是IDE集中的配置，可依自己习惯或喜好进行配置。不过，倒是可以分享些个人的配置及相应的考虑，以供参考：\n默认英文界面就挺好，毕竟中文翻译不全，也不够精准，万一需要去泡一下官方社区了，至少英文界面还能知道具体说的是哪儿\nEnvironment-\u0026gt;IDE CoolBar，选择第一个工具条，点Configure，把File menu commands下的New ...添加上【理由：默认工具条上只有新建普通单元和窗体，新建工程、模块、Frame等还要去菜单里点，不够快捷】\nEnvironment-\u0026gt;Backup，两个都选.~pp【理由：不管是工程还是单元，统一后缀名，方便用脚本清理，也方便加入版本库的忽略列表】\nEnvironment-\u0026gt;Naming，Default Pascal extension项选择.pp【理由：方便与Delphi的源码文件做区分】\nEditor-\u0026gt;Display，设置Show line numbers后的值为1【理由：每行都显示行号，方便与人交流/讨论代码】\nEditor-\u0026gt;Display-\u0026gt;Markup and Matches，勾选Matching Keywords下的Outline (global)【理由：代码块带上垂直线，方便区分嵌套关系】\nEditor-\u0026gt;Completion and Hints，勾选Auto remove empty methods【理由：保持代码整洁，减少误导】\nJCF Format Settings-\u0026gt;Clarify-\u0026gt;Comments，不勾选Remove empty '//' comments【理由：相信我，你一定会用得上//空注释的】\nDebugger-\u0026gt;Debugger backend，如果经常编写、调试dll的话，选择Gdb会比较合适，否则保持默认【理由：目前FpDebug不支持dll的调试】\n自带的第三方可选组件 上面的一体式窗口就是其中的一个组件包，其它组件包安装方法相同。这里简单介绍几个：\nh2paswizard 0.0：需要把C/C++的.h头文件转为pascal的.pas单元文件时会用到，不过就个人而言还是喜欢手撸来得精准\nLazActiveX 0.1：安装该包后才能安装基于ActiveX的组件，例如windows自带的TTS\nlazdeamon 0.9.9：编写windows 服务形式的应用了会用到\nlazvlc 1.0：VLC播放器的组件包，编写播放视频的应用了会用到，需要手动下载V2以上版本的libvlccore.dll和libvlc.dll\nweblaz 1.0：fpweb的组件包，不安装直接引用相关单元也可以\n官方远程仓库的第三方可选组件 菜单Package-\u0026gt;Online Package Manager ...可以下载/安装官方远程仓库收录的第三方可选组件，需要联网才能使用。也简单介绍几个：\nCEF4Delphi：谷歌浏览器内核，依赖DCPcrypt，同时需要手动下载版本号完全相同的一梭子二进制文件，所以还是直接去GitHub上下载吧\nDBTreeViewAndDBCntrlGrid：可从数据集中把树型数据直接显示为树，可以算做Lazarus默认的数据感知组件的扩充\nDCPcrypt：常用加密/解密算法包\nIndy10：Delphi上默认的经典的网络通讯组件包\nLNet：轻量级的网络通讯组件包，不过其UDP组件不能绑定发送端口，感觉莫名其妙\nMORMot：一个很牛的pascal语言的ORM框架\nPythonForLazarus：Python4Delphi的Lazarus版移植，懂的自然懂\n其它开源仓库的第三方组件 开源的实在是太多太多了……这里就只说一个个人觉得巨实用的：\ndataset-serialize：数据集与JSON序列化/反序列化的项目 ","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_ide_config/","summary":"从其它平台迁移而来\n前言 做为一个桌面应用开发者，工作中一直使用的是Delphi（是语言，也是IDE，基于pascal语言），无论是经典的D7，还是现下最新的XE，都有着还算丰富的使用经验吧，虽然这两者都各有优缺点。做为团队开发成员之一，具体使用什么，几乎是没什么选择权的，毕竟公司有自己的技术栈，当然还有相应的技术债。\n但是，做为一个个人开发者，还是比较喜欢严谨的pascal语言的（其实Go的一些语法就是借鉴pascal的，比如：类型在变量右侧），而且还有着那么多年的开发经验，理论上来说，写个小工具啊什么的，还是应该选择熟悉的Delphi才是，但是Delphi并不符合个人的选择条件：\n不要太重量级\n有当前比较流行的特性\n有相对活跃的社区\nD7以现在的眼光来看，绝对算是足够轻量级的，整个环境（不含三方组件）安装完还不到1G，但是是毕竟是二十年前的东西了，不说新特性，一些陈年bug就够喝一壶了。\n相对来说，XE却是一直在更新着，新特性是有了，但是仅安装包就7~9G，只安装桌面开发必须的自带组件，安装完也有15G+，而且正版授权巨贵，社区版限制又巨多。\n至于有相对活跃的社区这条，国外应该还行，但对英文渣渣来说还是有点难了；而国内，Delphi都是快绝迹的语言了，当我什么都没说吧。\n所以，选来选去，也就只剩开源的Lazarus和CodeTyphon（基于Lazarus）了。原本是看中了CodeTyphon的，但是死活在Bug10上安装不成功，也就只能选Lazarus了，不过Lazarus倒也是越用越顺心了。\n虽说Lazarus标榜的一次编写，到处编译，不过，实际用到的几乎都是windows平台，至于其它平台，有机会再说吧。\n开发环境 以下以Lazarus 2.2.4为例。\n安装IDE Lazarus有32位版本和64位版本，而且都互相有对方架构的插件包，个人尝试后还是觉得分别安装两个版本比较合适（不要质疑，真的可以同时安装多个版本，不同架构、不同版本号都可以）。\n由于Bug10不愧是Bug10，所以个人还是喜欢整成免安装版本，万一哪天Bug10作妖，就不怕重新折腾了。\n在非系统盘下手动创建目录，比如D:\\lazarus和D:\\lazarus\\config，前者是IDE的安装目录，后者是IDE的配置目录\n下载并运行安装包\n在选择目标位置这一步时，选择之前手动创建的安装目录，同时勾选创建一个新的第二的安装（不要质疑，哪怕是第一次安装），下一步\n到选择配置文件夹这一步，选择之前手动创建的配置目录，然后一路下一步\n安装完之后，把安装目录备份一下，再把IDE卸载了，然后把安装目录恢复了（当然，这一步也可以不做）\n运行lazarus.exe，首次运行时（包括未来重装系统后）会弹出Welcom to Lazarus IDE的窗口，其中Fppkg项会有叹号（似乎是2.2版本之后才有的），点Restore Fppkg configuration，再点Write new configuration files，最后点Start IDE\n可以为lazarus.exe创建快捷方式\n至此，IDE就算是安装完了，需要的话可以把安装目录整个压缩备份，不过个人还是建议把IDE配置好了再备份\nIDE配置 构建配置 由于Lazarus每次安装三方组件都要重新build，如果三方组件装得多了，IDE的exe会很大（不是你自己写的exe），而个人又是比较喜欢小巧的，所以这一步是少不了的。\n菜单Tools-\u0026gt;Configure \u0026quot;Build Lazarus\u0026quot;\nProfile to build项选择Optimized IDE\n点Build会立即重新构建IDE；点Save Settings仅保存配置，下次构建时生效\n一体式窗口 安装完之后，IDE默认是D7那种分离式窗口，在小分辨率屏幕的时代很有用，不过现在嘛，个人感觉还是一体式窗口比较舒服。Lazarus已经提供了这样的包，只不过默认并没有启用。\n菜单Package-\u0026gt;Install/Uninstall Packages ...\n右侧选择AnchorDockingDsgn 1.0，点Install selection或双击\n点Save and rebuild IDE重新构建，IDE重启之后就是一体式的窗口了\n拖动子窗口的标题，会自动吸附，调整为自己喜欢的布局，重启IDE即可\n此时，若是不小心把布局调乱了，就不好恢复了，所以可以考虑把自动保存布局功能给关了：\n菜单Tools-\u0026gt;Desktops ...，去掉Auto save active desktop的勾，关闭 其它配置 菜单Tools-\u0026gt;Options ...是IDE集中的配置，可依自己习惯或喜好进行配置。不过，倒是可以分享些个人的配置及相应的考虑，以供参考：","title":"Lazarus开发环境配置"},{"content":" 从其它平台迁移而来\n在客户端不需要证书的情况下，简单两步操作即可让TFPHTTPClient实现https的请求：\n在源码中引用opensslsockets单元\n在生成目录下加入动态库libcrypto-1_1.dll和libssl-1_1.dll\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_fphttpclient_https/","summary":"从其它平台迁移而来\n在客户端不需要证书的情况下，简单两步操作即可让TFPHTTPClient实现https的请求：\n在源码中引用opensslsockets单元\n在生成目录下加入动态库libcrypto-1_1.dll和libssl-1_1.dll","title":"FPHTTPClient请求https"},{"content":" 从其它平台迁移而来\n语法 1 2 3 4 5 6 7 --- title: 流程图名称 # 可能会有渲染不支持 --- graph/flowchart [TB/TD|BT|LR|RL] 节点名即内容 节点名1[节点内容] 节点名2[\u0026#34;节点内容\u0026#34;] graph 节点名即内容 节点名1[节点内容] 节点名2[\"带引号节点内容\"] 节点 1 2 graph 默认节点 graph 默认节点 1 2 graph a1[矩形] graph a1[矩形] 1 2 graph a2(圆角矩形) graph a2(圆角矩形) 1 2 graph a3{菱形} graph a3{菱形} 1 2 graph a4((圆形)) graph a4((圆形)) 1 2 graph a5\u0026gt;旗形] graph a5\u003e旗形] 1 2 graph a6{{尖端矩形}} graph a6{{尖端矩形}} 1 2 graph a7([圆端矩形]) graph a7([圆端矩形]) 1 2 graph a8[\\平行四边形1\\] graph a8[\\平行四边形1\\] 1 2 graph a9[/平行四边形2/] graph a9[/平行四边形2/] 1 2 graph a10[/梯形1\\] graph a10[/梯形1\\] 1 2 graph a11[\\梯形2/] graph a11[\\梯形2/] 1 2 graph a12[[子程序]] graph a12[[子程序]] 1 2 graph a13[(圆柱形)] graph a13[(圆柱形)] 1 2 graph a14(((双圆))) # 高版本渲染支持 graph a14(((双圆))) 布局 标识 含义 备注 TB/TD 从上到下 默认 BT 从下到上 LR 从左到右 RL 从右到左 TB/TD graph a --\u003e b BT graph BT a --\u003e b LR graph LR a --\u003e b RL graph RL a --\u003e b 连线 普通连线 线形 1单位长 2单位长 3单位长 细实线 --- ---- ----- 细实线箭头 --\u0026gt; ---\u0026gt; ----\u0026gt; 粗实线 === ==== ===== 粗实线箭头 ==\u0026gt; ===\u0026gt; ====\u0026gt; 虚线 -.- -..- -...- 虚线箭头 -.-\u0026gt; -..-\u0026gt; -...-\u0026gt; --- graph LR a --- b ---- graph LR a ---- b ----- graph LR a ----- b --\u0026gt; graph LR a --\u003e b === graph LR a === b ==\u0026gt; graph LR a ==\u003e b -.- graph LR a -.- b -.-\u0026gt; graph LR a -.-\u003e b 箭头 --\u0026gt;三角箭头 graph LR a --\u003e b --o圆点箭头 graph LR a --o b --x叉箭头 graph LR a --x b \u0026lt;--\u0026gt;两端三角箭头 graph LR a \u003c--\u003e b o--o两端圆点箭头 graph LR a o--o b x--x两端叉箭头 graph LR a x--x b 带文字连线 --\u0026gt;|文字| graph LR a --\u003e|文字| b -- 文字 --\u0026gt; graph LR a -- 文字 --\u003e b 子图 语法 1 2 3 4 subgraph 子图名 direction [TB/TD|BT|LR|RL] # 子图中的方向 子图内容 end 1 2 3 4 5 6 7 8 9 --- title: 子图示例 --- graph LR subgraph s direction BT a --\u0026gt; b end s ==\u0026gt; c graph LR subgraph s direction BT a --\u003e b end s ==\u003e c ","permalink":"https://afrusrsc.github.io/posts/other/mermaid_graph/","summary":"从其它平台迁移而来\n语法 1 2 3 4 5 6 7 --- title: 流程图名称 # 可能会有渲染不支持 --- graph/flowchart [TB/TD|BT|LR|RL] 节点名即内容 节点名1[节点内容] 节点名2[\u0026#34;节点内容\u0026#34;] graph 节点名即内容 节点名1[节点内容] 节点名2[\"带引号节点内容\"] 节点 1 2 graph 默认节点 graph 默认节点 1 2 graph a1[矩形] graph a1[矩形] 1 2 graph a2(圆角矩形) graph a2(圆角矩形) 1 2 graph a3{菱形} graph a3{菱形} 1 2 graph a4((圆形)) graph a4((圆形)) 1 2 graph a5\u0026gt;旗形] graph a5\u003e旗形] 1 2 graph a6{{尖端矩形}} graph a6{{尖端矩形}} 1 2 graph a7([圆端矩形]) graph a7([圆端矩形]) 1 2 graph a8[\\平行四边形1\\] graph a8[\\平行四边形1\\] 1 2 graph a9[/平行四边形2/] graph a9[/平行四边形2/] 1 2 graph a10[/梯形1\\] graph a10[/梯形1\\] 1 2 graph a11[\\梯形2/] graph a11[\\梯形2/] 1 2 graph a12[[子程序]] graph a12[[子程序]] 1 2 graph a13[(圆柱形)] graph a13[(圆柱形)] 1 2 graph a14(((双圆))) # 高版本渲染支持 graph a14(((双圆))) 布局 标识 含义 备注 TB/TD 从上到下 默认 BT 从下到上 LR 从左到右 RL 从右到左 TB/TD graph a --\u003e b BT graph BT a --\u003e b LR graph LR a --\u003e b RL graph RL a --\u003e b 连线 普通连线 线形 1单位长 2单位长 3单位长 细实线 --- ---- ----- 细实线箭头 --\u0026gt; ---\u0026gt; ----\u0026gt; 粗实线 === ==== ===== 粗实线箭头 ==\u0026gt; ===\u0026gt; ====\u0026gt; 虚线 -.","title":"Mermaid学习笔记之——流程图"},{"content":" 从其它平台迁移而来\n一直比较喜欢用Markdown格式写点东西，如：记笔记、列计划等。但是当需要在Markdown中插入一些图片时，尤其是那些会经常发生变动的图片时（例如：流程图），简直痛不欲生，因为需要重新用工具修改图片后再链接进Markdown里。\n如果能直接在Markdown里编写并生成图片，简直不要太开心。所幸这个问题已经有大佬给出了解决方案，那就是Mermaid。\n个人理解：Mermaid是一种类似于Markdown中代码块高亮渲染的东西，可以把特定的纯文本渲染成对应的图片（流程图等）。Mermaid仅仅是一种渲染，并非Markdown的原生语法，所以，能不能看到图片以及图片最终呈现的样子，还要看对应的编辑器或页面是否对Mermaid进行支持及具体的渲染实现。\n语法 在Markdown中嵌入Mermaid，语法与嵌入代码块的语法类似，即原先写c、java等的地方写为mermaid，之间写上具体的Mermaid内容即可。\n1 2 3 4 ```mermaid # 开始 graph TD # 类型 Start --\u0026gt; Stop # 具体内容 ``` # 结束 经渲染后如下：\ngraph TD Start --\u003e Stop 分类 1. 流程图 见上面的示例。\n2. 时序图 1 2 3 4 sequenceDiagram Alice-\u0026gt;\u0026gt;John: Hello John, how are you? John--\u0026gt;\u0026gt;Alice: Great! Alice-)John: See you later! sequenceDiagram Alice-\u003e\u003eJohn: Hello John, how are you? John--\u003e\u003eAlice: Great! Alice-)John: See you later! 3. 类图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 classDiagram Animal \u0026lt;|-- Duck Animal \u0026lt;|-- Fish Animal \u0026lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } 4. 状态图 1 2 3 4 5 6 7 8 stateDiagram-v2 [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] stateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] 5. 关系图 1 2 3 4 erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses 6. 旅程图 1 2 3 4 5 6 7 8 9 journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me 7. 甘特图 1 2 3 4 5 6 7 8 9 gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d 8. 饼图 1 2 3 4 pie title Pets adopted by volunteers \u0026#34;Dogs\u0026#34; : 386 \u0026#34;Cats\u0026#34; : 85 \u0026#34;Rats\u0026#34; : 15 pie title Pets adopted by volunteers \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 9. 需求图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } element test_entity { type: simulation } test_entity - satisfies -\u0026gt; test_req requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } element test_entity { type: simulation } test_entity - satisfies -\u003e test_req 10. git提交图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 --- title: Example Git diagram --- gitGraph commit commit branch develop checkout develop commit commit checkout main merge develop commit commit --- title: Example Git diagram --- gitGraph commit commit branch develop checkout develop commit commit checkout main merge develop commit commit 11. C4图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 C4Context title System Context diagram for Internet Banking System Enterprise_Boundary(b0, \u0026#34;BankBoundary0\u0026#34;) { Person(customerA, \u0026#34;Banking Customer A\u0026#34;, \u0026#34;A customer of the bank, with personal bank accounts.\u0026#34;) Person(customerB, \u0026#34;Banking Customer B\u0026#34;) Person_Ext(customerC, \u0026#34;Banking Customer C\u0026#34;, \u0026#34;desc\u0026#34;) Person(customerD, \u0026#34;Banking Customer D\u0026#34;, \u0026#34;A customer of the bank, \u0026lt;br/\u0026gt; with personal bank accounts.\u0026#34;) System(SystemAA, \u0026#34;Internet Banking System\u0026#34;, \u0026#34;Allows customers to view information about their bank accounts, and make payments.\u0026#34;) Enterprise_Boundary(b1, \u0026#34;BankBoundary\u0026#34;) { SystemDb_Ext(SystemE, \u0026#34;Mainframe Banking System\u0026#34;, \u0026#34;Stores all of the core banking information about customers, accounts, transactions, etc.\u0026#34;) System_Boundary(b2, \u0026#34;BankBoundary2\u0026#34;) { System(SystemA, \u0026#34;Banking System A\u0026#34;) System(SystemB, \u0026#34;Banking System B\u0026#34;, \u0026#34;A system of the bank, with personal bank accounts. next line.\u0026#34;) } System_Ext(SystemC, \u0026#34;E-mail system\u0026#34;, \u0026#34;The internal Microsoft Exchange e-mail system.\u0026#34;) SystemDb(SystemD, \u0026#34;Banking System D Database\u0026#34;, \u0026#34;A system of the bank, with personal bank accounts.\u0026#34;) Boundary(b3, \u0026#34;BankBoundary3\u0026#34;, \u0026#34;boundary\u0026#34;) { SystemQueue(SystemF, \u0026#34;Banking System F Queue\u0026#34;, \u0026#34;A system of the bank.\u0026#34;) SystemQueue_Ext(SystemG, \u0026#34;Banking System G Queue\u0026#34;, \u0026#34;A system of the bank, with personal bank accounts.\u0026#34;) } } } BiRel(customerA, SystemAA, \u0026#34;Uses\u0026#34;) BiRel(SystemAA, SystemE, \u0026#34;Uses\u0026#34;) Rel(SystemAA, SystemC, \u0026#34;Sends e-mails\u0026#34;, \u0026#34;SMTP\u0026#34;) Rel(SystemC, customerA, \u0026#34;Sends e-mails to\u0026#34;) UpdateElementStyle(customerA, $fontColor=\u0026#34;red\u0026#34;, $bgColor=\u0026#34;grey\u0026#34;, $borderColor=\u0026#34;red\u0026#34;) UpdateRelStyle(customerA, SystemAA, $textColor=\u0026#34;blue\u0026#34;, $lineColor=\u0026#34;blue\u0026#34;, $offsetX=\u0026#34;5\u0026#34;) UpdateRelStyle(SystemAA, SystemE, $textColor=\u0026#34;blue\u0026#34;, $lineColor=\u0026#34;blue\u0026#34;, $offsetY=\u0026#34;-10\u0026#34;) UpdateRelStyle(SystemAA, SystemC, $textColor=\u0026#34;blue\u0026#34;, $lineColor=\u0026#34;blue\u0026#34;, $offsetY=\u0026#34;-40\u0026#34;, $offsetX=\u0026#34;-50\u0026#34;) UpdateRelStyle(SystemC, customerA, $textColor=\u0026#34;red\u0026#34;, $lineColor=\u0026#34;red\u0026#34;, $offsetX=\u0026#34;-50\u0026#34;, $offsetY=\u0026#34;20\u0026#34;) UpdateLayoutConfig($c4ShapeInRow=\u0026#34;3\u0026#34;, $c4BoundaryInRow=\u0026#34;1\u0026#34;) C4Context title System Context diagram for Internet Banking System Enterprise_Boundary(b0, \"BankBoundary0\") { Person(customerA, \"Banking Customer A\", \"A customer of the bank, with personal bank accounts.\") Person(customerB, \"Banking Customer B\") Person_Ext(customerC, \"Banking Customer C\", \"desc\") Person(customerD, \"Banking Customer D\", \"A customer of the bank, with personal bank accounts.\") System(SystemAA, \"Internet Banking System\", \"Allows customers to view information about their bank accounts, and make payments.\") Enterprise_Boundary(b1, \"BankBoundary\") { SystemDb_Ext(SystemE, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\") System_Boundary(b2, \"BankBoundary2\") { System(SystemA, \"Banking System A\") System(SystemB, \"Banking System B\", \"A system of the bank, with personal bank accounts. next line.\") } System_Ext(SystemC, \"E-mail system\", \"The internal Microsoft Exchange e-mail system.\") SystemDb(SystemD, \"Banking System D Database\", \"A system of the bank, with personal bank accounts.\") Boundary(b3, \"BankBoundary3\", \"boundary\") { SystemQueue(SystemF, \"Banking System F Queue\", \"A system of the bank.\") SystemQueue_Ext(SystemG, \"Banking System G Queue\", \"A system of the bank, with personal bank accounts.\") } } } BiRel(customerA, SystemAA, \"Uses\") BiRel(SystemAA, SystemE, \"Uses\") Rel(SystemAA, SystemC, \"Sends e-mails\", \"SMTP\") Rel(SystemC, customerA, \"Sends e-mails to\") UpdateElementStyle(customerA, $fontColor=\"red\", $bgColor=\"grey\", $borderColor=\"red\") UpdateRelStyle(customerA, SystemAA, $textColor=\"blue\", $lineColor=\"blue\", $offsetX=\"5\") UpdateRelStyle(SystemAA, SystemE, $textColor=\"blue\", $lineColor=\"blue\", $offsetY=\"-10\") UpdateRelStyle(SystemAA, SystemC, $textColor=\"blue\", $lineColor=\"blue\", $offsetY=\"-40\", $offsetX=\"-50\") UpdateRelStyle(SystemC, customerA, $textColor=\"red\", $lineColor=\"red\", $offsetX=\"-50\", $offsetY=\"20\") UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\") 12. 思维导图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 mindmap root((mindmap)) Origins Long history ::icon(fa fa-book) Popularisation British popular psychology author Tony Buzan Research On effectiveness\u0026lt;br/\u0026gt;and features On Automatic creation Uses Creative techniques Strategic planning Argument mapping Tools Pen and paper Mermaid mindmap root((mindmap)) Origins Long history ::icon(fa fa-book) Popularisation British popular psychology author Tony Buzan Research On effectivenessand features On Automatic creation Uses Creative techniques Strategic planning Argument mapping Tools Pen and paper Mermaid 图片能否正常显示，还要看具体的Mermaid实现版本。\n","permalink":"https://afrusrsc.github.io/posts/other/mermaid/","summary":"从其它平台迁移而来\n一直比较喜欢用Markdown格式写点东西，如：记笔记、列计划等。但是当需要在Markdown中插入一些图片时，尤其是那些会经常发生变动的图片时（例如：流程图），简直痛不欲生，因为需要重新用工具修改图片后再链接进Markdown里。\n如果能直接在Markdown里编写并生成图片，简直不要太开心。所幸这个问题已经有大佬给出了解决方案，那就是Mermaid。\n个人理解：Mermaid是一种类似于Markdown中代码块高亮渲染的东西，可以把特定的纯文本渲染成对应的图片（流程图等）。Mermaid仅仅是一种渲染，并非Markdown的原生语法，所以，能不能看到图片以及图片最终呈现的样子，还要看对应的编辑器或页面是否对Mermaid进行支持及具体的渲染实现。\n语法 在Markdown中嵌入Mermaid，语法与嵌入代码块的语法类似，即原先写c、java等的地方写为mermaid，之间写上具体的Mermaid内容即可。\n1 2 3 4 ```mermaid # 开始 graph TD # 类型 Start --\u0026gt; Stop # 具体内容 ``` # 结束 经渲染后如下：\ngraph TD Start --\u003e Stop 分类 1. 流程图 见上面的示例。\n2. 时序图 1 2 3 4 sequenceDiagram Alice-\u0026gt;\u0026gt;John: Hello John, how are you? John--\u0026gt;\u0026gt;Alice: Great! Alice-)John: See you later! sequenceDiagram Alice-\u003e\u003eJohn: Hello John, how are you? John--\u003e\u003eAlice: Great! Alice-)John: See you later! 3. 类图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 classDiagram Animal \u0026lt;|-- Duck Animal \u0026lt;|-- Fish Animal \u0026lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } 4.","title":"Mermaid学习笔记之——初识"},{"content":" 从其它平台迁移而来\n环境 Lazarus v2.2.4(32位/64位)\nMySQL 8.0.31 64位\nPostgreSQL 15.1 64位\n坑 MySQL Lazarus v2.2.4已内置MySQL8.0的TMySQL80Connection组件，但是连接时却提示Can not load MySQL library \u0026quot;libmysql.dll\u0026quot;. Please check your installation.使用64位编译，放进64位MySQL8.0.31的libmysql.dll仍然报该错，一直到把版本降到5.7系列才正常，换32位编译，同样的结果：使用5.7系列的libmysql.dll可正常使用。\nPostgreSQL 连接PostgreSQL时，同样遇到与MySQL类似的报错：Can not load PostgreSQL client library \u0026quot;libpq.dll\u0026quot;. Check your installation.按照与MySQL相同的思路，版本从15.1一直降到目前支持的最低版本9.2.24，仍然报错！\n查一下官方论坛，各种方式试了一通，发现64位的程序除libpq.dll外，v11+还需要libcrypto-3-x64.dll、libiconv-2.dll、libintl-9.dll、libssl-3-x64.dll和libwinpthread-1.dll；v9.4~v10.23还需要libcrypto-1_1-x64.dll、libiconv-2.dll、libintl-8.dll、libssl-1_1-x64.dll。\n而32位程序，最高可用版本为v10.23，除libpq.dll外，还需要libcrypto-1_1.dll、libiconv-2.dll、libintl-8.dll、libssl-1_1.dll，必要时可能还需要VC运行时。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_connection/","summary":"从其它平台迁移而来\n环境 Lazarus v2.2.4(32位/64位)\nMySQL 8.0.31 64位\nPostgreSQL 15.1 64位\n坑 MySQL Lazarus v2.2.4已内置MySQL8.0的TMySQL80Connection组件，但是连接时却提示Can not load MySQL library \u0026quot;libmysql.dll\u0026quot;. Please check your installation.使用64位编译，放进64位MySQL8.0.31的libmysql.dll仍然报该错，一直到把版本降到5.7系列才正常，换32位编译，同样的结果：使用5.7系列的libmysql.dll可正常使用。\nPostgreSQL 连接PostgreSQL时，同样遇到与MySQL类似的报错：Can not load PostgreSQL client library \u0026quot;libpq.dll\u0026quot;. Check your installation.按照与MySQL相同的思路，版本从15.1一直降到目前支持的最低版本9.2.24，仍然报错！\n查一下官方论坛，各种方式试了一通，发现64位的程序除libpq.dll外，v11+还需要libcrypto-3-x64.dll、libiconv-2.dll、libintl-9.dll、libssl-3-x64.dll和libwinpthread-1.dll；v9.4~v10.23还需要libcrypto-1_1-x64.dll、libiconv-2.dll、libintl-8.dll、libssl-1_1-x64.dll。\n而32位程序，最高可用版本为v10.23，除libpq.dll外，还需要libcrypto-1_1.dll、libiconv-2.dll、libintl-8.dll、libssl-1_1.dll，必要时可能还需要VC运行时。","title":"Lazarus连数据库的那点坑"},{"content":" 从其它平台迁移而来\n事件 计划做一个插件式的桌面应用框架，一方面练练手，另一方面算是自身的技术积累吧。\n在练手过程中，发现一个巨难受的问题，dll卸载不掉，程序直接假死！\n虽然可以不直接调用卸载，依赖主程序退出时卸载的特性，但做为插件式应用，必须能在运行中加载/卸载才算完整。即便不是插件式应用，dll的正常卸载也应该是很常用的功能，现在不正常，那么一定是代码写得有问题。\n写了测试Demo，一行一行加代码，结果都能正常卸载，这就杯具了……测试了无数次，直到想把每一步都输出到日志时，dll无法卸载了。一点点分析源码后，发现很可能是日志中为了方便使用，加的initialization节和finalization节导致的，注释掉之后就真的正常了。\n分析 initialization节应该是在Application.Initialize;时执行的，finalization节应该是在Application.Terminate;之后的某个时间点执行的（具体执行时机没深入研究过）。而我的dll是要做成插件的，不可避免会有可视化窗体，所以Application.Initialize;不可避免（Lazarus是这样，Delphi不是），而在initialization节中创建了日志记录器实例，在finalization节中进行释放，这样，在卸载dll时就出现了锁死的情况：卸载时有内存（实例）未释放，需要等内存释放了才能完全卸载，而未卸载又导致执行不到finalization节，就不能释放实例……于是，dll无法卸载，程序就进入假死状态。\n以上只是初步分析，鉴于对底层机制了解不深，可能分析不完全正确，甚至是错误的。\n结论 在编写的dll中不要在initialization节和finalization节中进行内存管理的工作。 对于无对象、纯函数式的dll，initialization节和finalization节会不会产生影响尚未测试，目前也暂无这方面需求，待以后遇到了再详细测试吧。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_dll_unload/","summary":"从其它平台迁移而来\n事件 计划做一个插件式的桌面应用框架，一方面练练手，另一方面算是自身的技术积累吧。\n在练手过程中，发现一个巨难受的问题，dll卸载不掉，程序直接假死！\n虽然可以不直接调用卸载，依赖主程序退出时卸载的特性，但做为插件式应用，必须能在运行中加载/卸载才算完整。即便不是插件式应用，dll的正常卸载也应该是很常用的功能，现在不正常，那么一定是代码写得有问题。\n写了测试Demo，一行一行加代码，结果都能正常卸载，这就杯具了……测试了无数次，直到想把每一步都输出到日志时，dll无法卸载了。一点点分析源码后，发现很可能是日志中为了方便使用，加的initialization节和finalization节导致的，注释掉之后就真的正常了。\n分析 initialization节应该是在Application.Initialize;时执行的，finalization节应该是在Application.Terminate;之后的某个时间点执行的（具体执行时机没深入研究过）。而我的dll是要做成插件的，不可避免会有可视化窗体，所以Application.Initialize;不可避免（Lazarus是这样，Delphi不是），而在initialization节中创建了日志记录器实例，在finalization节中进行释放，这样，在卸载dll时就出现了锁死的情况：卸载时有内存（实例）未释放，需要等内存释放了才能完全卸载，而未卸载又导致执行不到finalization节，就不能释放实例……于是，dll无法卸载，程序就进入假死状态。\n以上只是初步分析，鉴于对底层机制了解不深，可能分析不完全正确，甚至是错误的。\n结论 在编写的dll中不要在initialization节和finalization节中进行内存管理的工作。 对于无对象、纯函数式的dll，initialization节和finalization节会不会产生影响尚未测试，目前也暂无这方面需求，待以后遇到了再详细测试吧。","title":"Lazarus的dll卸载问题"},{"content":" 从其它平台迁移而来\n最近在研究Lazarus写dll，已经踩了不少坑了，这下又踩了个不大不小的坑，记录下。\n问题 在dll工程里，断点失效，根本没办法调试 解决方案 网上查了N多资料，个中辛酸在此不表，终于找到些蛛丝马迹。\nLazarus在windows上默认使用的是FpDebug内置的Dwarf，这货本身就不支持在dll中调试，法了个克！切换为gdb，立马OK！\n不过，据说gdb在windows上有bug，这……反正FpDebug的bug遇到了也不是一个两个了，先用着再说。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_debug/","summary":"从其它平台迁移而来\n最近在研究Lazarus写dll，已经踩了不少坑了，这下又踩了个不大不小的坑，记录下。\n问题 在dll工程里，断点失效，根本没办法调试 解决方案 网上查了N多资料，个中辛酸在此不表，终于找到些蛛丝马迹。\nLazarus在windows上默认使用的是FpDebug内置的Dwarf，这货本身就不支持在dll中调试，法了个克！切换为gdb，立马OK！\n不过，据说gdb在windows上有bug，这……反正FpDebug的bug遇到了也不是一个两个了，先用着再说。","title":"Lazarus debug的坑"},{"content":" 从其它平台迁移而来\n之前用lazarus编写了使用IInterface的dll，可惜没有成功。当把IInterface编译到exe里时，功能正常，编译到dll里再在exe里调用就不正常，原因未深究，不过大致也知道是哪一类问题，至于还有没有其它问题，暂未可知。\n闲来有空，有写了点Demo来，有了不少新发现，在此记录下：\n只有使用exports导出的函数才能在dll外部调用\n只有使用stdcall修饰的函数传参规则才与标准C的传参规则相同，其它遵守标准C传参规则的语言可以正常调用；否则，只有lazarus编写的程序可以正常调用\n入参为string类型时，无论是否使用stdcall修饰，lazarus编写的程序调用正常，其它语言未测试\n返回值或出参为string类型时，调用报External: ACCESS VIOLATION错误；但参数为PChar时，调用正常\n入参/出参/返回值为结构体时，调用正常\nstring类型传参是指针/引用拷贝，结构体传参是值拷贝\nstring做入参时，由主调函数分配内存并增加引用计数，被调函数执行时再次增加引用计数，被调函数结束时减少引用计数，此时引用计数不为0不释放内存，主调函数结束时再次减少引用计数，引用计数为0释放内存，该内存由exe分配，因此释放不报错；做出参时，由被调函数执行时分配内存并增加引用计数，被调函数返回时先赋值给主调函数的变量，增加引用计数，再结束被调函数，减少引用计数，主调函数结束时再次减少引用计数，此时引用计数为0释放内存，但该内存是由dll分配，因此产生External: ACCESS VIOLATION错误\nstring类型不适合在dll和exe之间传参（尤其是出参）\n返回值为对象时，调用异常；入参/出参为exe创建的对象时，调用正常\n结论 根据测试得出的结论，可能不严谨：\n指针做为形参（入参/出参）传递没有问题，但必须遵守谁创建谁释放的原则；指针做为返回值可能会有隐患\n对象传参实际传的是对象的指针，规则与指针相同\n返回值适合传递值拷贝的类型，如整型、浮点型、布尔型、结构体、指针（但指针指向的内存要遵守谁创建谁释放的原则，不过一般不直接使用）等\n字符串、结构体的生命周期是由编译器维护的，使用需慎重\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_dll_api/","summary":"从其它平台迁移而来\n之前用lazarus编写了使用IInterface的dll，可惜没有成功。当把IInterface编译到exe里时，功能正常，编译到dll里再在exe里调用就不正常，原因未深究，不过大致也知道是哪一类问题，至于还有没有其它问题，暂未可知。\n闲来有空，有写了点Demo来，有了不少新发现，在此记录下：\n只有使用exports导出的函数才能在dll外部调用\n只有使用stdcall修饰的函数传参规则才与标准C的传参规则相同，其它遵守标准C传参规则的语言可以正常调用；否则，只有lazarus编写的程序可以正常调用\n入参为string类型时，无论是否使用stdcall修饰，lazarus编写的程序调用正常，其它语言未测试\n返回值或出参为string类型时，调用报External: ACCESS VIOLATION错误；但参数为PChar时，调用正常\n入参/出参/返回值为结构体时，调用正常\nstring类型传参是指针/引用拷贝，结构体传参是值拷贝\nstring做入参时，由主调函数分配内存并增加引用计数，被调函数执行时再次增加引用计数，被调函数结束时减少引用计数，此时引用计数不为0不释放内存，主调函数结束时再次减少引用计数，引用计数为0释放内存，该内存由exe分配，因此释放不报错；做出参时，由被调函数执行时分配内存并增加引用计数，被调函数返回时先赋值给主调函数的变量，增加引用计数，再结束被调函数，减少引用计数，主调函数结束时再次减少引用计数，此时引用计数为0释放内存，但该内存是由dll分配，因此产生External: ACCESS VIOLATION错误\nstring类型不适合在dll和exe之间传参（尤其是出参）\n返回值为对象时，调用异常；入参/出参为exe创建的对象时，调用正常\n结论 根据测试得出的结论，可能不严谨：\n指针做为形参（入参/出参）传递没有问题，但必须遵守谁创建谁释放的原则；指针做为返回值可能会有隐患\n对象传参实际传的是对象的指针，规则与指针相同\n返回值适合传递值拷贝的类型，如整型、浮点型、布尔型、结构体、指针（但指针指向的内存要遵守谁创建谁释放的原则，不过一般不直接使用）等\n字符串、结构体的生命周期是由编译器维护的，使用需慎重","title":"Lazarus编写dll与接口注意事项小结"},{"content":" 从其它平台迁移而来\n老坑 *.frf是FastReport 2.x的报表模板，现维护的老项目中有使用到该报表。\n问题描述 报表通过数据集DS和报表变量V1、V2、V3等获取数据，并在模板中进行展示。\n单独展示数据集中的某个字段：[DS.\u0026quot;D1\u0026quot;]\n展示数据集中的某两个字段的运算结果：[[DS.\u0026quot;D1\u0026quot;]+[DS.\u0026quot;D2\u0026quot;]]\n单独展示某个变量：[V1]\n展示数据集中的某个字段与变量的运算结果：[[DS.\u0026quot;D1\u0026quot;]+[V2]]\n以上都是没有问题的，但当需要展示两个变量的运算结果时就不行了，[V1]+[V2]实际展示的是两个变量的字符串连接，因为报表变量本来就是字符串。查看模板其它写法，发现有使用尖括号\u0026lt;\u0026gt;的，尝试后也不行，[V1]+\u0026lt;V2\u0026gt;实际展示的只有V2的值。\n由于报表变量本身就是字符串，想着通过数据类型转换来解决，但非常遗憾，报表没有提供把字符串转为数值的函数。\n实在不行就只能考虑在代码中计算完之后再赋值给报表变量了，但这样就牺牲了报表的灵活性了，乃是没有办法的最后的办法了。\n最后灵光一现，既然数据集字段与变量可以运算，那加个0是不是也可以运算？一试果然可行！\n结果 展示某两个变量的运算结果：[0+[V1]+[V2]-[V3]] 问题解决了，不过总感觉是个偏方，不晓得正统的解决方案是什么。\n不过话说回来，FastReport 2.x已经很古老了，除了老项目维护基本不可能会用到，因为现在连FastReport 3+用得都很少了，毕竟现在已经是什么乱七八糟的牛鬼蛇神都有的元宇宙时代了，能解决问题就好。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/fastreport_frf_calc/","summary":"从其它平台迁移而来\n老坑 *.frf是FastReport 2.x的报表模板，现维护的老项目中有使用到该报表。\n问题描述 报表通过数据集DS和报表变量V1、V2、V3等获取数据，并在模板中进行展示。\n单独展示数据集中的某个字段：[DS.\u0026quot;D1\u0026quot;]\n展示数据集中的某两个字段的运算结果：[[DS.\u0026quot;D1\u0026quot;]+[DS.\u0026quot;D2\u0026quot;]]\n单独展示某个变量：[V1]\n展示数据集中的某个字段与变量的运算结果：[[DS.\u0026quot;D1\u0026quot;]+[V2]]\n以上都是没有问题的，但当需要展示两个变量的运算结果时就不行了，[V1]+[V2]实际展示的是两个变量的字符串连接，因为报表变量本来就是字符串。查看模板其它写法，发现有使用尖括号\u0026lt;\u0026gt;的，尝试后也不行，[V1]+\u0026lt;V2\u0026gt;实际展示的只有V2的值。\n由于报表变量本身就是字符串，想着通过数据类型转换来解决，但非常遗憾，报表没有提供把字符串转为数值的函数。\n实在不行就只能考虑在代码中计算完之后再赋值给报表变量了，但这样就牺牲了报表的灵活性了，乃是没有办法的最后的办法了。\n最后灵光一现，既然数据集字段与变量可以运算，那加个0是不是也可以运算？一试果然可行！\n结果 展示某两个变量的运算结果：[0+[V1]+[V2]-[V3]] 问题解决了，不过总感觉是个偏方，不晓得正统的解决方案是什么。\n不过话说回来，FastReport 2.x已经很古老了，除了老项目维护基本不可能会用到，因为现在连FastReport 3+用得都很少了，毕竟现在已经是什么乱七八糟的牛鬼蛇神都有的元宇宙时代了，能解决问题就好。","title":"*.frf报表中字段计算的坑"},{"content":" 从其它平台迁移而来\nLazarus压缩/解压zip文件可以使用Zipper单元中的TZipper/TUnZipper类来实现，但是在有中文文件名时需要注意，否则会出现乱码。\n压缩 TZipper的Zip类方法无需创建实例即可直接生成zip压缩文件。\nTZipper实例的ZipFile方法是压缩一个指定的文件生成zip压缩文件，ZipFiles方法是压缩多个指定的文件生成zip压缩文件，UnZipAllFiles方法是配合Entries等属性生成zip压缩文件。\n解压 TUnZipper的UnZip类方法无需创建实例即可直接解压zip文件。\nTUnZipper实例的UnZipFile方法是解压出一个指定的文件，UnZipFiles方法是解压出多个指定的文件，UnZipAllFiles方法可以从zip文件中解压出所有文件。\n乱码 无中文文件名的情况下，以上类方法和实例方法使用都是正常的，与其它压缩/解压工具交叉使用也不会出现问题。\n当存在中文文件名时，成对使用以上压缩/解压方法，从结果上来说是没什么问题的，但与其它压缩/解压工具交叉使用时就会出现文件名乱码问题。\n乱码其实还是字符编码的问题，Lazarus默认使用UTF8编码，windows默认使用OEM对应的编码，对于中文windows就是GBK编码，于是就出问题了。\n解决方案 TZipper有UseLanguageEncoding属性，TUnZipper有UseUTF8属性，均设置为True，再进行压缩/解压即可，因此，类方法是肯定不行的了。\n不过，这两个属性在语意上却十分让人费解，因为属性为False时，zip文件头里的文件名实际使用的是UTF8编码，而当属性为True时，zip文件头里的文件名实际使用的却是GBK编码，搞不懂这些老外的想法。\n对了，好像要使用FPC 3.2.0+的编译器版本才可以。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_zip01/","summary":"从其它平台迁移而来\nLazarus压缩/解压zip文件可以使用Zipper单元中的TZipper/TUnZipper类来实现，但是在有中文文件名时需要注意，否则会出现乱码。\n压缩 TZipper的Zip类方法无需创建实例即可直接生成zip压缩文件。\nTZipper实例的ZipFile方法是压缩一个指定的文件生成zip压缩文件，ZipFiles方法是压缩多个指定的文件生成zip压缩文件，UnZipAllFiles方法是配合Entries等属性生成zip压缩文件。\n解压 TUnZipper的UnZip类方法无需创建实例即可直接解压zip文件。\nTUnZipper实例的UnZipFile方法是解压出一个指定的文件，UnZipFiles方法是解压出多个指定的文件，UnZipAllFiles方法可以从zip文件中解压出所有文件。\n乱码 无中文文件名的情况下，以上类方法和实例方法使用都是正常的，与其它压缩/解压工具交叉使用也不会出现问题。\n当存在中文文件名时，成对使用以上压缩/解压方法，从结果上来说是没什么问题的，但与其它压缩/解压工具交叉使用时就会出现文件名乱码问题。\n乱码其实还是字符编码的问题，Lazarus默认使用UTF8编码，windows默认使用OEM对应的编码，对于中文windows就是GBK编码，于是就出问题了。\n解决方案 TZipper有UseLanguageEncoding属性，TUnZipper有UseUTF8属性，均设置为True，再进行压缩/解压即可，因此，类方法是肯定不行的了。\n不过，这两个属性在语意上却十分让人费解，因为属性为False时，zip文件头里的文件名实际使用的是UTF8编码，而当属性为True时，zip文件头里的文件名实际使用的却是GBK编码，搞不懂这些老外的想法。\n对了，好像要使用FPC 3.2.0+的编译器版本才可以。","title":"Lazarus压缩/解压zip乱码问题"},{"content":" 从其它平台迁移而来\n就个人而言，对Go的整体评价还是相当不错的，直到遇到了时间格式化。有人说，这是大佬们的浪漫。\n直接说对应关系吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //年 2006 \u0026lt;=\u0026gt; yyyy 06 \u0026lt;=\u0026gt; yy //月 01 \u0026lt;=\u0026gt; MM 1 \u0026lt;=\u0026gt; M //日 02 \u0026lt;=\u0026gt; dd 2 \u0026lt;=\u0026gt; d //时 15 \u0026lt;=\u0026gt; hh 3 \u0026lt;=\u0026gt; h //分 04 \u0026lt;=\u0026gt; mm 4 \u0026lt;=\u0026gt; m //秒 05 \u0026lt;=\u0026gt; ss 5 \u0026lt;=\u0026gt; s go 1.20+在time包中又增加了time.DateTime、time.DateOnly、time.TimeOnly三个常量，分别对应2006-01-02 15:04:05、2006-01-02、15:04:05，再也不用专门去记对应关系了。\n","permalink":"https://afrusrsc.github.io/posts/program/go/go_format_datetime/","summary":"从其它平台迁移而来\n就个人而言，对Go的整体评价还是相当不错的，直到遇到了时间格式化。有人说，这是大佬们的浪漫。\n直接说对应关系吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //年 2006 \u0026lt;=\u0026gt; yyyy 06 \u0026lt;=\u0026gt; yy //月 01 \u0026lt;=\u0026gt; MM 1 \u0026lt;=\u0026gt; M //日 02 \u0026lt;=\u0026gt; dd 2 \u0026lt;=\u0026gt; d //时 15 \u0026lt;=\u0026gt; hh 3 \u0026lt;=\u0026gt; h //分 04 \u0026lt;=\u0026gt; mm 4 \u0026lt;=\u0026gt; m //秒 05 \u0026lt;=\u0026gt; ss 5 \u0026lt;=\u0026gt; s go 1.20+在time包中又增加了time.DateTime、time.DateOnly、time.TimeOnly三个常量，分别对应2006-01-02 15:04:05、2006-01-02、15:04:05，再也不用专门去记对应关系了。","title":"Go的时间格式化"},{"content":" 从其它平台迁移而来\n坑 最近要和一个平台提供的http接口进行对接，由于服务不是部署在公网上的，所以没办法直接在开发环境下直接调试，又不能在客户的测试机上部署开发环境，只能选择加日志这种古老的方法。\n在对接过程中却出现了莫名其妙的问题：POST的内容是一样的，但返回的内容却不一样，更准确点说是有的接口返回正常有的返回不正常（其实还是测试有限，测试多的话还会出现同一接口有的请求正常有的不正常）。\n平台提供的word接口文档写得真的是……一言难尽，由此也对接口的准确性、可靠性等保持怀疑。不过，这次用我们提供的数据，平台方给出了相应的中间结果（中间结果一致）及返回结果，还有postman和curl的测试截图，充分证明接口以及数据请求是没有问题的。\n在客户测试机上装了curl测试也证明接口没问题。（问为什么一开始没想到用curl？因为windows默认没有，而且utf8还会显示乱码，习惯性的就没想起来用）\n请求头也改了，没用一样的效果。\n最后实在找不出问题，就只能进行TCP抓包了，这一抓还就真抓出问题了：\n原始数据\n1 /knwRBV5D4Qtk7RzoQhtBUSMXQig3zURYmeSQBB17NVr6qddCkTxS7e0oO/qfNCkuX14vGsxEoLLN4KS5vtQWDs5on+GeAE5LadCZuHDCe7M25GitNKqnsCfC5qVmti1LyxLxYg2JpLP6GylWERWBOmbP2yO2Aiuey6V526rlRICnidM1W0A4ziNMSjGCng0n5Md4so/RjswNdcE4C5F0kBEGRWH0ZK+QdkZMs4zL84Pu/aiSMpiID9Mm+jtdLZuk0m0UtEd1MmxnU2KPdQz9057JAtM5LIj4YenZl3J86OPWtb9DE6a+410CWBawZY1vItZ+43Kh/QPnkw6Qe4toXRnF84X/ijtiWkTt4moJT87xDpf/TXEd7LRkddWPRRGF3KHnUKacLySwMmXkU6CQMazE1Kh1ZGML6zl1weaq4xVulFwhGfp2XKzYdZfT3uq4yqVr30AaEqYoy2/P1MkhTs5on+GeAE54r939gdklpefguipLJVBpWk/B5S9QsCDxDbfGYNxJo3rIAxDL7sjjlmVL1RjU86sHsNIbmRii7dL70pf5qcIMJzryGmtn94SAE2HjLw0abfr0A9amRsdIzs5on+GeAE5RIxdCKDfNRFnPqLzNU5stMSDcpuafJpNhUXDbQOMlPungXJHHZAgbE2XtoI4geIRYjiyBLDMQuB0l5WvfDhpRnYo1VaEu7J0tRuezwUplK61p4I8giLwAtO+yNMRV+J65g9XaT8vmf8gxmtK3wEFrve7HwsYH0QhlQQiMilY/JVsiHZS6+ID/w== 发送后抓到的却是\n1 /knwRBV5D4Qtk7RzoQhtBUSMXQig3zURYmeSQBB17NVr6qddCkTxS7e0oO/qfNCkuX14vGsxEoLLN4KS5vtQWDs5on+GeAE5LadCZuHDCe7M25GitNKqnsCfC5qVmti1LyxLxYg2JpLP6GylWERWBOmbP2yO2Aiuey6V526rlRICnidM1W0A4ziNMSjGCng0n5Md4so/RjswNdcE4C5F0kBEGRWH0ZK+QdkZMs4zL84Pu/aiSMpiID9Mm+jtdLZuk0m0UtEd1MmxnU2KPdQz9057JAtM5LIj4YenZl3J86OPWtb9DE6a+410CWBawZY1vItZ+43Kh/QPnkw6Qe4toXRnF84X/ijtiWkTt4moJT87xDpf/TXEd7LRkddWPRRGF3KHnUKacLySwMmXkU6CQMazE1Kh1ZGML6zl1weaq4xVulFwhGfp2XKzYdZfT3uq4yqVr30AaEqYoy2/P1MkhTs5on+GeAE54r939gdklpefguipLJVBpWk/B5S9QsCDxDbfGYNxJo3rIAxDL7sjjlmVL1RjU86sHsNIbmRii7dL70pf5qcIMJzryGmtn94SAE2HjLw0abfr0A9amRsdIzs5on+GeAE5RIxdCKDfNRFnPqLzNU5stMSDcpuafJpNhUXDbQOMlPungXJHHZAgbE2XtoI4geIRYjiyBLDMQuB0l5WvfDhpRnYo1VaEu7J0tRuezwUplK61p4I8giLwAtO+yNMRV+J65g9XaT8vmf8gxmtK3wEFrve7HwsYH0QhlQQiMilY/JVsiHZS6+ID/w=%3D 最后的=被转码为%3D了！\n解决 找到原因就好办了\n1 2 //idhttp.HTTPOptions := [hoForceEncodeParams]; //默认强制对参数进行转码 idhttp.HTTPOptions := []; //去掉就OK了 ","permalink":"https://afrusrsc.github.io/posts/program/pascal/delphi_idhttp_post/","summary":" 从其它平台迁移而来\n坑 最近要和一个平台提供的http接口进行对接，由于服务不是部署在公网上的，所以没办法直接在开发环境下直接调试，又不能在客户的测试机上部署开发环境，只能选择加日志这种古老的方法。\n在对接过程中却出现了莫名其妙的问题：POST的内容是一样的，但返回的内容却不一样，更准确点说是有的接口返回正常有的返回不正常（其实还是测试有限，测试多的话还会出现同一接口有的请求正常有的不正常）。\n平台提供的word接口文档写得真的是……一言难尽，由此也对接口的准确性、可靠性等保持怀疑。不过，这次用我们提供的数据，平台方给出了相应的中间结果（中间结果一致）及返回结果，还有postman和curl的测试截图，充分证明接口以及数据请求是没有问题的。\n在客户测试机上装了curl测试也证明接口没问题。（问为什么一开始没想到用curl？因为windows默认没有，而且utf8还会显示乱码，习惯性的就没想起来用）\n请求头也改了，没用一样的效果。\n最后实在找不出问题，就只能进行TCP抓包了，这一抓还就真抓出问题了：\n原始数据\n1 /knwRBV5D4Qtk7RzoQhtBUSMXQig3zURYmeSQBB17NVr6qddCkTxS7e0oO/qfNCkuX14vGsxEoLLN4KS5vtQWDs5on+GeAE5LadCZuHDCe7M25GitNKqnsCfC5qVmti1LyxLxYg2JpLP6GylWERWBOmbP2yO2Aiuey6V526rlRICnidM1W0A4ziNMSjGCng0n5Md4so/RjswNdcE4C5F0kBEGRWH0ZK+QdkZMs4zL84Pu/aiSMpiID9Mm+jtdLZuk0m0UtEd1MmxnU2KPdQz9057JAtM5LIj4YenZl3J86OPWtb9DE6a+410CWBawZY1vItZ+43Kh/QPnkw6Qe4toXRnF84X/ijtiWkTt4moJT87xDpf/TXEd7LRkddWPRRGF3KHnUKacLySwMmXkU6CQMazE1Kh1ZGML6zl1weaq4xVulFwhGfp2XKzYdZfT3uq4yqVr30AaEqYoy2/P1MkhTs5on+GeAE54r939gdklpefguipLJVBpWk/B5S9QsCDxDbfGYNxJo3rIAxDL7sjjlmVL1RjU86sHsNIbmRii7dL70pf5qcIMJzryGmtn94SAE2HjLw0abfr0A9amRsdIzs5on+GeAE5RIxdCKDfNRFnPqLzNU5stMSDcpuafJpNhUXDbQOMlPungXJHHZAgbE2XtoI4geIRYjiyBLDMQuB0l5WvfDhpRnYo1VaEu7J0tRuezwUplK61p4I8giLwAtO+yNMRV+J65g9XaT8vmf8gxmtK3wEFrve7HwsYH0QhlQQiMilY/JVsiHZS6+ID/w== 发送后抓到的却是\n1 /knwRBV5D4Qtk7RzoQhtBUSMXQig3zURYmeSQBB17NVr6qddCkTxS7e0oO/qfNCkuX14vGsxEoLLN4KS5vtQWDs5on+GeAE5LadCZuHDCe7M25GitNKqnsCfC5qVmti1LyxLxYg2JpLP6GylWERWBOmbP2yO2Aiuey6V526rlRICnidM1W0A4ziNMSjGCng0n5Md4so/RjswNdcE4C5F0kBEGRWH0ZK+QdkZMs4zL84Pu/aiSMpiID9Mm+jtdLZuk0m0UtEd1MmxnU2KPdQz9057JAtM5LIj4YenZl3J86OPWtb9DE6a+410CWBawZY1vItZ+43Kh/QPnkw6Qe4toXRnF84X/ijtiWkTt4moJT87xDpf/TXEd7LRkddWPRRGF3KHnUKacLySwMmXkU6CQMazE1Kh1ZGML6zl1weaq4xVulFwhGfp2XKzYdZfT3uq4yqVr30AaEqYoy2/P1MkhTs5on+GeAE54r939gdklpefguipLJVBpWk/B5S9QsCDxDbfGYNxJo3rIAxDL7sjjlmVL1RjU86sHsNIbmRii7dL70pf5qcIMJzryGmtn94SAE2HjLw0abfr0A9amRsdIzs5on+GeAE5RIxdCKDfNRFnPqLzNU5stMSDcpuafJpNhUXDbQOMlPungXJHHZAgbE2XtoI4geIRYjiyBLDMQuB0l5WvfDhpRnYo1VaEu7J0tRuezwUplK61p4I8giLwAtO+yNMRV+J65g9XaT8vmf8gxmtK3wEFrve7HwsYH0QhlQQiMilY/JVsiHZS6+ID/w=%3D 最后的=被转码为%3D了！\n解决 找到原因就好办了\n1 2 //idhttp.HTTPOptions := [hoForceEncodeParams]; //默认强制对参数进行转码 idhttp.HTTPOptions := []; //去掉就OK了 ","title":"idhttp POST的坑"},{"content":" 从其它平台迁移而来\nAfterConstruction、BeforeDestruction是TObject本身就有的方法，Loaded是从TComponent才有的方法，好好利用的话就可以更精准的控制对象的生命周期或者初始化/清理工作。虽然知道这点，而且也经常在自己的程序中使用，但还是会经常搞错执行顺序，因此专门记录一下以备忘备查。\nForm graph TD f1[inherited Create 前] --\u003e f2[inherited Loaded 前] --\u003e f3[inherited Loaded 后] --\u003e f4[inherited Create 后] --\u003e f5[inherited AfterConstruction 前] --\u003e f6[FormCreate] --\u003e f7[inherited AfterConstruction 后] --\u003e f8[FormResize] --\u003e f9[FormShow] --\u003e f10[FormCloseQuery] --\u003e f11[FormClose] --\u003e f12[inherited BeforeDestruction 前] --\u003e f13[FormHide] --\u003e f14[FormDestroy] --\u003e f15[inherited BeforeDestruction 后] --\u003e f16[inherited Destroy 前] --\u003e f17[inherited Destroy 后] DataModule graph TD d1[inherited Create 前] --\u003e d2[inherited Loaded 前] --\u003e d3[inherited Loaded 后] --\u003e d4[inherited Create 后] --\u003e d5[inherited AfterConstruction 前] --\u003e d6[DataModuleCreate] --\u003e d7[inherited AfterConstruction 后] --\u003e d8[inherited BeforeDestruction 前] --\u003e d9[DataModuleDestroy] --\u003e d10[inherited BeforeDestruction 后] --\u003e d11[inherited Destroy 前] --\u003e d12[inherited Destroy 后] Frame graph TD f1[inherited Create 前] --\u003e f2[inherited Loaded 前] --\u003e f3[inherited Loaded 后] --\u003e f4[inherited Create 后] --\u003e f5[inherited AfterConstruction 前] --\u003e f6[inherited AfterConstruction 后] --\u003e f7[FrameResize] --\u003e f8[inherited BeforeDestruction 前] --\u003e f9[inherited BeforeDestruction 后] --\u003e f10[inherited Destroy 前] --\u003e f11[inherited Destroy 后] 总结 Loaded是在Create的过程执行的，应该是用来做一些加载资源之类或其它辅助构造的工作\nAfterConstruction是在构造之后调用OnCreate事件，若类无OnCreate事件则可以用AfterConstruction代替来完成一些初始化工作\nBeforeDestruction是在析构之前调用OnDestroy事件，若类无OnDestroy事件则可以用BeforeDestruction代替来完成一些反初始化工作\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_order/","summary":"从其它平台迁移而来\nAfterConstruction、BeforeDestruction是TObject本身就有的方法，Loaded是从TComponent才有的方法，好好利用的话就可以更精准的控制对象的生命周期或者初始化/清理工作。虽然知道这点，而且也经常在自己的程序中使用，但还是会经常搞错执行顺序，因此专门记录一下以备忘备查。\nForm graph TD f1[inherited Create 前] --\u003e f2[inherited Loaded 前] --\u003e f3[inherited Loaded 后] --\u003e f4[inherited Create 后] --\u003e f5[inherited AfterConstruction 前] --\u003e f6[FormCreate] --\u003e f7[inherited AfterConstruction 后] --\u003e f8[FormResize] --\u003e f9[FormShow] --\u003e f10[FormCloseQuery] --\u003e f11[FormClose] --\u003e f12[inherited BeforeDestruction 前] --\u003e f13[FormHide] --\u003e f14[FormDestroy] --\u003e f15[inherited BeforeDestruction 后] --\u003e f16[inherited Destroy 前] --\u003e f17[inherited Destroy 后] DataModule graph TD d1[inherited Create 前] --\u003e d2[inherited Loaded 前] --\u003e d3[inherited Loaded 后] --\u003e d4[inherited Create 后] --\u003e d5[inherited AfterConstruction 前] --\u003e d6[DataModuleCreate] --\u003e d7[inherited AfterConstruction 后] --\u003e d8[inherited BeforeDestruction 前] --\u003e d9[DataModuleDestroy] --\u003e d10[inherited BeforeDestruction 后] --\u003e d11[inherited Destroy 前] --\u003e d12[inherited Destroy 后] Frame graph TD f1[inherited Create 前] --\u003e f2[inherited Loaded 前] --\u003e f3[inherited Loaded 后] --\u003e f4[inherited Create 后] --\u003e f5[inherited AfterConstruction 前] --\u003e f6[inherited AfterConstruction 后] --\u003e f7[FrameResize] --\u003e f8[inherited BeforeDestruction 前] --\u003e f9[inherited BeforeDestruction 后] --\u003e f10[inherited Destroy 前] --\u003e f11[inherited Destroy 后] 总结 Loaded是在Create的过程执行的，应该是用来做一些加载资源之类或其它辅助构造的工作","title":"Lazarus构造/析构等方法的执行顺序"},{"content":" 从其它平台迁移而来\nPackage-\u0026gt;Install/Uninstall Packages AnchorDockingDsgn：安装后转为一体式IDE\nLazActiveX：安装后可安装ActiveX组件\nlazdaemon：可开发windows服务\nlazprojectgroups：使IDE支持工程组\nlazvlc：VLC 播放器组件，需要V2版本以上的libvlccore.dll和libvlc.dll\nPackage-\u0026gt;Online Package Manager DBTreeViewAndDBCntrlGrid：可从数据集中把树型数据直接显示为树\nDCPcrypt：常用加密/解密，如DES、3DES、AES、RC2、RC4、RC5、RC6、MD4、MD5、SHA1、SHA256、SHA384、SHA512等\n自带单元 fpjson、jsonscanner、jsonparser：自带JSON\njsonConf：JSON配置\nfphttpclient：HTTP客户端\nfphttpserver：HTTP服务端\nbase64：BASE64编码/解码\nmd5：MD2、MD4、MD5算法\nsha1：SHA-1(RFC 3174)算法\ncrcCRC32、CRC64和CRC128算法\n开源库 dataset-serialize：数据集与JSON序列化/反序列化\nCEF4Delphi：谷歌浏览器内核，依赖DCPcrypt\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_info/","summary":"从其它平台迁移而来\nPackage-\u0026gt;Install/Uninstall Packages AnchorDockingDsgn：安装后转为一体式IDE\nLazActiveX：安装后可安装ActiveX组件\nlazdaemon：可开发windows服务\nlazprojectgroups：使IDE支持工程组\nlazvlc：VLC 播放器组件，需要V2版本以上的libvlccore.dll和libvlc.dll\nPackage-\u0026gt;Online Package Manager DBTreeViewAndDBCntrlGrid：可从数据集中把树型数据直接显示为树\nDCPcrypt：常用加密/解密，如DES、3DES、AES、RC2、RC4、RC5、RC6、MD4、MD5、SHA1、SHA256、SHA384、SHA512等\n自带单元 fpjson、jsonscanner、jsonparser：自带JSON\njsonConf：JSON配置\nfphttpclient：HTTP客户端\nfphttpserver：HTTP服务端\nbase64：BASE64编码/解码\nmd5：MD2、MD4、MD5算法\nsha1：SHA-1(RFC 3174)算法\ncrcCRC32、CRC64和CRC128算法\n开源库 dataset-serialize：数据集与JSON序列化/反序列化\nCEF4Delphi：谷歌浏览器内核，依赖DCPcrypt","title":"Lazarus速查"},{"content":" 从其它平台迁移而来\n在使用Lazarus编写动态库的过程中遇到了报Error: Undefined symbol:错误的问题，死活编译不过去，加了LCL包依赖也不行，找了N久终于在一个英文网站上找到了解决办法。\nError: Undefined symbol:错误会依据所写的代码用到的单元不同而有一定的差异，我遇到的报错大致如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 project1.lpr(18,1) Error: Undefined symbol: WSRegisterCustomImageListResolution project1.lpr(18,1) Error: Undefined symbol: WSRegisterMenuItem project1.lpr(18,1) Error: Undefined symbol: WSRegisterMenu project1.lpr(18,1) Error: Undefined symbol: WSRegisterMainMenu project1.lpr(18,1) Error: Undefined symbol: WSRegisterPopupMenu project1.lpr(18,1) Error: Undefined symbol: WSRegisterDragImageListResolution project1.lpr(18,1) Error: Undefined symbol: WSRegisterLazAccessibleObject project1.lpr(18,1) Error: Undefined symbol: WSRegisterControl project1.lpr(18,1) Error: Undefined symbol: WSRegisterWinControl project1.lpr(18,1) Error: Undefined symbol: WSRegisterGraphicControl project1.lpr(18,1) Error: Undefined symbol: WSRegisterCustomControl project1.lpr(18,1) Error: Undefined symbol: WSRegisterScrollingWinControl project1.lpr(18,1) Error: Undefined symbol: WSRegisterScrollBox project1.lpr(18,1) Error: Undefined symbol: WSRegisterCustomFrame project1.lpr(18,1) Error: Undefined symbol: WSRegisterCustomForm project1.lpr(18,1) Error: Undefined symbol: WSRegisterHintWindow 其实之前已经离解决问题很近了，只需再uses一个Interfaces，即：\n在Project Inspector的Required Packages里添加LCL包\n在工程单元的uses列表里添加Interfaces单元\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_undefined_symbol/","summary":"从其它平台迁移而来\n在使用Lazarus编写动态库的过程中遇到了报Error: Undefined symbol:错误的问题，死活编译不过去，加了LCL包依赖也不行，找了N久终于在一个英文网站上找到了解决办法。\nError: Undefined symbol:错误会依据所写的代码用到的单元不同而有一定的差异，我遇到的报错大致如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 project1.lpr(18,1) Error: Undefined symbol: WSRegisterCustomImageListResolution project1.lpr(18,1) Error: Undefined symbol: WSRegisterMenuItem project1.lpr(18,1) Error: Undefined symbol: WSRegisterMenu project1.lpr(18,1) Error: Undefined symbol: WSRegisterMainMenu project1.lpr(18,1) Error: Undefined symbol: WSRegisterPopupMenu project1.lpr(18,1) Error: Undefined symbol: WSRegisterDragImageListResolution project1.lpr(18,1) Error: Undefined symbol: WSRegisterLazAccessibleObject project1.lpr(18,1) Error: Undefined symbol: WSRegisterControl project1.lpr(18,1) Error: Undefined symbol: WSRegisterWinControl project1.lpr(18,1) Error: Undefined symbol: WSRegisterGraphicControl project1.","title":"Lazarus报Error: Undefined symbol"},{"content":" 从其它平台迁移而来\n坑 首次使用Oracle数据库，习惯性的用Navicat连起来，嗯？？？怎么报错连不上？\n数据库安装有问题？SQL Plus能连上啊！\n检查配置，没问题！\n重启，还是不行！\n重装Navicat，然并卵！\n解决 出现解决不了的问题，那就果断面向搜索引擎，看了好多文章，也试了个遍，甚至都开始更换dll了，最后发现其实还真和dll有关系。\n这是默认的配置，可以看到，OCI用的是Navicat自带的oci.dll，换成Oracle安装路径的oci.dll，重启Navicat，完美！\n","permalink":"https://afrusrsc.github.io/posts/db/navicat_oracle/","summary":"从其它平台迁移而来\n坑 首次使用Oracle数据库，习惯性的用Navicat连起来，嗯？？？怎么报错连不上？\n数据库安装有问题？SQL Plus能连上啊！\n检查配置，没问题！\n重启，还是不行！\n重装Navicat，然并卵！\n解决 出现解决不了的问题，那就果断面向搜索引擎，看了好多文章，也试了个遍，甚至都开始更换dll了，最后发现其实还真和dll有关系。\n这是默认的配置，可以看到，OCI用的是Navicat自带的oci.dll，换成Oracle安装路径的oci.dll，重启Navicat，完美！","title":"Navicat连接Oracle数据库的坑"},{"content":" 从其它平台迁移而来\n最近需要评估一下海康摄像头不同抓拍方式的性能，以及封装类的可靠性。\n在测试过程中，又发现了当初遇见的设备内存抓拍报错的问题。当初排查的结论是：当封装类开启预览的情况下，使用设备抓图有较高概率抓拍失败。由于预览是必需的，最终选择了预览抓拍。\n现在，换用lazarus进行测试，发现设备抓图必失败，与是否预览无关。一点点调试，发现直接调用SDK原始方法进行设备抓图正常，使用封装类的设备抓图就不行，那肯定是封装类出了问题。\n最终发现，封装类的设备抓图使用了out来修饰参数，参数是TMemoryStream和TJPEGImage对象，尝试去掉out修饰符，然后就一切正常了。\n记得很久前专门研究过out和var修饰符的区别，当时查阅的结果是：out和var修饰的参数都是传址的，区别是out会对参数进行初始化，而var则不会。\n另外，参数为对象的情况，实际也是传址的。\n本次发现的问题可能就是使用out来修饰对象参数导致的，但并没有进行进一步的测试。\n附 测试环境 操作系统：win10\n硬盘：SSD\n测试结果 子码流预览抓图，耗时毫秒级；主码流预览抓图，耗时10+毫秒级\n预览抓图比设备拍图耗时少得多，设备抓图在100+毫秒级\n在相同分辨率情况下，预览抓图的文件大小比设备抓图的略大\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_use_out/","summary":"从其它平台迁移而来\n最近需要评估一下海康摄像头不同抓拍方式的性能，以及封装类的可靠性。\n在测试过程中，又发现了当初遇见的设备内存抓拍报错的问题。当初排查的结论是：当封装类开启预览的情况下，使用设备抓图有较高概率抓拍失败。由于预览是必需的，最终选择了预览抓拍。\n现在，换用lazarus进行测试，发现设备抓图必失败，与是否预览无关。一点点调试，发现直接调用SDK原始方法进行设备抓图正常，使用封装类的设备抓图就不行，那肯定是封装类出了问题。\n最终发现，封装类的设备抓图使用了out来修饰参数，参数是TMemoryStream和TJPEGImage对象，尝试去掉out修饰符，然后就一切正常了。\n记得很久前专门研究过out和var修饰符的区别，当时查阅的结果是：out和var修饰的参数都是传址的，区别是out会对参数进行初始化，而var则不会。\n另外，参数为对象的情况，实际也是传址的。\n本次发现的问题可能就是使用out来修饰对象参数导致的，但并没有进行进一步的测试。\n附 测试环境 操作系统：win10\n硬盘：SSD\n测试结果 子码流预览抓图，耗时毫秒级；主码流预览抓图，耗时10+毫秒级\n预览抓图比设备拍图耗时少得多，设备抓图在100+毫秒级\n在相同分辨率情况下，预览抓图的文件大小比设备抓图的略大","title":"慎用 out"},{"content":" 从其它平台迁移而来\n事件 过了个十一，原本好好的电脑，突然鼠标不能用了，本着重启能解决80%的问题的原则重启了下，结果就杯具了，直接就蓝屏了，怎么折腾都进不了系统，BUG 10果然是BUG 10，绝对名不虚传！\n无奈，只剩下重装系统这一条路了，装完系统之后还要装一堆软件，还要把软件配置成自己的习惯，还有其它一些细节工作……要把这些都做完才能大致恢复到原先的样子，想想就各种不爽。\n虽然已经尽可能的使用免安装/重装的软件了，但还是避免不了有一些软件必须要重装才能使用的情况，唉~\n其中最令人头疼的就是开发环境了，几乎绝大部分都要重装，Lazarus就是其中之一，先前已经尝试过了，离成功只差一步了，这次终于搞定了，记录下来。\n免重装 正常安装Lazarus\n首次启动Lazarus会弹出初始配置界面，关闭\n打开Lazarus的根安装目录，新建一个config文件夹\n打开C:\\Users\\xxx\\AppData\\Local\\lazarus文件夹(xxx为用户名)，复制里面所有内容到config\n找到Lazarus的快捷方式，右键属性，在目标里原有内容后面添加 --pcp=.\\config(注意前面有空格)，确定\n把修改好的快捷方式复制到Lazarus的根安装目录下，供以后使用\n删除C:\\Users\\xxx\\AppData\\Local\\lazarus文件夹\n使用刚才的快捷方式启动Lazarus，进行个性化设置、安装组件等\n以后重装系统了直接使用快捷方式启动Lazarus即可\n如果安装的组件全部都在Lazarus的安装目录下，整个Lazarus的安装目录即为一个便携式的IDE了\n为避免如果使用过程中出现莫名其妙的现象，建议把Lazarus的安装目录下的ssleay32.dll、libeay32.dll、Qt5Pas1.dll和Qt4Pas5.dll复制到C:\\Windows\\System32或C:\\Windows\\SysWOW64下\n本文参考了https://blog.csdn.net/love3s/article/details/7450339\n附 在命令行进入Lazarus的根安装目录，运行lazarus.exe -?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 lazarus [options] \u0026lt;project-filename\u0026gt; IDE Options: --help or -? this help message -v or --version show version and exit --quiet be less verbose, can be given multiple times --verbose be more verbose, can be given multiple times --setup Show setup dialog for most important settings --primary-config-path= \u0026lt;path\u0026gt; or --pcp= \u0026lt;path\u0026gt; primary config directory where Lazarus stores its config files. Default is C:\\Users\\Administrator\\AppData\\Local\\lazarus --secondary-config-path= \u0026lt;path\u0026gt; or --scp= \u0026lt;path\u0026gt; secondary config directory where Lazarus searches for config template files. Default is D:\\lazarus --debug-log= \u0026lt;file\u0026gt; file where debug output is written to. If it is not specified, debug output is written to the console. --debug-enable= [[-]OptName][,[-]OptName][...] Enable or Disable groups of debug output. Valid Options are: DBG_VERBOSE DBG_WARNINGS DBG_STATE DBG_EVENTS DBG_STATE_EVENT DBG_DATA_MONITORS DBG_DISASSEMBLER DBG_LOCATION_INFO SYNMOUSEEVENTS SYNSYSTEMWIDTHCHARS SRCED_LOCK SRCED_OPEN SRCED_CLOSE SRCED_PAGES DBG_CMD_ECHO DBG_CMD_ECHO_FULL DBGMI_TYPE_INFO DBGMI_TIMEOUT_DEBUG DBG_THREAD_AND_FRAME DBGMI_QUEUE_DEBUG DBGMI_STRUCT_PARSER FPDBG_DWARF_ERRORS FPDBG_DWARF_WARNINGS FPDBG_DWARF_VERBOSE FPDBG_DWARF_VERBOSE_LOAD FPDBG_DWARF_SEARCH FPDBG_DWARF_DATA_WARNINGS DBG_ERRORS --no-splash-screen or --nsc Do not show splash screen --force-new-instance Do not check if another IDE instance is already running --skip-last-project Skip loading last project --language= Override language. For example --language=de. For possible values see files in the languages directory. --lazarusdir=\u0026lt;directory\u0026gt; directory to be used as a basedirectory LCL Interface specific options: 总感觉好像还有内容，但我这里始终出不来……\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/lazarus_install/","summary":"从其它平台迁移而来\n事件 过了个十一，原本好好的电脑，突然鼠标不能用了，本着重启能解决80%的问题的原则重启了下，结果就杯具了，直接就蓝屏了，怎么折腾都进不了系统，BUG 10果然是BUG 10，绝对名不虚传！\n无奈，只剩下重装系统这一条路了，装完系统之后还要装一堆软件，还要把软件配置成自己的习惯，还有其它一些细节工作……要把这些都做完才能大致恢复到原先的样子，想想就各种不爽。\n虽然已经尽可能的使用免安装/重装的软件了，但还是避免不了有一些软件必须要重装才能使用的情况，唉~\n其中最令人头疼的就是开发环境了，几乎绝大部分都要重装，Lazarus就是其中之一，先前已经尝试过了，离成功只差一步了，这次终于搞定了，记录下来。\n免重装 正常安装Lazarus\n首次启动Lazarus会弹出初始配置界面，关闭\n打开Lazarus的根安装目录，新建一个config文件夹\n打开C:\\Users\\xxx\\AppData\\Local\\lazarus文件夹(xxx为用户名)，复制里面所有内容到config\n找到Lazarus的快捷方式，右键属性，在目标里原有内容后面添加 --pcp=.\\config(注意前面有空格)，确定\n把修改好的快捷方式复制到Lazarus的根安装目录下，供以后使用\n删除C:\\Users\\xxx\\AppData\\Local\\lazarus文件夹\n使用刚才的快捷方式启动Lazarus，进行个性化设置、安装组件等\n以后重装系统了直接使用快捷方式启动Lazarus即可\n如果安装的组件全部都在Lazarus的安装目录下，整个Lazarus的安装目录即为一个便携式的IDE了\n为避免如果使用过程中出现莫名其妙的现象，建议把Lazarus的安装目录下的ssleay32.dll、libeay32.dll、Qt5Pas1.dll和Qt4Pas5.dll复制到C:\\Windows\\System32或C:\\Windows\\SysWOW64下\n本文参考了https://blog.csdn.net/love3s/article/details/7450339\n附 在命令行进入Lazarus的根安装目录，运行lazarus.exe -?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 lazarus [options] \u0026lt;project-filename\u0026gt; IDE Options: --help or -?","title":"配置Lazarus免重装"},{"content":" 从其它平台迁移而来\n背景 客户使用的是南方XX的生产控制系统，需要把数据导入到我们自己的系统里，之前做过类似的东西，不难。\n当看到南方XX使用的是Access数据库里，心中一沉……（此处省略1024G脏字）不管心中有多少头神兽奔腾而过，该做的事情终究还是要做的，谁让人家里客户是金主呢。\n坑来了 代码写好了，测试也没问题（小BUG什么的分分钟搞定，不算数），通过！\n然后等着定时器，看第二回合是否通过。结果，卡卡卡的报主键重复！！！墨菲定律再次生效！\n查日志、打断点……一波操作后发现，是Access的时间过滤SQL执行结果和预期不一样！\n在Access里执行，正常！在程序里（ADO）执行，异常！！（此处再次省略1024G脏字）\n开启面向搜索引擎编程模式，浪费一把又一把生命后（论浪费生命，某垃圾度绝对功不可没），终于找到了解决方案：\n1 SELECT * FROM 表 WHERE 时间字段\u0026gt;CDate(\u0026#39;字符串型的时间条件值\u0026#39;) 吐槽 （此处直接省略1024T脏字）\n微软早期的东西自己和自己都范冲，真是垃圾得不能再垃圾了，呃~不好意思，侮辱垃圾了！\n福利？ 分享个图吧，不知道算不算福利，反正我是差点笑岔气儿！\n","permalink":"https://afrusrsc.github.io/posts/db/access_time/","summary":"从其它平台迁移而来\n背景 客户使用的是南方XX的生产控制系统，需要把数据导入到我们自己的系统里，之前做过类似的东西，不难。\n当看到南方XX使用的是Access数据库里，心中一沉……（此处省略1024G脏字）不管心中有多少头神兽奔腾而过，该做的事情终究还是要做的，谁让人家里客户是金主呢。\n坑来了 代码写好了，测试也没问题（小BUG什么的分分钟搞定，不算数），通过！\n然后等着定时器，看第二回合是否通过。结果，卡卡卡的报主键重复！！！墨菲定律再次生效！\n查日志、打断点……一波操作后发现，是Access的时间过滤SQL执行结果和预期不一样！\n在Access里执行，正常！在程序里（ADO）执行，异常！！（此处再次省略1024G脏字）\n开启面向搜索引擎编程模式，浪费一把又一把生命后（论浪费生命，某垃圾度绝对功不可没），终于找到了解决方案：\n1 SELECT * FROM 表 WHERE 时间字段\u0026gt;CDate(\u0026#39;字符串型的时间条件值\u0026#39;) 吐槽 （此处直接省略1024T脏字）\n微软早期的东西自己和自己都范冲，真是垃圾得不能再垃圾了，呃~不好意思，侮辱垃圾了！\n福利？ 分享个图吧，不知道算不算福利，反正我是差点笑岔气儿！","title":"恶心的Access时间查询"},{"content":" 从其它平台迁移而来\nDBGridEh算是Delphi中比较好用的第三方数据感知组件了，但其中有些小坑是真的有点小无语的。\n场景 客户需要的有这样一组数据，大部分列是要求和的，用DBGridEh的Footer是轻松加愉快的；但是个别列是和每一行的计算方法一致的，用求和反倒是大错特错的，所以要求针对这些个别列按照给定的算法进行计算后显示在Footer中。\n坑 Footer有个ValueType和Value属性，汇总类型是通过ValueType设置的，习惯性的以为汇总值是通过Value来读写的。\n然而，事实并非如此！\n对于求和列，DBGridEh1.Columns[i].Footer.Value的值一直是''空串，要想取得求和列的汇总值，正确的打开方式是DBGridEh1.GetFooterValue(0,DBGridEh1.Columns[i])！这简直是反人类啊有木有！\n后记 这是第二次踩这个坑了，记录下，给自己长点记性！事不过三！！\n另外，公司使用的版本比较老，新版本可能没有这些问题了，不太清楚，暂时没空去求证。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/ehlib_dbgrideh_footer_sum/","summary":"从其它平台迁移而来\nDBGridEh算是Delphi中比较好用的第三方数据感知组件了，但其中有些小坑是真的有点小无语的。\n场景 客户需要的有这样一组数据，大部分列是要求和的，用DBGridEh的Footer是轻松加愉快的；但是个别列是和每一行的计算方法一致的，用求和反倒是大错特错的，所以要求针对这些个别列按照给定的算法进行计算后显示在Footer中。\n坑 Footer有个ValueType和Value属性，汇总类型是通过ValueType设置的，习惯性的以为汇总值是通过Value来读写的。\n然而，事实并非如此！\n对于求和列，DBGridEh1.Columns[i].Footer.Value的值一直是''空串，要想取得求和列的汇总值，正确的打开方式是DBGridEh1.GetFooterValue(0,DBGridEh1.Columns[i])！这简直是反人类啊有木有！\n后记 这是第二次踩这个坑了，记录下，给自己长点记性！事不过三！！\n另外，公司使用的版本比较老，新版本可能没有这些问题了，不太清楚，暂时没空去求证。","title":"踩坑记：DBGridEh中取Footer的Sum值"},{"content":" 从其它平台迁移而来\n一直想找个开源的可以商用的Delphi的替代品，能跨平台了最好。开始时试过Lazarus，和D7还真是挺像的，不过用惯了XE，还是想找个习惯相似的IDE，扒拉下论坛后发现了CodeTyphon，就想着试一下。\n下载 下载就不多说了，网上很容易找到，而且官方wiki写得也很好，英文好的可以直接看，像我这样的英语渣渣，还是有必要慢慢去啃的。\nCodeTyphon下载后只有一个CodeTyphonIns.zip的压缩包，无论是Windows、Linux还是MacOS，安装包都是它，因为不管在哪个平台上安装，都是要编译的。\n安装 解压CodeTyphonIns.zip得到CodeTyphonIns\n在Windows平台，以管理员方式运行install.bat；在类unix平台，先cd CodeTyphonIns，再sudo ./install.sh\n出现以下界面，输入0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ==================================================== CodeTyphon Studio Version 7.30 (GEN 7) Installation for Linux-Solaris-Openindiana-MacOS FreeBSD-NetBSD-OpenBSD-DragonFly ==================================================== -----WARNING------ WARNING ----WARNING------- You tryng to install CT as root This is NOT the correct procedure. You MUST start CodeTyphon Installation as normal user with sudo root privileges --------------------------------------------- 0) Install CodeTyphon Studio (remove old first) 1) Update CodeTyphon Studio 2) Remove CodeTyphon Studio 9) Exit \u0026gt;\u0026gt;\u0026gt; Select an action (press 0..9 key): 等待执行完，出现以下界面，再次输入0（我就是这里漏掉了，折腾了N多遍） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ==================================================== CodeTyphon Studio 7.30 Setup for Linux64 Settings: Platform=gtk2 Multiarch Mode=0 ==================================================== 0) Install System Libraries 1) Run CodeTyphon Center (CTC) 11) -- Platform (widget) Setup 12) -- Multi-Architecture Setup 3) Remove FreePascal 4) Remove and Build FreePascal 5) Remove Typhon IDE 6) Remove and Build Typhon IDE 7) Remove ALL 8) Remove and Build ALL 9) EXIT \u0026gt;\u0026gt;\u0026gt; Select an action (press 0..9 key): 0 此时，Windows平台会弹出下载安装DirectX的界面，Linux也会下载安装系统所需要的包，这个过程是必须联网进行的。\n安装完之后会回到上一步的界面，输入8\n等待安装结束，查看日志是否安装成功，最后输入9退出\n以上是最基本的采用默认配置的安装步骤，以后摸索多了再更如何自定义配置的安装吧。\nPS：Lazarus安装个组件后就可以变成XE的方式。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/codetyphon_install/","summary":"从其它平台迁移而来\n一直想找个开源的可以商用的Delphi的替代品，能跨平台了最好。开始时试过Lazarus，和D7还真是挺像的，不过用惯了XE，还是想找个习惯相似的IDE，扒拉下论坛后发现了CodeTyphon，就想着试一下。\n下载 下载就不多说了，网上很容易找到，而且官方wiki写得也很好，英文好的可以直接看，像我这样的英语渣渣，还是有必要慢慢去啃的。\nCodeTyphon下载后只有一个CodeTyphonIns.zip的压缩包，无论是Windows、Linux还是MacOS，安装包都是它，因为不管在哪个平台上安装，都是要编译的。\n安装 解压CodeTyphonIns.zip得到CodeTyphonIns\n在Windows平台，以管理员方式运行install.bat；在类unix平台，先cd CodeTyphonIns，再sudo ./install.sh\n出现以下界面，输入0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ==================================================== CodeTyphon Studio Version 7.30 (GEN 7) Installation for Linux-Solaris-Openindiana-MacOS FreeBSD-NetBSD-OpenBSD-DragonFly ==================================================== -----WARNING------ WARNING ----WARNING------- You tryng to install CT as root This is NOT the correct procedure. You MUST start CodeTyphon Installation as normal user with sudo root privileges --------------------------------------------- 0) Install CodeTyphon Studio (remove old first) 1) Update CodeTyphon Studio 2) Remove CodeTyphon Studio 9) Exit \u0026gt;\u0026gt;\u0026gt; Select an action (press 0.","title":"安装 CodeTyphon"},{"content":" 从其它平台迁移而来\n今天在SQL Server的坑里跌得鼻青脸肿，折腾两三个小时，终于爬了出来，特此纪念一下，并以此明志！\n背景 传统行业的老旧ERP项目\n数据库在公司服务器上，版本为SQL Server 2000，本地使用的数据库为SQL Server 2008 R2，数据库工具为Navicat\n多数查询是从视图里查\n部分业务是写在存储过程里\n案发过程 业务功能扩充，需要在数据库中增加几个字段，于是直接从本地SQL Server 2008 R2连接公司SQL Server 2000，在表适当的位置插入所需字段，然后在Navicat中修改对应的视图和存储过程。\n然后，奇怪的事情发生了，程序运行未报错也无错误日志，但就是出不来数据！\n打断点，跟踪调试，发现程序抛了个异常，但是没有任何代码能捕获到，而且也并未层层抛出，不知道中间哪个环节被吃了！先不管是哪吃了，把异常处理了应该就没问题了，毕竟之前都是正常的。\n异常是类型不兼容和类型转换错误，好嘛，开始排查存储过程调用……一切正常！\n把查询的SQL输出，在Navicat中查询，也无结果！把查询条件去掉，结果出来了！排查条件吧，结果发现条件没问题！这TM就有点让人抓狂了！！！\n如此这般折磨几遍之后，结果丝毫没有任何改变！法了个克！\n还是先喝口水压压惊吧，然后！居然！！竟然！！！发现了不正常的东西！！！！一个布尔型的字段里居然出现了字符串！！！！！\n再次排查存储过程，存储过程正常！\n排查视图，视图不正常，但视图的SQL是正确的！这TM是个什么鬼情况？？？\n百思不得其解！\n再喝口水压压惊，把整个修改过程回忆一遍，灵光一闪，发现了点蛛丝马迹：修改视图时，只是在Navicat中确认了下视图的SQL是否正确，因为是正确的，所以并未进行修改！嗯，问题可能就是出在这里！！！\n那就在SQL Server 2008 R2里看一下吧，然后就发现了真相！我只想说：法了个克！！！\n重新修改视图，问题解决！\n真相 真相就是：\n自作聪明的SQL Server其实愚蠢到令人发指！！！\n罢了，还是好好说话吧。\n其实问题还是出在插入字段的这操作上，正常情况下可能是不会出什么问题的，但是当遇到视图里使用SELECT a.*, b.xx, c.xx ...这种方式时，问题就来了。\nNavicat中看到的还是SELECT a.*, b.xx, c.xx ...这种方式，但是在SQL Server中却变成了SELECT a.f1, a.f2, a.f3, b.xx, c.xx ...这种方式，本来这也没什么大不了的，但是偏偏在对a表插入（并非追加）字段时就出问题了，因为SQL Server自己按字段顺序把原有的字段AS成了新字段，由于插入了字段，于是后面的字段就都错位了，结果自然就是驴唇不对马嘴了！\n思考 基于这次的发现，估计在SQL Server中调整字段的顺序也有可能会出现类似的情况，不过没有去测试验证，以后有时间了再说吧（不过估计不会再有时间了吧，就算有时间估计也不会去折腾讨厌的SQL Server吧）。\n另外，服务器的数据库是SQL Server 2000，修改时用的是SQL Server 2008 R2，还不好就此说这是哪个版本出现的问题，也许新版本已经解决过了吧，这还是留给有心的朋友去研究吧。\n最后，我只想说，MySQL它不香么？PostgreSQL它不香么？为什么要把时间浪费在SQL Server上？\n","permalink":"https://afrusrsc.github.io/posts/db/sqlserver_bug/","summary":"从其它平台迁移而来\n今天在SQL Server的坑里跌得鼻青脸肿，折腾两三个小时，终于爬了出来，特此纪念一下，并以此明志！\n背景 传统行业的老旧ERP项目\n数据库在公司服务器上，版本为SQL Server 2000，本地使用的数据库为SQL Server 2008 R2，数据库工具为Navicat\n多数查询是从视图里查\n部分业务是写在存储过程里\n案发过程 业务功能扩充，需要在数据库中增加几个字段，于是直接从本地SQL Server 2008 R2连接公司SQL Server 2000，在表适当的位置插入所需字段，然后在Navicat中修改对应的视图和存储过程。\n然后，奇怪的事情发生了，程序运行未报错也无错误日志，但就是出不来数据！\n打断点，跟踪调试，发现程序抛了个异常，但是没有任何代码能捕获到，而且也并未层层抛出，不知道中间哪个环节被吃了！先不管是哪吃了，把异常处理了应该就没问题了，毕竟之前都是正常的。\n异常是类型不兼容和类型转换错误，好嘛，开始排查存储过程调用……一切正常！\n把查询的SQL输出，在Navicat中查询，也无结果！把查询条件去掉，结果出来了！排查条件吧，结果发现条件没问题！这TM就有点让人抓狂了！！！\n如此这般折磨几遍之后，结果丝毫没有任何改变！法了个克！\n还是先喝口水压压惊吧，然后！居然！！竟然！！！发现了不正常的东西！！！！一个布尔型的字段里居然出现了字符串！！！！！\n再次排查存储过程，存储过程正常！\n排查视图，视图不正常，但视图的SQL是正确的！这TM是个什么鬼情况？？？\n百思不得其解！\n再喝口水压压惊，把整个修改过程回忆一遍，灵光一闪，发现了点蛛丝马迹：修改视图时，只是在Navicat中确认了下视图的SQL是否正确，因为是正确的，所以并未进行修改！嗯，问题可能就是出在这里！！！\n那就在SQL Server 2008 R2里看一下吧，然后就发现了真相！我只想说：法了个克！！！\n重新修改视图，问题解决！\n真相 真相就是：\n自作聪明的SQL Server其实愚蠢到令人发指！！！\n罢了，还是好好说话吧。\n其实问题还是出在插入字段的这操作上，正常情况下可能是不会出什么问题的，但是当遇到视图里使用SELECT a.*, b.xx, c.xx ...这种方式时，问题就来了。\nNavicat中看到的还是SELECT a.*, b.xx, c.xx ...这种方式，但是在SQL Server中却变成了SELECT a.f1, a.f2, a.f3, b.xx, c.xx ...这种方式，本来这也没什么大不了的，但是偏偏在对a表插入（并非追加）字段时就出问题了，因为SQL Server自己按字段顺序把原有的字段AS成了新字段，由于插入了字段，于是后面的字段就都错位了，结果自然就是驴唇不对马嘴了！\n思考 基于这次的发现，估计在SQL Server中调整字段的顺序也有可能会出现类似的情况，不过没有去测试验证，以后有时间了再说吧（不过估计不会再有时间了吧，就算有时间估计也不会去折腾讨厌的SQL Server吧）。\n另外，服务器的数据库是SQL Server 2000，修改时用的是SQL Server 2008 R2，还不好就此说这是哪个版本出现的问题，也许新版本已经解决过了吧，这还是留给有心的朋友去研究吧。\n最后，我只想说，MySQL它不香么？PostgreSQL它不香么？为什么要把时间浪费在SQL Server上？","title":"愚蠢的 SQL Server"},{"content":" 从其它平台迁移而来\n背景 一直以来，都对Linux心中神往，一直以来，也都对bug 10(win 10)深恶痛绝，但是对Linux却始终是浅尝辄止——要么是在虚拟机里玩，要么就是wls，真要装在真机上也不过是停留在安装完而已，真正用起来还是差得太多太远。\n不要跟我提wls2，用这货还得升到最新的bug 10，少不了又是自动升级又是各种应用什么的，那可一点儿都不纯净，还是现在用的LTSC勉强能将就，虽然还是动不动就会自动升级，而且通常还是升级失败再回滚的二货，但是比那种二货都不如的还是要强一些的。\n前段时间老婆打下来一台旧笔记本，i3 M370，4G内存，500G机械盘，也是实实在在的老古董了(还有更老的台机在角落里吃土呢)，但质量还是不错的，运行也还算稳定，就动了心思准备拿来搞Linux，实实在在用起来。\n选择发行版 Linux的发行版还是非常多的，鉴于以前捣鼓的大多都是Debian系的，这次还打算入手Debian系，至于Redhat系，以后再说吧。\n由于是老爷机，桌面环境想要在稳定的基础上尽可能轻量。至于不要桌面环境，彻头彻尾地搞tty，心里还是发怵的，毕竟是以学习为主，免不了要上网查资料，而且我这英语渣渣还是不要搞得太有挑战性，免得一不留神就跑偏了。\nDebian 多年前装过Debian，那时对中文的支持真的是——一言难尽，不过这么多年过去了，可能会有点长进吧，所以就先装了最新的尝试了下，然后……我真的没发现有啥长进的。\nUbuntu Ubuntu是在Debian上弄起来的，最早时候玩的也是这货，wls里也是这货，而且各种桌面环境的发行版也都有，说实话，整体感观还是不错的！只不过这货现在好你搞什么平台大一统的，臃肿了不是一星半点，而且还又搞了个Snap什么的，感觉已经不再是我识别的那个Ubuntu，已经有向bug 10靠拢的倾向了，再加上这是老爷机，果断放弃。\nLinux Mint Linux Mint这货原先是在Ubuntu上搞起来的，当年也试用过Mate版的，体验挺好的，即兼容了Ubuntu的众多优势，又定位于桌面系统，没有变得那么肥胖，算是比较符合我的选择标准了。最近看到有基于Debian的LMDE版，思虑再三，决定就用这货了！\nKali Linux Kali Linux这货也是在Debian上搞起来的，据说是专为黑客而生，估计以后会尝试吧。\n安装LMDE 制作安装盘 下载LMDE的iso镜像\n使用UltraISO把镜像写入U盘\n注意：写入的时候写入方式一定要选择RAW，否则从U盘启动时会报错failed to load ldlinux.c32\n安装 进BIOS设置U盘为第一启动项，保存\n从U盘引导，自动进入Live模式\n运行桌面上Install启动安装向导开始安装\n联网设置先跳过，否则整个安装过程巨漫长\n分区的环节，我直接把原有的分区全删了，使用整块硬盘\n安装grub的分区一定要选好，像我这种直接选了整块硬盘，不管现在选哪个，后期更新时再出现选grub安装分区的一定要和现在选的保持一致(我就是抽风了一下搞得grub引导不了，折腾半天也没修复回来，最后默默选择了重装)\n根据提示拔掉U盘，并按回车重启\n联网更新 联网 重启进入系统后就可以放心的联网了，若是wifi联不上就直接用网线吧。反正我是联不上wifi，起初以为是驱动问题，折腾了一整天也没搞定，后来索性放弃了，估计是无线网卡有问题，以后再说吧。\n更新 菜单-\u0026gt;首选项-\u0026gt;系统设置-\u0026gt;软件源，输入密码，选择一个国内的源，哪个快选哪个就行，当然也可以不选，只要你能忍受那蜗牛速度\n在终端里执行命令sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y，输入密码，等待更新完成\n后记 玩Linux就要敢于折腾、勇于折腾\n不要问我要图，给图了你们还咋折腾？PS:其实是忘了弄，后来又懒得弄\n","permalink":"https://afrusrsc.github.io/posts/os/lmde_install/","summary":"从其它平台迁移而来\n背景 一直以来，都对Linux心中神往，一直以来，也都对bug 10(win 10)深恶痛绝，但是对Linux却始终是浅尝辄止——要么是在虚拟机里玩，要么就是wls，真要装在真机上也不过是停留在安装完而已，真正用起来还是差得太多太远。\n不要跟我提wls2，用这货还得升到最新的bug 10，少不了又是自动升级又是各种应用什么的，那可一点儿都不纯净，还是现在用的LTSC勉强能将就，虽然还是动不动就会自动升级，而且通常还是升级失败再回滚的二货，但是比那种二货都不如的还是要强一些的。\n前段时间老婆打下来一台旧笔记本，i3 M370，4G内存，500G机械盘，也是实实在在的老古董了(还有更老的台机在角落里吃土呢)，但质量还是不错的，运行也还算稳定，就动了心思准备拿来搞Linux，实实在在用起来。\n选择发行版 Linux的发行版还是非常多的，鉴于以前捣鼓的大多都是Debian系的，这次还打算入手Debian系，至于Redhat系，以后再说吧。\n由于是老爷机，桌面环境想要在稳定的基础上尽可能轻量。至于不要桌面环境，彻头彻尾地搞tty，心里还是发怵的，毕竟是以学习为主，免不了要上网查资料，而且我这英语渣渣还是不要搞得太有挑战性，免得一不留神就跑偏了。\nDebian 多年前装过Debian，那时对中文的支持真的是——一言难尽，不过这么多年过去了，可能会有点长进吧，所以就先装了最新的尝试了下，然后……我真的没发现有啥长进的。\nUbuntu Ubuntu是在Debian上弄起来的，最早时候玩的也是这货，wls里也是这货，而且各种桌面环境的发行版也都有，说实话，整体感观还是不错的！只不过这货现在好你搞什么平台大一统的，臃肿了不是一星半点，而且还又搞了个Snap什么的，感觉已经不再是我识别的那个Ubuntu，已经有向bug 10靠拢的倾向了，再加上这是老爷机，果断放弃。\nLinux Mint Linux Mint这货原先是在Ubuntu上搞起来的，当年也试用过Mate版的，体验挺好的，即兼容了Ubuntu的众多优势，又定位于桌面系统，没有变得那么肥胖，算是比较符合我的选择标准了。最近看到有基于Debian的LMDE版，思虑再三，决定就用这货了！\nKali Linux Kali Linux这货也是在Debian上搞起来的，据说是专为黑客而生，估计以后会尝试吧。\n安装LMDE 制作安装盘 下载LMDE的iso镜像\n使用UltraISO把镜像写入U盘\n注意：写入的时候写入方式一定要选择RAW，否则从U盘启动时会报错failed to load ldlinux.c32\n安装 进BIOS设置U盘为第一启动项，保存\n从U盘引导，自动进入Live模式\n运行桌面上Install启动安装向导开始安装\n联网设置先跳过，否则整个安装过程巨漫长\n分区的环节，我直接把原有的分区全删了，使用整块硬盘\n安装grub的分区一定要选好，像我这种直接选了整块硬盘，不管现在选哪个，后期更新时再出现选grub安装分区的一定要和现在选的保持一致(我就是抽风了一下搞得grub引导不了，折腾半天也没修复回来，最后默默选择了重装)\n根据提示拔掉U盘，并按回车重启\n联网更新 联网 重启进入系统后就可以放心的联网了，若是wifi联不上就直接用网线吧。反正我是联不上wifi，起初以为是驱动问题，折腾了一整天也没搞定，后来索性放弃了，估计是无线网卡有问题，以后再说吧。\n更新 菜单-\u0026gt;首选项-\u0026gt;系统设置-\u0026gt;软件源，输入密码，选择一个国内的源，哪个快选哪个就行，当然也可以不选，只要你能忍受那蜗牛速度\n在终端里执行命令sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y，输入密码，等待更新完成\n后记 玩Linux就要敢于折腾、勇于折腾\n不要问我要图，给图了你们还咋折腾？PS:其实是忘了弄，后来又懒得弄","title":"安装LMDE"},{"content":" 从其它平台迁移而来\n在窗体上放4个TRtcHttpServer，依次设置ServerPort为：80、443、8080和8090，并分别命名为HS80、HS443、HS8080和HS8090\n再放3个TRtcDualDataServerLink到窗体上，分别命名为DL80and443、DL8080and8090和DLall\n设置DL80and443的Server属性为HS80，Server2属性为HS443；设置DL8080and8090的Server属性为HS8080，Server2属性为HS8090\n设置DLall的Link属性为DL80and443，Link2属性为DL8080and8090\n再放1个TRtcDataProvider到窗体上，设置Link属性为DLall，并在OnCheckRequest事件里写上代码：\n1 2 3 4 5 with TRtcDataServer(Sender) do begin Accept; Write(\u0026#39;you are on Server \u0026#39; + ServerPort); end; 在窗口OnShow事件里启动所有TRtcHttpServer，在OnClose事件里停止所有TRtcHttpServer\n编译运行\n在浏览器里分别访问http://localhost:80、http://localhost:443、http://localhost:8080、http://localhost:8090\n注意：TRtcDualDataServerLink只能选择设置Server*或Link*！\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/rtc_dual_server/","summary":"从其它平台迁移而来\n在窗体上放4个TRtcHttpServer，依次设置ServerPort为：80、443、8080和8090，并分别命名为HS80、HS443、HS8080和HS8090\n再放3个TRtcDualDataServerLink到窗体上，分别命名为DL80and443、DL8080and8090和DLall\n设置DL80and443的Server属性为HS80，Server2属性为HS443；设置DL8080and8090的Server属性为HS8080，Server2属性为HS8090\n设置DLall的Link属性为DL80and443，Link2属性为DL8080and8090\n再放1个TRtcDataProvider到窗体上，设置Link属性为DLall，并在OnCheckRequest事件里写上代码：\n1 2 3 4 5 with TRtcDataServer(Sender) do begin Accept; Write(\u0026#39;you are on Server \u0026#39; + ServerPort); end; 在窗口OnShow事件里启动所有TRtcHttpServer，在OnClose事件里停止所有TRtcHttpServer\n编译运行\n在浏览器里分别访问http://localhost:80、http://localhost:443、http://localhost:8080、http://localhost:8090\n注意：TRtcDualDataServerLink只能选择设置Server*或Link*！","title":"自学RTC——DualServer"},{"content":" 从其它平台迁移而来\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/rtc/","summary":"从其它平台迁移而来","title":"RTC组件关系图"},{"content":" 从其它平台迁移而来\n核心代码 OnCheckRequest事件中的代码： 1 2 3 with TRtcDataServer(Sender) do if Request.FilePath.Equal(0, \u0026#39;UPLOAD\u0026#39;) then Accept; OnDataReceived事件中的代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 var fname: string; cnt: integer; begin with TRtcDataServer(Sender) do begin if Request.Method = \u0026#39;GET\u0026#39; then begin Write(\u0026#39;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;form enctype=\u0026#34;multipart/form-data\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;\u0026#39;); Write(\u0026#39;Type some text, if you like:\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;textline\u0026#34; size=\u0026#34;30\u0026#34;\u0026gt;\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;Please specify a single file to upload:\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;onefile\u0026#34; size=\u0026#34;40\u0026#34;\u0026gt;\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;Please specify one or more files to upload:\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;morefiles\u0026#34; size=\u0026#34;40\u0026#34; multiple\u0026gt;\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Send\u0026#34;\u0026gt;\u0026#39;); Write(\u0026#39;\u0026lt;/form\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#39;); end else begin Request.Params.AddText(Read); if Request.Complete then begin Write(\u0026#39;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026#39;); if Request.Params[\u0026#39;textline\u0026#39;] \u0026lt;\u0026gt; \u0026#39;\u0026#39; then Write(\u0026#39;You typed this text: \u0026lt;br\u0026gt; \u0026#39; + Request.Params[\u0026#39;textline\u0026#39;] + \u0026#39;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026#39;); // Uploading a single file ... if Request.Params.IsFile(\u0026#39;onefile\u0026#39;) then begin if not DirectoryExists(eUploadFolder.Text) then CreateDir(eUploadFolder.Text); fname := Request.Params[\u0026#39;onefile\u0026#39;]; if Request.Params.GetFile(\u0026#39;onefile\u0026#39;, eUploadFolder.Text + \u0026#39;\\\u0026#39; + ExtractFileName(fname)) then Write(\u0026#39;File \u0026#34;\u0026#39; + fname + \u0026#39;\u0026#34; was uploaded using the \u0026#34;single file\u0026#34; field.\u0026lt;br\u0026gt;\u0026#39;) else Write(\u0026#39;Error receiving File \u0026#34;\u0026#39; + fname + \u0026#39;\u0026#34;.\u0026lt;br\u0026gt;\u0026#39;); end else Write(\u0026#39;Single file was NOT uploaded (OneFile parameter empty) \u0026lt;br\u0026gt;.\u0026#39;); // Uploading one or more files ... if Request.Params.IsFile(\u0026#39;morefiles\u0026#39;) then begin if not DirectoryExists(eUploadFolder.Text) then CreateDir(eUploadFolder.Text); for cnt := 0 to Request.Params.ElementCount[\u0026#39;morefiles\u0026#39;] - 1 do begin fname := Request.Params.Element[\u0026#39;morefiles\u0026#39;, cnt]; if Request.Params.GetFile(\u0026#39;morefiles\u0026#39;, eUploadFolder.Text + \u0026#39;\\\u0026#39; + ExtractFileName(fname), cnt) then Write(\u0026#39;File \u0026#34;\u0026#39; + fname + \u0026#39;\u0026#34; was uploaded using the \u0026#34;more files\u0026#34; field at [\u0026#39; + IntToStr(cnt) + \u0026#39;].\u0026lt;br\u0026gt;\u0026#39;) else Write(\u0026#39;Error receiving File \u0026#34;\u0026#39; + fname + \u0026#39;\u0026#34;.\u0026lt;br\u0026gt;\u0026#39;); end; end else Write(\u0026#39;Multiple files were NOT uploaded (MoreFiles parameter empty).\u0026#39;); Write(\u0026#39;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#39;); end; end; end; end; ","permalink":"https://afrusrsc.github.io/posts/program/pascal/rtc_browser_upload/","summary":"从其它平台迁移而来\n核心代码 OnCheckRequest事件中的代码： 1 2 3 with TRtcDataServer(Sender) do if Request.FilePath.Equal(0, \u0026#39;UPLOAD\u0026#39;) then Accept; OnDataReceived事件中的代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 var fname: string; cnt: integer; begin with TRtcDataServer(Sender) do begin if Request.","title":"自学RTC——BrowserUpload"},{"content":" 从其它平台迁移而来\n对于上节的示例中，比较适合发送小文件，若直接用于发送大文件的话，很容易把服务器的内存资源耗尽。当请求大文件时，可以限制每次发送大文件时使用的内存大小（例如16000 B）。\n打开上节的工程\n修改RtcDataProvider3的OnCheckRequest事件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var fname: string; begin with TRtcDataServer(Sender) do begin fname := GetFullFileName(Request.FileName); if (fname \u0026lt;\u0026gt; \u0026#39;\u0026#39;) and (File_Exists(fname)) then begin Accept; Request.Info[\u0026#39;fname\u0026#39;] := fname; Response.ContentLength := File_Size(fname); WriteHeader; end; end; end; 修改RtcDataProvider3的OnDataReceived事件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var fname: string; len: cardinal; begin with TRtcDataServer(Sender) do if Request.Complete then begin if Response.ContentLength \u0026gt; Response.ContentOut then begin fname := Request.Info[\u0026#39;fname\u0026#39;]; if File_Size(fname) = Response.ContentLength then begin len := Response.ContentLength - Response.ContentOut; if len \u0026gt; 16000 then len := 16000; Write(Read_File(fname, Response.ContentOut, len)); end else Disconnect; end; end; end; 关联RtcDataProvider3的OnDataSent事件到OnDataReceived事件的实现，使两个事件都指向同一段代码\n编译并运行\n在data文件夹下放入一个大文件（例如test.mp3），访问网址http://localhost/test.mp3\n流程分析 为了更进一步了解整个过程，把RtcHttpServer1和RtcDataProvider3的每个事件都记录进日志：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 [22:36:08.272] RtcHttpServer1ListenStart-\u0026gt; [22:36:08.292] RtcDataProvider3ListenStart-\u0026gt; [22:36:26.108] RtcHttpServer1ClientConnect-\u0026gt; [22:36:26.118] RtcHttpServer1Connecting-\u0026gt; [22:36:26.130] RtcHttpServer1Connect-\u0026gt; [22:36:26.160] RtcHttpServer1DataIn-\u0026gt; [22:36:26.164] RtcDataProvider3CheckRequest-\u0026gt;请求文件：F:\\RTC\\bin\\data\\test.ppt [12521984 B] [22:36:26.169] RtcHttpServer1RequestAccepted-\u0026gt; [22:36:26.175] RtcDataProvider3DataOut-\u0026gt; [22:36:26.178] RtcHttpServer1DataOut-\u0026gt; [22:36:26.257] RtcHttpServer1PeekRequest-\u0026gt; [22:36:26.262] RtcDataProvider3DataReceived-\u0026gt;剩余：12521984 B [22:36:26.276] RtcDataProvider3DataOut-\u0026gt; [22:36:26.281] RtcHttpServer1DataOut-\u0026gt; [22:36:26.286] RtcDataProvider3DataSent-\u0026gt;剩余：12505984 B [22:36:26.301] RtcDataProvider3DataOut-\u0026gt; [22:36:26.311] RtcHttpServer1DataOut-\u0026gt; [22:36:26.316] RtcDataProvider3ReadyToSend-\u0026gt; [22:36:26.323] RtcDataProvider3DataSent-\u0026gt;剩余：12489984 B [22:36:26.338] RtcDataProvider3DataOut-\u0026gt; [22:36:26.345] RtcHttpServer1DataOut-\u0026gt; ... [22:36:50.488] RtcDataProvider3ReadyToSend-\u0026gt; [22:36:50.494] RtcDataProvider3DataSent-\u0026gt;剩余：9984 B [22:36:50.507] RtcDataProvider3DataOut-\u0026gt; [22:36:50.515] RtcHttpServer1DataOut-\u0026gt; [22:36:50.522] RtcDataProvider3ReadyToSend-\u0026gt; [22:36:50.528] RtcDataProvider3DataSent-\u0026gt; [22:36:50.534] RtcDataProvider3ResponseDone-\u0026gt; [22:36:50.540] RtcHttpServer1ResponseDone-\u0026gt; [22:38:45.919] RtcHttpServer1Disconnecting-\u0026gt; [22:38:45.950] RtcHttpServer1Disconnect-\u0026gt; [22:38:45.968] RtcHttpServer1ClientDisconnect-\u0026gt; [22:46:04.945] RtcDataProvider1ListenStop-\u0026gt; [22:46:04.955] RtcHttpServer1ListenStop-\u0026gt; 服务端启动，RtcHttpServer1开始监听，RtcDataProvider3随着也开始监听\n在浏览器中请求文件，RtcHttpServer1收到客户端的连接，RtcHttpServer1开始连接，连接成功，RtcHttpServer1收到数据（请求），RtcDataProvider3也收到请求\nRtcDataProvider3在OnCheckRequest事件中检查请求，文件存在，接受请求\nRtcHttpServer1确定请求被接受，RtcDataProvider3把文件名写入请求信息Request.Info['fname']中备用，把文件大小写入到响应长度Response.ContentLength里，然后把响应头发送出去（实际是发送给RtcHttpServer1，然后RtcHttpServer1把响应最终发出）\nRtcHttpServer1Peek请求，RtcDataProvider3触发OnDataReceived事件\nRtcDataProvider3接收到完整的请求后才进行处理，文件未发现修改（大小未改变）且文件超过16000 B，只发送16000 B（发给RtcHttpServer1，RtcHttpServer1再转发）\nRtcDataProvider3数据发出，触发OnDataSent事件，事件处理中发现文件未发完，准备数据继续发送（依然是只发送16000 B，由RtcHttpServer1转发），发送后又触发OnDataSent事件……\n直到文件数据全部发送完，RtcDataProvider3完成响应，RtcHttpServer1也完成响应\n浏览器关闭，RtcHttpServer1开始断开连接，连接断开\n关闭服务端，RtcDataProvider3停止监听，RtcHttpServer1也停止监听\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson4/","summary":"从其它平台迁移而来\n对于上节的示例中，比较适合发送小文件，若直接用于发送大文件的话，很容易把服务器的内存资源耗尽。当请求大文件时，可以限制每次发送大文件时使用的内存大小（例如16000 B）。\n打开上节的工程\n修改RtcDataProvider3的OnCheckRequest事件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var fname: string; begin with TRtcDataServer(Sender) do begin fname := GetFullFileName(Request.FileName); if (fname \u0026lt;\u0026gt; \u0026#39;\u0026#39;) and (File_Exists(fname)) then begin Accept; Request.Info[\u0026#39;fname\u0026#39;] := fname; Response.ContentLength := File_Size(fname); WriteHeader; end; end; end; 修改RtcDataProvider3的OnDataReceived事件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var fname: string; len: cardinal; begin with TRtcDataServer(Sender) do if Request.","title":"自学RTC——ServerLesson4"},{"content":" 从其它平台迁移而来\n/test.txt 打开上节的工程\n添加组件RtcDataProvider3并设置Server属性为RtcHttpServer1，设置CheckOrder属性为900，使得RtcDataProvider3所处理的请求在其它请求之后（CheckOrder越小越先处理）\n在当前exe所在路径下创建一个data文件夹，并在该文件夹内新建一个有内容的test.txt，然后编写一个GetFullFileName函数，用于从请求中提取文件名并转化为本地文件名\n1 2 3 4 5 6 7 8 9 10 11 12 13 function GetFullFileName(fname: string): string; var DocRoot: string; begin DocRoot := ExtractFilePath(AppFileName); if Copy(DocRoot, length(DocRoot), 1) = \u0026#39;\\\u0026#39; then Delete(DocRoot, length(DocRoot), 1); DocRoot := DocRoot + \u0026#39;\\data\u0026#39;; fname := StringReplace(fname, \u0026#39;/\u0026#39;, \u0026#39;\\\u0026#39;, [rfreplaceall]); Result := ExpandFileName(DocRoot + fname); if UpperCase(Copy(Result, 1, length(DocRoot))) \u0026lt;\u0026gt; UpperCase(DocRoot) then Result := \u0026#39;\u0026#39;; end; 在RtcDataProvider3的OnCheckRequest事件中写上代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 var fname: string; begin with TRtcDataServer(Sender) do begin fname := GetFullFileName(Request.FileName); if (fname \u0026lt;\u0026gt; \u0026#39;\u0026#39;) and (File_Exists(fname)) then begin Accept; Request.Info[\u0026#39;fname\u0026#39;] := fname; end; end; end; 在RtcDataProvider3的OnDataReceived事件中写上代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 procedure TForm1.RtcDataProvider3DataReceived(Sender: TRtcConnection); var fname: string; begin with TRtcDataServer(Sender) do if Request.Complete then begin fname := Request.Info[\u0026#39;fname\u0026#39;]; if File_Exists(fname) then Write(Read_File(fname)) else Write; end; end; 编译并运行\n打开浏览器，访问网址http://localhost/test.txt\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson3/","summary":"从其它平台迁移而来\n/test.txt 打开上节的工程\n添加组件RtcDataProvider3并设置Server属性为RtcHttpServer1，设置CheckOrder属性为900，使得RtcDataProvider3所处理的请求在其它请求之后（CheckOrder越小越先处理）\n在当前exe所在路径下创建一个data文件夹，并在该文件夹内新建一个有内容的test.txt，然后编写一个GetFullFileName函数，用于从请求中提取文件名并转化为本地文件名\n1 2 3 4 5 6 7 8 9 10 11 12 13 function GetFullFileName(fname: string): string; var DocRoot: string; begin DocRoot := ExtractFilePath(AppFileName); if Copy(DocRoot, length(DocRoot), 1) = \u0026#39;\\\u0026#39; then Delete(DocRoot, length(DocRoot), 1); DocRoot := DocRoot + \u0026#39;\\data\u0026#39;; fname := StringReplace(fname, \u0026#39;/\u0026#39;, \u0026#39;\\\u0026#39;, [rfreplaceall]); Result := ExpandFileName(DocRoot + fname); if UpperCase(Copy(Result, 1, length(DocRoot))) \u0026lt;\u0026gt; UpperCase(DocRoot) then Result := \u0026#39;\u0026#39;; end; 在RtcDataProvider3的OnCheckRequest事件中写上代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 var fname: string; begin with TRtcDataServer(Sender) do begin fname := GetFullFileName(Request.","title":"自学RTC——ServerLesson3"},{"content":" 从其它平台迁移而来\n/SQUARE 打开上节的工程\n添加组件RtcDataProvider2并设置Server属性为RtcHttpServer1\n在RtcDataProvider2的OnCheckRequest事件中写上代码：\n1 2 3 with TRtcDataServer(Sender) do if UpperCase(Request.FileName)=\u0026#39;/SQUARE\u0026#39; then Accept; 在RtcDataProvider2的OnDataReceived事件中写上代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var line:integer; begin with TRtcDataServer(Sender) do if Request.Complete then begin Write(\u0026#39;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026#39;); Write(\u0026#39;Here comes a table of square values ... \u0026lt;br\u0026gt;\u0026#39;); for line:=1 to 100 do begin // 使用3个 write 和使用1个效果是一样的 Write(\u0026#39;Square of \u0026#39;+IntToStr(line)+\u0026#39; = \u0026#39;); Write(IntToStr(line*line)); Write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39;); end; Write(\u0026#39;......... done.\u0026#39;); Write(\u0026#39;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#39;); end; end; 编译并运行\n打开浏览器，分别访问网址http://localhost/square、http://localhost/time\n细节 TRtcDataProvider只响应自己接收的请求，互不干涉\nTRtcDataServer(Sender) VS Sender as TRtcDataServer，考察下as与强转的效果和区别\n使用多个write()与使用一个效果一样\n带参数的/SQUARE 修改RtcDataProvider2的OnDataReceived事件的代码为： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 var cnt,line:integer; begin with TRtcDataServer(Sender) do if Request.Complete then begin Write(\u0026#39;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026#39;); Write(\u0026#39;Here comes a table of square values ... \u0026lt;br\u0026gt;\u0026#39;); cnt:=0; if Request.Query[\u0026#39;cnt\u0026#39;]\u0026lt;\u0026gt;\u0026#39;\u0026#39; then try cnt:=StrToInt(Request.Query[\u0026#39;cnt\u0026#39;]); except end; if (cnt\u0026lt;1)or (cnt\u0026gt;1000) then begin cnt:=10; Write(\u0026#39;Wrong \u0026#34;cnt\u0026#34; parameter.\u0026#39;); Write(\u0026#39;Using default value of 10.\u0026lt;br\u0026gt;\u0026#39;); end; for line:=1 to cnt do begin Write(\u0026#39;Square of \u0026#39;+IntToStr(line)+\u0026#39; = \u0026#39;+IntToStr(line*line)); Write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39;); end; Write(\u0026#39;......... done.\u0026#39;); Write(\u0026#39;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#39;); end; end; 编译并运行\n打开浏览器，分别访问网址http://localhost/square、http://localhost/square?cnt=30、http://localhost/square?cnt=5392\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson2/","summary":"从其它平台迁移而来\n/SQUARE 打开上节的工程\n添加组件RtcDataProvider2并设置Server属性为RtcHttpServer1\n在RtcDataProvider2的OnCheckRequest事件中写上代码：\n1 2 3 with TRtcDataServer(Sender) do if UpperCase(Request.FileName)=\u0026#39;/SQUARE\u0026#39; then Accept; 在RtcDataProvider2的OnDataReceived事件中写上代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var line:integer; begin with TRtcDataServer(Sender) do if Request.Complete then begin Write(\u0026#39;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026#39;); Write(\u0026#39;Here comes a table of square values ... \u0026lt;br\u0026gt;\u0026#39;); for line:=1 to 100 do begin // 使用3个 write 和使用1个效果是一样的 Write(\u0026#39;Square of \u0026#39;+IntToStr(line)+\u0026#39; = \u0026#39;); Write(IntToStr(line*line)); Write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39;); end; Write(\u0026#39;.","title":"自学RTC——ServerLesson2"},{"content":" 从其它平台迁移而来\nRTC全称RealThinClient，据说是Delphi做三层的神器之一，虽然听说已久，却始终未好好研究过，而且安装包里带的有示例源码，于是乎，索性拿这些源码开这么个系列，督促下自己。\n步骤 创建一个新工程\n从RTC Server组件页中找到RtcHttpServer组件放到窗体上\n设置RtcHttpServer1的ServerPort属性为80\n在窗体的OnCreate事件里写上代码：\n1 RtcHttpServer1.Listen; 从RTC Server组件页中找到RtcDataProvider组件放到窗体上\n设置RtcDataProvider1的Server属性为RtcHttpServer1\n在RtcDataProvider1的OnCheckRequest事件中写上代码：\n1 2 3 with Sender as TRtcDataServer do if UpperCase(Request.FileName)=\u0026#39;/TIME\u0026#39; then Accept; 在RtcDataProvider1的OnDataReceived事件中写上代码： 1 2 3 with Sender as TRtcDataServer do if Request.Complete then Write(\u0026#39;Current time is: \u0026#39;+TimeToStr(Now)); 编译并运行\n打开浏览器，访问网址http://localhost/time\n示例源码 核心源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 procedure TForm1.RtcDataProvider1CheckRequest(Sender: TRtcConnection); begin with Sender as TRtcDataServer do if Request.FilePath.Equal(0,\u0026#39;TIME\u0026#39;) then Accept; end; procedure TForm1.RtcDataProvider1DataReceived(Sender: TRtcConnection); var a:integer; begin with Sender as TRtcDataServer do if Request.Complete then begin Write(\u0026#39;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026#39;); Write(\u0026#39;Request from \u0026#39;+Sender.PeerAddr+\u0026#39;:\u0026#39;+Sender.PeerPort+\u0026#39;\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;Server time: \u0026#39;+TimeToStr(Now)+\u0026#39;\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;\u0026lt;br\u0026gt;URL = \u0026#39;+Request.URL+\u0026#39;\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;\u0026lt;br\u0026gt;URI = \u0026#39;+Request.URI+\u0026#39;\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;\u0026lt;br\u0026gt;FileName = \u0026#39;+Request.FileName+\u0026#39;\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;\u0026lt;br\u0026gt;FilePath.Count = \u0026#39;+IntToStr(Request.FilePath.Count)+\u0026#39;\u0026lt;br\u0026gt;\u0026#39;); for a:=0 to Request.FilePath.Count-1 do Write(\u0026#39;FilePath[\u0026#39;+IntToStr(a)+\u0026#39;] = \u0026#34;\u0026#39;+Request.FilePath[a]+\u0026#39;\u0026#34;\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;\u0026lt;br\u0026gt;Query.ItemCount = \u0026#39;+IntToStr(Request.Query.ItemCount)+\u0026#39;\u0026lt;br\u0026gt;\u0026#39;); for a:=0 to Request.Query.ItemCount-1 do Write(\u0026#39;Query Item \u0026#39;+IntToStr(a)+\u0026#39;: \u0026#39;+ \u0026#39;Name = \u0026#34;\u0026#39;+Request.Query.ItemName[a]+\u0026#39;\u0026#34;; \u0026#39;+ \u0026#39;Value = \u0026#34;\u0026#39;+Request.Query.ItemValue[a]+\u0026#39;\u0026#34;\u0026lt;br\u0026gt;\u0026#39;); Write(\u0026#39;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#39;); end; end; 测试 浏览器访问http://localhost/time： 1 2 3 4 5 6 7 8 9 10 11 12 13 Request from 127.0.0.1:60623 Server time: 21:12:30 URL = localhost/time URI = /time FileName = /time FilePath.Count = 1 FilePath[0] = \u0026#34;time\u0026#34; Query.ItemCount = 0 浏览器访问http://localhost/times： 返回错误\n浏览器访问http://localhost/time/test/abc： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Request from 127.0.0.1:60704 Server time: 21:22:32 URL = localhost/time/test/abc URI = /time/test/abc FileName = /time/test/abc FilePath.Count = 3 FilePath[0] = \u0026#34;time\u0026#34; FilePath[1] = \u0026#34;test\u0026#34; FilePath[2] = \u0026#34;abc\u0026#34; Query.ItemCount = 0 浏览器访问http://localhost/time?test=abc： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Request from 127.0.0.1:60725 Server time: 21:24:06 URL = localhost/time?test=abc URI = /time?test=abc FileName = /time FilePath.Count = 1 FilePath[0] = \u0026#34;time\u0026#34; Query.ItemCount = 1 Query Item 0: Name = \u0026#34;test\u0026#34;; Value = \u0026#34;abc\u0026#34; 源码解读 Request.FilePath.Equal(0,'TIME') VS UpperCase(Request.FileName)='/TIME' 从响应结果可以看出：\n两者都忽略了大小写\n两者都不能响应/times\n前者可以响应以/time开头的所有请求，并且把请求分解后放在FilePath[]里；后者则只能响应/time\n两者都能响应带参数的/time\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson1/","summary":"从其它平台迁移而来\nRTC全称RealThinClient，据说是Delphi做三层的神器之一，虽然听说已久，却始终未好好研究过，而且安装包里带的有示例源码，于是乎，索性拿这些源码开这么个系列，督促下自己。\n步骤 创建一个新工程\n从RTC Server组件页中找到RtcHttpServer组件放到窗体上\n设置RtcHttpServer1的ServerPort属性为80\n在窗体的OnCreate事件里写上代码：\n1 RtcHttpServer1.Listen; 从RTC Server组件页中找到RtcDataProvider组件放到窗体上\n设置RtcDataProvider1的Server属性为RtcHttpServer1\n在RtcDataProvider1的OnCheckRequest事件中写上代码：\n1 2 3 with Sender as TRtcDataServer do if UpperCase(Request.FileName)=\u0026#39;/TIME\u0026#39; then Accept; 在RtcDataProvider1的OnDataReceived事件中写上代码： 1 2 3 with Sender as TRtcDataServer do if Request.Complete then Write(\u0026#39;Current time is: \u0026#39;+TimeToStr(Now)); 编译并运行\n打开浏览器，访问网址http://localhost/time\n示例源码 核心源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 procedure TForm1.","title":"自学RTC——ServerLesson1"},{"content":" 从其它平台迁移而来\n初学Go时，用的都是GOPATH模式，要么代码得写在一个固定的路径下，要么得改系统变量，从始至终只有一个项目也就忍了，可明显这是不可能的，多个项目，想想就要抓狂。\n还好有GO MOD模式，虽然也看网上的帖子了，不过一直没尝试。终于，还是要亲自尝试下才有长进。\n准备 golang v1.11+ 据说要使用GO MOD模式，必须要使用v1.11以上的版本（这里是直接用最新的v1.15.3）。\nIDE 好用的果然还是JB家的Goland，不过吾等P民囊中羞涩，还是果断VS Code+插件。\n代理 由于众所周知的原因，我们需要准备好代理，代理的使用略。\nGO MOD 打开命令行\n在GOPATH之外任意新建一个空测试目录，并cd进去\n执行命令go mod init XXX（XXX为项目名），会生成一个go.mod文件，内容如下：\n1 2 3 module gmtest go 1.15 以使用GoFrame为例， 修改go.mod加上gf 1 2 3 4 5 module gmtest go 1.15 require github.com/gogf/go latest latest表示使用最新版本。\n编写Go代码 1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gogf/gf\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello GF\u0026#34;, gf.VERSION) } 执行go run main.go编译运行（注意使用代理），会生成go.sum文件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU= github.com/clbanning/mxj v1.8.5-0.20200714211355-ff02cfb8ea28/go.mod h1:BVjHeAH+rl9rs6f+QIpeRl0tfu10SXn1pUSa5PVGJng= github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38= github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38= github.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ= github.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg= github.com/gogf/gf v1.14.0 h1:cO7yqWQB8PVCQ8ynTARd/LDQvJdzA6ZkUSr7GPslmFI= github.com/gogf/gf v1.14.0/go.mod h1:7b21qQKDyIwJO4PkBCxVci5C62tm89MANGV2wJgAf50= github.com/gomodule/redigo v2.0.0+incompatible/go.mod h1:B4C85qUVwatsJoIUNIfCRsp7qO0iAmpGFZ4EELWSbC4= github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg= github.com/gorilla/websocket v1.4.1/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE= github.com/gqcn/structs v1.1.1/go.mod h1:/aBhTBSsKQ2Ec9pbnYdGphtdWXHFn4KrCL0fXM/Adok= github.com/grokify/html-strip-tags-go v0.0.0-20190921062105-daaa06bf1aaf/go.mod h1:2Su6romC5/1VXOQMaWL2yb618ARB8iVo6/DR99A6d78= github.com/json-iterator/go v1.1.10/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4= github.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI= github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q= github.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0= github.com/olekukonko/tablewriter v0.0.1/go.mod h1:vsDQFd/mU46D+Z4whnwzcISnGGzXWMclvtLoiIKAKIo= github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4= github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME= github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI= golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w= golang.org/x/net v0.0.0-20200602114024-627f9648deb9/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A= golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY= golang.org/x/sys v0.0.0-20191005200804-aed5e4c7ecf9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs= golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs= golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ= golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk= golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ= gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0= gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM= 同时go.mod文件也会被修改：\n1 2 3 4 5 module gmtest go 1.15 require github.com/gogf/gf v1.14.0 以后维护好该项目的go.mod文件即可 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_gomod/","summary":"从其它平台迁移而来\n初学Go时，用的都是GOPATH模式，要么代码得写在一个固定的路径下，要么得改系统变量，从始至终只有一个项目也就忍了，可明显这是不可能的，多个项目，想想就要抓狂。\n还好有GO MOD模式，虽然也看网上的帖子了，不过一直没尝试。终于，还是要亲自尝试下才有长进。\n准备 golang v1.11+ 据说要使用GO MOD模式，必须要使用v1.11以上的版本（这里是直接用最新的v1.15.3）。\nIDE 好用的果然还是JB家的Goland，不过吾等P民囊中羞涩，还是果断VS Code+插件。\n代理 由于众所周知的原因，我们需要准备好代理，代理的使用略。\nGO MOD 打开命令行\n在GOPATH之外任意新建一个空测试目录，并cd进去\n执行命令go mod init XXX（XXX为项目名），会生成一个go.mod文件，内容如下：\n1 2 3 module gmtest go 1.15 以使用GoFrame为例， 修改go.mod加上gf 1 2 3 4 5 module gmtest go 1.15 require github.com/gogf/go latest latest表示使用最新版本。\n编写Go代码 1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gogf/gf\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello GF\u0026#34;, gf.VERSION) } 执行go run main.","title":"使用gomod"},{"content":" 从其它平台迁移而来\n之前就想搞个数据连接池，结果太麻烦就放弃了，不想却在TFDConnection中看到了Pooled属性，就一路挖了下来，还真就是那么回事！\nTFDManager 之前只知道，放上TFDManager控件后，什么都不用做，就可以在别的单元引用该单元后直接连接到TFDConnection控件了；现在，数据连接池还是要通过TFDManager来实现。\n设置数据连接池参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //指定动态库 FDPhysMySQLDriverLink.VendorLib := \u0026#39;libmysql.dll\u0026#39;; //设置连接参数 with FDManager.ConnectionDefs.AddConnectionDef do begin Name := \u0026#39;MySQL_Conn\u0026#39;; Params.DriverID := \u0026#39;MySQL\u0026#39;; Params.Add(\u0026#39;CharacterSet=csUtf8mb4\u0026#39;); Params.Add(\u0026#39;Server=127.0.0.1\u0026#39;); Params.Add(\u0026#39;Port=3306\u0026#39;); Params.Database := \u0026#39;test\u0026#39;; Params.UserName := \u0026#39;root\u0026#39;; Params.Password := \u0026#39;123456\u0026#39;; Params.PoolMaximumItems := 10; Params.Pooled := True; end; 以上是以MySQL为例，其它数据库参照即可。\n打开连接池 1 FDManager.Open; 获取连接 1 2 FDConnection.ConnectionDefName := \u0026#39;MySQL_Conn\u0026#39;; FDConnection.Connected := True; 归还连接 FDConnection直接放到窗体上，或动态创建，写上如下代码即可，无需在设计器里设置任何东西。\n1 FDConnection.Connected := False; 关闭连接池 1 FDManager.Close; ","permalink":"https://afrusrsc.github.io/posts/program/pascal/firedac_fdconnection_pool/","summary":"从其它平台迁移而来\n之前就想搞个数据连接池，结果太麻烦就放弃了，不想却在TFDConnection中看到了Pooled属性，就一路挖了下来，还真就是那么回事！\nTFDManager 之前只知道，放上TFDManager控件后，什么都不用做，就可以在别的单元引用该单元后直接连接到TFDConnection控件了；现在，数据连接池还是要通过TFDManager来实现。\n设置数据连接池参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //指定动态库 FDPhysMySQLDriverLink.VendorLib := \u0026#39;libmysql.dll\u0026#39;; //设置连接参数 with FDManager.ConnectionDefs.AddConnectionDef do begin Name := \u0026#39;MySQL_Conn\u0026#39;; Params.DriverID := \u0026#39;MySQL\u0026#39;; Params.Add(\u0026#39;CharacterSet=csUtf8mb4\u0026#39;); Params.Add(\u0026#39;Server=127.0.0.1\u0026#39;); Params.Add(\u0026#39;Port=3306\u0026#39;); Params.Database := \u0026#39;test\u0026#39;; Params.UserName := \u0026#39;root\u0026#39;; Params.Password := \u0026#39;123456\u0026#39;; Params.PoolMaximumItems := 10; Params.Pooled := True; end; 以上是以MySQL为例，其它数据库参照即可。\n打开连接池 1 FDManager.Open; 获取连接 1 2 FDConnection.ConnectionDefName := \u0026#39;MySQL_Conn\u0026#39;; FDConnection.Connected := True; 归还连接 FDConnection直接放到窗体上，或动态创建，写上如下代码即可，无需在设计器里设置任何东西。","title":"FireDAC的数据连接池"},{"content":" 从其它平台迁移而来\n由于长期使用Delphi开发，又与硬件打交道比较多，不可避免地要与标准C动态库进行对接，而往往厂家提供的SDK又偏偏没有Delphi的，无奈也就只好自己改写.h头文件了。写得多了，也就有了一点点心得，在这里就分享出来，也好与大家互相交流、学习。\n知识点 标准C动态库使用的都是单字节字符。\nDelphi 2007以前默认使用的是单字节字符，即Ansi编码，也就是说Char = AnsiChar、PChar = PAnsiChar、string = AnsiString；Delphi 2009以后使用的是双字节字符，即Unicode编码，也就是说Char = WideChar、PChar = PWideChar、string = WideString。为了保证改写后的.pas文件适用于Dephi的各个版本，应避免使用Char、PChar、string这种类型不明确的数据类型（通常情况下使用AnsiChar、PAnsiChar、AnsiString即可，但特殊情况要特殊处理）。\n@string[1]才是字符串首地址。\nDelphi中可以把AnsiString当作缓冲区来使用，某些情况下比array of Byte要方便得多。\n对字符串变量第一次使用SetLengh时会重新分配内存，第二次使用时，若设定的长度比第一次小，则只会进行截断而并不改变已写入的内容，该特性在使用API返回字符串时非常好用。\nDelphi中的record是进行过字节对齐的，执行效率高，但占用空间比看到的会略大；packed record是未进行过字节对齐的，执行效率略低，但占用空间与看到的保持一致。也就是说，Delphi中packed record才是与C中的struct等同。\n在Delphi中packed record配合case可以实现C中的union，具体是否等同还要看实际定义的字节是否一致（需要对每种数据类型占用的空间十分熟悉）。\n标准C动态库的API函数或回调函数，在Delphi中均要使用stdcall;来修饰，以确保传参顺序一致。\n数据类型对应关系 C/C++ 类型 Delphi 基本类型 Delphi Window 单元类型 说明 char ShortInt / Int8 8位有符号整型 char* PShortInt unsigned char / BYTE Byte / UInt8 UCHAR 8位无符号整型，字节型 unsigned char* PByte LPBYTE / PUCHAR short SmallInt / Int16 SHORT 16位有符号整型 short* PSmallInt PSHORT unsigned short Word / UInt16 WORD 16位无符号整型 unsigned short* PWord PUSHORT int / long Integer / Longint / Int32 LONG 32位有符号整型 int* / long* PInteger / PLongInt PLONG unsigned / unsigned int / unsigned long Cardinal / LongWord / UInt32 DWORD / UINT / ULONG / ULONG32 32位无符号整型 unsigned int* / unsigned long* PCardinal / PLongWord / PUint32 PDWORD / PUINT / PULONG long long / __int64 Int64 LONG64 / LONGLONG 64位有符号整型 long long* / __int64* PInt64 PLONG64 unsigned long long / unsigned __int64 UInt64 ULONG64 / ULONGLONG / DWORD64 64位无符号整型 unsigned long long* / unsigned __int64* PUInt64 PULONG64 / PULONGLONG / PDWORD64 float Single / Float32 32位单精度浮点型 float* PSingle double Double / Float64 64位双精度浮点型 double* PDouble long double Extended 10字节浮点型 char AnsiChar 单字节字符 char* PAnsiChar LPSTR / LPCSTR char** PPAnsiChar wchar_t / WCHAR WideChar WCHAR 双字节字符 wchar_t* PWideChar PWChar / LPWSTR / LPCWSTR wchar_t** PPWideChar 任意1字节类型 Boolean / ByteBool 1字节布尔型 任意1字节类型指针 PBoolean / PByteBool 任意2字节类型 WordBool 2字节布尔型 任意2字节类型指针 PWordBool BOOL LongBool BOOL 4字节布尔型 BOOL* PLongBool PBOOL void* Pointer PVOID / LPVOID / LPCVOID 无类型指针 void** PPointer PPVOID 升华 有了以上知识，把.h头文件改为.pas单元是不成问题了，但改写后的API是否好用，还要打个问号。\n比如有以下API：\n1 BOOL __stdcall GetFileName(char * strFileName, int * iLen); 按前面提到的改为.pas单元：\n1 2 3 4 //声明 function GetFileName(strFileName: PAnsiChar; iLen: PInteger): LongBool; stdcall; //调用 b := GetFileName(ps, @l); 改写没有任何问题，但是不如以下这种直观、方便，毕竟有不少人对指针和地址还是相当恐惧的。\n1 2 3 4 //声明 function GetFileName(strFileName: PAnsiChar; var iLen: Integer): LongBool; stdcall; //调用 b := GetFileName(ps, l); 假如以上API为：\n1 BOOL __stdcall GetPic(char * pBuff, int * iLen); 那么，生硬的改成\n1 function GetPic(pBuff: PAnsiChar; iLen: PInteger): LongBool; stdcall; 就不如改为\n1 2 3 4 5 function GetPic(pBuff: PByte; var iLen: Integer): LongBool; stdcall; //或 function GetPic(pBuff: Pointer; var iLen: Integer): LongBool; stdcall; //甚至 function GetPic(var pBuff: TBytes; var iLen: Integer): LongBool; stdcall; 改写不仅仅是为了改写，更是为了调用。当然，若是再加一层封装来给其它单元调用，甚至直接封装成类，那是再好不过了！\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/h2pas/","summary":"从其它平台迁移而来\n由于长期使用Delphi开发，又与硬件打交道比较多，不可避免地要与标准C动态库进行对接，而往往厂家提供的SDK又偏偏没有Delphi的，无奈也就只好自己改写.h头文件了。写得多了，也就有了一点点心得，在这里就分享出来，也好与大家互相交流、学习。\n知识点 标准C动态库使用的都是单字节字符。\nDelphi 2007以前默认使用的是单字节字符，即Ansi编码，也就是说Char = AnsiChar、PChar = PAnsiChar、string = AnsiString；Delphi 2009以后使用的是双字节字符，即Unicode编码，也就是说Char = WideChar、PChar = PWideChar、string = WideString。为了保证改写后的.pas文件适用于Dephi的各个版本，应避免使用Char、PChar、string这种类型不明确的数据类型（通常情况下使用AnsiChar、PAnsiChar、AnsiString即可，但特殊情况要特殊处理）。\n@string[1]才是字符串首地址。\nDelphi中可以把AnsiString当作缓冲区来使用，某些情况下比array of Byte要方便得多。\n对字符串变量第一次使用SetLengh时会重新分配内存，第二次使用时，若设定的长度比第一次小，则只会进行截断而并不改变已写入的内容，该特性在使用API返回字符串时非常好用。\nDelphi中的record是进行过字节对齐的，执行效率高，但占用空间比看到的会略大；packed record是未进行过字节对齐的，执行效率略低，但占用空间与看到的保持一致。也就是说，Delphi中packed record才是与C中的struct等同。\n在Delphi中packed record配合case可以实现C中的union，具体是否等同还要看实际定义的字节是否一致（需要对每种数据类型占用的空间十分熟悉）。\n标准C动态库的API函数或回调函数，在Delphi中均要使用stdcall;来修饰，以确保传参顺序一致。\n数据类型对应关系 C/C++ 类型 Delphi 基本类型 Delphi Window 单元类型 说明 char ShortInt / Int8 8位有符号整型 char* PShortInt unsigned char / BYTE Byte / UInt8 UCHAR 8位无符号整型，字节型 unsigned char* PByte LPBYTE / PUCHAR short SmallInt / Int16 SHORT 16位有符号整型 short* PSmallInt PSHORT unsigned short Word / UInt16 WORD 16位无符号整型 unsigned short* PWord PUSHORT int / long Integer / Longint / Int32 LONG 32位有符号整型 int* / long* PInteger / PLongInt PLONG unsigned / unsigned int / unsigned long Cardinal / LongWord / UInt32 DWORD / UINT / ULONG / ULONG32 32位无符号整型 unsigned int* / unsigned long* PCardinal / PLongWord / PUint32 PDWORD / PUINT / PULONG long long / __int64 Int64 LONG64 / LONGLONG 64位有符号整型 long long* / __int64* PInt64 PLONG64 unsigned long long / unsigned __int64 UInt64 ULONG64 / ULONGLONG / DWORD64 64位无符号整型 unsigned long long* / unsigned __int64* PUInt64 PULONG64 / PULONGLONG / PDWORD64 float Single / Float32 32位单精度浮点型 float* PSingle double Double / Float64 64位双精度浮点型 double* PDouble long double Extended 10字节浮点型 char AnsiChar 单字节字符 char* PAnsiChar LPSTR / LPCSTR char** PPAnsiChar wchar_t / WCHAR WideChar WCHAR 双字节字符 wchar_t* PWideChar PWChar / LPWSTR / LPCWSTR wchar_t** PPWideChar 任意1字节类型 Boolean / ByteBool 1字节布尔型 任意1字节类型指针 PBoolean / PByteBool 任意2字节类型 WordBool 2字节布尔型 任意2字节类型指针 PWordBool BOOL LongBool BOOL 4字节布尔型 BOOL* PLongBool PBOOL void* Pointer PVOID / LPVOID / LPCVOID 无类型指针 void** PPointer PPVOID 升华 有了以上知识，把.","title":"从.h头文件到.pas单元"},{"content":" 从其它平台迁移而来\n越来越喜欢绿色免安装的产品了，MySQL也不例外，由其是MySQL 8，于是就重点研究了下如何安装zip版的MySQL。\n安装脚本 以下是参考网上其它资料整理后的批处理文件，直接放在MySQL解压出来的根目录下执行即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @echo off ::============================================================================== set mysqlPath=%cd% echo 1. 启动服务 echo 2. 停止服务 echo 3. 安装服务 echo 4. 卸载服务 set /p op=\u0026#34;请选择操作: \u0026#34; if %op%==1 goto :Start if %op%==2 goto :Stop if %op%==3 goto :Install if %op%==4 goto :Uninstall ::============================================================================== :Start ::启动服务 net start mysql goto :eof ::------------------------------------------------------------------------------ :Stop ::停止服务 net stop mysql goto :eof ::------------------------------------------------------------------------------ :Install ::生成配置文件 echo [mysqld]\u0026gt;my.ini echo # 设置3306端口\u0026gt;\u0026gt;my.ini echo port=3306\u0026gt;\u0026gt;my.ini echo # 设置mysql的安装目录\u0026gt;\u0026gt;my.ini echo basedir=%mysqlPath%\u0026gt;\u0026gt;my.ini echo # 设置mysql数据库的数据的存放目录\u0026gt;\u0026gt;my.ini echo datadir=%mysqlPath%\\Data\u0026gt;\u0026gt;my.ini echo # 允许最大连接数\u0026gt;\u0026gt;my.ini echo max_connections=200\u0026gt;\u0026gt;my.ini echo # 允许连接失败的次数\u0026gt;\u0026gt;my.ini echo max_connect_errors=10\u0026gt;\u0026gt;my.ini echo # 服务端使用的字符集默认为UTF8\u0026gt;\u0026gt;my.ini echo character-set-server=utf8mb4\u0026gt;\u0026gt;my.ini echo # 创建新表时将使用的默认存储引擎\u0026gt;\u0026gt;my.ini echo default-storage-engine=INNODB\u0026gt;\u0026gt;my.ini echo # 默认使用“mysql_native_password”插件认证\u0026gt;\u0026gt;my.ini echo default_authentication_plugin=mysql_native_password\u0026gt;\u0026gt;my.ini echo [mysql]\u0026gt;\u0026gt;my.ini echo # 设置mysql客户端默认字符集\u0026gt;\u0026gt;my.ini echo default-character-set=utf8mb4\u0026gt;\u0026gt;my.ini echo [client]\u0026gt;\u0026gt;my.ini echo # 设置mysql客户端连接服务端时默认使用的端口\u0026gt;\u0026gt;my.ini echo port=3306\u0026gt;\u0026gt;my.ini echo default-character-set=utf8mb4\u0026gt;\u0026gt;my.ini ::安装服务 cd %mysqlPath%\\bin mysqld --initialize-insecure --console mysqld --install call :Start ::设置密码 echo 先输入原始密码，再输入新密码 mysqladmin -u root -p password goto :eof ::------------------------------------------------------------------------------ :Uninstall call :Stop cd %mysqlPath%\\bin mysqld --remove set /p d=\u0026#34;是否删除 Data 目录？[Y/N]: \u0026#34; if /i %d%==Y rd /s /q \u0026#34;%mysqlPath%\\Data\u0026#34; del /s /q \u0026#34;%mysqlPath%\\my.ini\u0026#34; goto :eof 补充说明 关于my.ini配置文件的内容，可根据自身需要进行修改或写入其它配置。\n为减少安装过程中的交互，初始化时root账户使用了空密码而不是随机密码。若想使用随机密码，可将mysqld --initialize-insecure --console改为mysqld --initialize --console。\n","permalink":"https://afrusrsc.github.io/posts/db/mysql_zip_install/","summary":"从其它平台迁移而来\n越来越喜欢绿色免安装的产品了，MySQL也不例外，由其是MySQL 8，于是就重点研究了下如何安装zip版的MySQL。\n安装脚本 以下是参考网上其它资料整理后的批处理文件，直接放在MySQL解压出来的根目录下执行即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @echo off ::============================================================================== set mysqlPath=%cd% echo 1.","title":"MySQL zip 安装"},{"content":" 从其它平台迁移而来\n前言 接触编程已十年有余，使用Delphi谋生也已五年有余，不敢说阅码无数，实实在在看过的代码也是有几箩筐的，但见过的写得好的、写得漂亮的、写得优美的代码，少之又少。\n由于pascal语言简单易学的优点，以及DelphiIDE快速开发的方便，致使随便来个阿猫阿狗搞几下就能搞出来个马马虎虎的东西，于是众多程序猿便借势野蛮生长，个个都长得很有个性，产出的代码也自然是个性十足。事实上，其它语言的这种现象也不少。\n我无意发起圣战，毕竟每只猿都有自己的追求，而我，不过是长成了一只有点洁癖的猿。以下是我的洁癖，也是我的追求，算是总结，也算是对自己的警醒。\n正文 排版 良好的排版能使代码看起来清晰愉悦，统一的排版能使团队合作愉快，也更能显出版本控制优势。\n简单来说，cnPack提供的排版功能就不错。我喜欢在默认的基础上做如下调整：\n关键字小写。因为小写比大写更易阅读。\nbegin 位于下一行。因为能突出代码块的起始位置。\n当超过90列时自动换行于80列。因为我的屏幕有点小，而且我个人也比较懒，再加上一点点历史原因。\n字符串拼接等不希望cnPack自动排版的地方，可在末尾加//单行注释进行妨碍。写过长SQL语句的都知道我在说什么。\n注释 注释很重要，但注释也可以很美妙。比如：interface区主要使用xml风格的注释，implementation区主要使用默认风格的注释，具体如下：\n函数、过程、类方法、类属性、结构体方法的声明使用xml风格的注释，注释在上，声明在下。当你把鼠标放上去的时候你就知道我是对的。\n枚举成员、类字段、结构体字段使用//单行注释，注释在右，且同一代码块尽量缩进对齐。无他，我有洁癖。\nxml风格的注释，我喜欢的格式如下，至于怎么设置，我想这不是问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 {func} /// \u0026lt;summary\u0026gt;|\u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n1\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;n2\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; {param} /// \u0026lt;param name=\u0026#34;|\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; {remarks} /// \u0026lt;remarks\u0026gt;|\u0026lt;/remarks\u0026gt; {returns} /// \u0026lt;returns\u0026gt;|\u0026lt;/returns\u0026gt; {seealso} /// \u0026lt;seealso\u0026gt;|\u0026lt;/seealso\u0026gt; {summary} /// \u0026lt;summary\u0026gt;|\u0026lt;/summary\u0026gt; {value} /// \u0026lt;value\u0026gt;|\u0026lt;/value\u0026gt; 命名 什么拼音首字母，什么1 2 3 4 5，我是极其痛恨的！\n禁止使用汉字、拼音、拼音首字母、前缀+数字命名。\n要使用有意义的单词或短语命名。\n可以使用缩写，但不能产生歧义，若没有更合适的命名但又容易产生歧义则必须加注释详细说明。\n主要使用Pascal命名法，特殊情况可加前缀，且前缀一般要小写。\n全局常量尽量全部大写，且单词间用下划线_分隔。\n普通命名尽量少用下划线_。\n组件须加前缀，前缀统一使用cnPack生成，同类组件要使用相同的前缀。\n工程组，组名加前缀g，工程名不加前缀。\n窗体单元，单元名加前缀FM_，窗体名加前缀frm。\n数据模块单元，单元名加前缀DM_，数据模块名加前缀dm。\n框架单元，单元名加前缀FA_，框架名加前缀fra。\n自定义组件单元，单元名加前缀c，我个人喜欢加前缀J。\n普通单元，单元名加前缀u。\n在类中，属性字段加前缀F，非属性字段加前缀m。\n句柄类变量可选择加前缀h。\n函数/过程的形参一般加前缀A。\n在函数/过程内部临时使用的变量可加前缀tmp。\n数据库中，表名加前缀T_，视图名加前缀V_，存储过程名加前缀SP_。\n函数/过程 形参最好保持在4个以内，最多不要超过10个，实在不行就传结构体。 我曾用过一家公司的API，一个函数传了54个参数，当时我就炸毛了，你这是要打扑克吗？\n一个函数/过程最好只做一件事，也就是所谓的KISS原则。 我曾接手过一个项目，核心业务就在一个过程里，知道这个过程有多少行吗？1W+！每次改到这里心中总有千万头羊驼奔过……\n日期时间 Delphi日期时间转换函数默认是会受操作系统日期时间格式影响的，程序初始化时最好先进行格式设置。\nDelphi日期时间的零点与其它的是不同的，尤其是数据库里，最好格式化成字符串再入库。\n面向对象 讲真，我也是从小白过来的，知道要跃过这道坎不是那么容易，但是，必须要知道：\n面向对象是一种思想，并不是你弄出个类来，就是在面向对象了！\n不管你是面向对象还是别的什么东西，KISS原则总是对的！\n多用组合，少用继承。Golang倒是把这点发挥到了极致。\n别不放窗体就不会写代码了！\n其它 字符编码尽可能使用UTF-8无BOM。\n要做到编译0 Error 0 Warning。\n禁止使用try ... except Application.Run; end;和try ... except ; end;，无论如何都不能用！\n不要滥用Timer，除非你想把自己玩死！\n建议Debug模式下总是开启内存泄漏报告，否则当你遇到AV报错的时候你就自己去爽吧！\n在Debug模式下善用OutputDebugString，相信你会开心得笑出猪哼的。\n创建/释放或打开/关闭要对称，而且要在正确的位置。\n坚持谁创建，就由谁负责释放的原则，不要干自动释放的蠢事，除非你清楚自己在做什么，但通常情况下没人会知道别人会怎么调用它。\n使用对象前最好先判断下对象是否存在，除非能确保对象肯定存在。\n动态创建的对象，释放时要使用FreeAndNil();。\n动态创建组件对象时，Create传入参数要慎重，某些情况下传入nil不会报错但就是运行不正常，比如某些数据库组件，此时建议传入Application。\n写线程时，不要使用FreeOnTerminate := True;，若坚持了以上原则的话，几乎没有可能会用到它。\n不要调用Terminate;，若坚持了以上原则的话，没有可能会用到它。\n不要使用相对路径，即使外部配置为相对路径，读取配置后也要转换为绝对路径，否则当你的程序被三方程序调用运行的时候，你就会爽歪歪的。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/delphi_rules/","summary":"从其它平台迁移而来\n前言 接触编程已十年有余，使用Delphi谋生也已五年有余，不敢说阅码无数，实实在在看过的代码也是有几箩筐的，但见过的写得好的、写得漂亮的、写得优美的代码，少之又少。\n由于pascal语言简单易学的优点，以及DelphiIDE快速开发的方便，致使随便来个阿猫阿狗搞几下就能搞出来个马马虎虎的东西，于是众多程序猿便借势野蛮生长，个个都长得很有个性，产出的代码也自然是个性十足。事实上，其它语言的这种现象也不少。\n我无意发起圣战，毕竟每只猿都有自己的追求，而我，不过是长成了一只有点洁癖的猿。以下是我的洁癖，也是我的追求，算是总结，也算是对自己的警醒。\n正文 排版 良好的排版能使代码看起来清晰愉悦，统一的排版能使团队合作愉快，也更能显出版本控制优势。\n简单来说，cnPack提供的排版功能就不错。我喜欢在默认的基础上做如下调整：\n关键字小写。因为小写比大写更易阅读。\nbegin 位于下一行。因为能突出代码块的起始位置。\n当超过90列时自动换行于80列。因为我的屏幕有点小，而且我个人也比较懒，再加上一点点历史原因。\n字符串拼接等不希望cnPack自动排版的地方，可在末尾加//单行注释进行妨碍。写过长SQL语句的都知道我在说什么。\n注释 注释很重要，但注释也可以很美妙。比如：interface区主要使用xml风格的注释，implementation区主要使用默认风格的注释，具体如下：\n函数、过程、类方法、类属性、结构体方法的声明使用xml风格的注释，注释在上，声明在下。当你把鼠标放上去的时候你就知道我是对的。\n枚举成员、类字段、结构体字段使用//单行注释，注释在右，且同一代码块尽量缩进对齐。无他，我有洁癖。\nxml风格的注释，我喜欢的格式如下，至于怎么设置，我想这不是问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 {func} /// \u0026lt;summary\u0026gt;|\u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n1\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;n2\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; {param} /// \u0026lt;param name=\u0026#34;|\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; {remarks} /// \u0026lt;remarks\u0026gt;|\u0026lt;/remarks\u0026gt; {returns} /// \u0026lt;returns\u0026gt;|\u0026lt;/returns\u0026gt; {seealso} /// \u0026lt;seealso\u0026gt;|\u0026lt;/seealso\u0026gt; {summary} /// \u0026lt;summary\u0026gt;|\u0026lt;/summary\u0026gt; {value} /// \u0026lt;value\u0026gt;|\u0026lt;/value\u0026gt; 命名 什么拼音首字母，什么1 2 3 4 5，我是极其痛恨的！","title":"Delphi开发守则"},{"content":" 从其它平台迁移而来\n由于没有太多编写接口的经验，此处仅简单说明语法。后期对接口有更多认知和经验后再进行详细记录。\nDelphi Delphi的接口是侵入式接口，并且是单继承的，但类可以同时实现多个接口，类声明时需要显示声明实现了哪些接口。\n声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type //直接声明 IMyInterface1 = interface function Func1: Integer; //函数 procedure Proc1(Value: Integer); //过程 property MI: Integer read Func1 write Proc1; //属性 end; //从已有接口继承 IMyInterface2 = interface(IMyInterface1) procedure Proc2; end; //含有 GUID 的接口可以公开给其它进程调用 IMyInterface3 = interface [\u0026#39;{3E51374A-D0E8-4C84-AA30-9634409E45DD}\u0026#39;] procedure Proc3; end; Delphi已经提供了基接口IInterface，自己声明的接口最好从IInterface继承。\n实现 1 2 3 4 5 6 7 8 9 10 11 type //含接口的类的声明 TMyClass = class(基类, 接口) public procedure Proc; //接口方法 end; //接口实现 procedure TMyClass.Proc; begin //接口方法的具体实现 end; 一个类可以有多个接口，所有接口的所有方法在类中必须全部实现。\nDelphi同样提供了实现了基接口IInterface的基类TInterfacedObject，从TInterfacedObject继承可以省去接口引用管理的实现。\nGo Go的接口是非侵入式的，接口编写者无须知道接口被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明实现哪一个接口。\n声明 1 2 3 4 5 type 接口类型名 interface{ 方法名1 (形参列表1) 返回值列表1 //参数列表和返回值列表中的参数变量名可以被忽略 方法名2 (形参列表2) 返回值列表2 ... } 实现 如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则我们说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型。\n接口的实现需要遵循两条规则才能让接口可用：\n接口的方法与实现接口的类型方法格式一致。\n接口中所有方法均被实现。\n","permalink":"https://afrusrsc.github.io/posts/program/go/go_delphi_interface/","summary":"从其它平台迁移而来\n由于没有太多编写接口的经验，此处仅简单说明语法。后期对接口有更多认知和经验后再进行详细记录。\nDelphi Delphi的接口是侵入式接口，并且是单继承的，但类可以同时实现多个接口，类声明时需要显示声明实现了哪些接口。\n声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type //直接声明 IMyInterface1 = interface function Func1: Integer; //函数 procedure Proc1(Value: Integer); //过程 property MI: Integer read Func1 write Proc1; //属性 end; //从已有接口继承 IMyInterface2 = interface(IMyInterface1) procedure Proc2; end; //含有 GUID 的接口可以公开给其它进程调用 IMyInterface3 = interface [\u0026#39;{3E51374A-D0E8-4C84-AA30-9634409E45DD}\u0026#39;] procedure Proc3; end; Delphi已经提供了基接口IInterface，自己声明的接口最好从IInterface继承。\n实现 1 2 3 4 5 6 7 8 9 10 11 type //含接口的类的声明 TMyClass = class(基类, 接口) public procedure Proc; //接口方法 end; //接口实现 procedure TMyClass.","title":"从Delphi到Go——接口"},{"content":" 从其它平台迁移而来\n人到中年，总是不免生出些危机感，长年使用Delphi，心中自是不踏实，闲来便看两眼java，不想却发现个从未注意过的小问题。\njava 1 2 3 4 5 double a = 1 / 10; //0.0 double b = 1.0 / 10; //0.1 double c = 1 / 10.0; //0.1 double d = 1 - 9.0 / 10; //0.09999999999999998 double e = 1 - 9 / 10; //1.0 Delphi 1 2 3 4 5 a := 1 / 10; //0.1 b := 1.0 / 10; //0.1 c := 1 / 10.0; //0.1 d := 1 - 9.0 / 10; //0.1 e := 1 - 9 / 10; //0.1 Go 1 2 3 4 5 a := 1 / 10 //0 b := 1.0 / 10 //0.1 c := 1 / 10.0 //0.1 d := 1 - 9.0/10 //0.1 e := 1 - 9/10 //1 C# 1 2 3 4 5 6 7 8 9 10 11 12 //.Net Framework double a = 1 / 10; //0 double b = 1.0 / 10; //0.1 double c = 1 / 10.0; //0.1 double d = 1 - 9.0 / 10; //0.1 double e = 1 - 9 / 10; //1 //.NET Core double a = 1 / 10; //0 double b = 1.0 / 10; //0.1 double c = 1 / 10.0; //0.1 double d = 1 - 9.0 / 10; //0.09999999999999998 double e = 1 - 9 / 10; //1 python 3 1 2 3 4 5 a = 1 / 10; //0.1 b = 1.0 / 10; //0.1 c = 1 / 10.0; //0.1 d = 1 - 9.0 / 10; //0.09999999999999998 e = 1 - 9 / 10; //0.09999999999999998 从以上可看出：\nDelphi和python 3，整数/整数=浮点数；java、Go、C#，整数/整数=整数。\nDelphi、Go、C#(.Net Framework)比java、C#(.NET Core)、python 3的浮点数精度要高。\nDelphi按自然认知书写即可；Go、C#(.Net Framework)需要注意一下书写语法；python 3浮点数做比较时要做下特殊处理才行；java、C#(.NET Core)不仅要注意书写语法，比较时还要做特殊处理。\n综合精度和方便度来看，Delphi才是王者，Go、C#(.Net Framework)次之，python 3再次，java、C#(.NET Core)末之。\n哈哈，Delphi依然宝刀未老啊！\n","permalink":"https://afrusrsc.github.io/posts/program/misc/float_precision_calc/","summary":"从其它平台迁移而来\n人到中年，总是不免生出些危机感，长年使用Delphi，心中自是不踏实，闲来便看两眼java，不想却发现个从未注意过的小问题。\njava 1 2 3 4 5 double a = 1 / 10; //0.0 double b = 1.0 / 10; //0.1 double c = 1 / 10.0; //0.1 double d = 1 - 9.0 / 10; //0.09999999999999998 double e = 1 - 9 / 10; //1.0 Delphi 1 2 3 4 5 a := 1 / 10; //0.1 b := 1.0 / 10; //0.1 c := 1 / 10.","title":"简单数学运算的比较"},{"content":" 从其它平台迁移而来\n开发过程中经常会需要使用到延时功能，Delphi中有不少实现延时的方法，网上已有不少文章做过说明和分析，但本着实践出真知的态度，还是亲自动手研究一番心里比较踏实。\n常用的延时方法 Sleep Sleep(n)，延时n毫秒，延时过程中程序不响应，一般延时较小时使用。\n在主线程中使用，延时较大（100+）的话会起程序假死，一般在子线程中使用较多。\n无论在主线程还是子线程中，延时较长的话（如 2000 ms），一般不一次性Sleep(2000)，而是分多次循环Sleep。有时为了能在延时过程中响应外部消息，还会加上Application.ProcessMessages;，如：\n1 2 3 4 5 6 //延时 2000 ms for i := 0 to 19 do begin Sleep(100); Application.ProcessMessages; end; Timer Timer为定时器，用于周期性地执行某个处理。也可用来实现延时，延时过程中不会引起程序假死，\nGetTickCount GetTickCount返回从操作系统启动到当前所经过的毫秒数，一般用于计算代码段的用时。配合循环使用也可达到延时的功能。\n1 2 3 4 n := GetTickCount; repeat Application.ProcessMessages; //若延时过程中需要响应消息可加上此句 until GetTickCount \u0026gt;= n + ms; //ms为延时的毫秒数 注意：使用以上代码进行延时的过程中，CPU使用率会异常地高（事实上，不加限制一直跑的循环都会导致CPU使用率过高）。\n小结 以上是对Sleep、Timer和GetTickCount用于延时的简单说明，个人经验：通常较小延时的场景用Sleep，较大延时的场景用Timer，评估代码段耗时的场景用GetTickCount。至于为什么这样用，以前是不清楚的，但通过对三者的精度分析，目前已知晓来龙去脉。\n延时精度分析 上文已经提到，一般用GetTickCount来分析代码段耗时，但由于本次GetTickCount在被测行列，故另寻他法。\n本次测试假定系统时间是足够精确的，因此使用Now分别在延时前后获取系统当前时间来进行耗时评估。\n为使测试更具代表性，每个测试点测试100次，取算术平均值。\n在1ms~100ms内，测试点步长为1ms，在100ms~1000ms内，测试点步长为10ms。\n为尽可能减小干扰，测试过程中未使用Application.ProcessMessages;，也未使用并行。\n测试结果 XE10编译，Win10下运行，经过近5个小时的测试，结果终于出炉了。\n延时(ms) Sleep GetTickCount Timer 1 1.70 15.58 15.64 2 2.71 15.63 15.50 3 3.67 15.62 15.63 4 4.56 15.63 15.44 5 5.54 15.62 15.56 6 6.52 15.63 15.51 7 7.53 15.63 15.55 8 8.54 15.61 15.49 9 9.52 15.63 15.50 10 10.55 15.63 15.48 11 11.57 15.62 15.53 12 12.73 15.63 15.56 13 13.64 15.63 15.52 14 14.53 15.61 15.53 15 15.52 15.63 15.54 16 16.59 24.85 24.79 17 17.53 31.24 31.16 18 18.54 31.26 31.22 19 19.51 31.24 31.20 20 20.58 31.25 31.18 21 21.51 31.26 31.21 22 22.51 31.24 31.18 23 23.55 31.26 31.17 24 24.53 31.25 31.24 25 25.55 31.24 31.26 26 26.52 31.26 31.24 27 27.50 31.25 31.18 28 28.56 31.24 31.19 29 29.50 31.26 31.27 30 30.54 31.24 31.09 31 31.51 31.25 31.24 32 32.53 41.72 41.64 33 33.55 46.87 46.76 34 34.58 46.89 46.75 35 35.50 46.87 46.79 36 36.55 46.88 46.76 37 37.52 46.87 46.72 38 38.53 46.88 46.77 39 39.54 46.87 46.75 40 40.52 46.88 46.77 41 41.54 46.87 46.80 42 42.53 46.88 46.72 43 43.53 46.87 46.76 44 44.50 46.88 46.80 45 45.59 46.87 46.69 46 46.54 46.87 46.84 47 47.51 50.00 49.82 48 48.55 62.50 62.48 49 49.54 62.51 62.44 50 50.61 62.50 62.42 51 51.56 62.49 62.45 52 52.57 62.50 62.48 53 53.51 62.51 62.47 54 54.55 62.49 62.35 55 55.54 62.50 62.50 56 56.53 62.51 62.47 57 57.53 62.50 62.40 58 58.58 62.49 62.43 59 59.51 62.50 62.46 60 60.55 62.51 62.44 61 61.54 62.49 62.47 62 62.53 62.50 62.48 63 63.54 75.00 74.87 64 64.54 78.13 77.93 65 65.57 78.12 78.02 66 66.53 78.13 78.07 67 67.54 78.13 78.06 68 68.57 78.12 78.04 69 69.55 78.13 77.97 70 70.55 78.12 78.01 71 71.56 78.12 78.07 72 72.56 78.13 78.04 73 73.53 78.12 78.00 74 74.53 78.13 78.04 75 75.57 78.12 78.08 76 76.52 78.12 77.95 77 77.47 78.14 78.00 78 78.56 78.12 78.06 79 79.52 93.75 93.60 80 80.55 93.75 93.74 81 81.55 93.74 93.64 82 82.60 93.76 93.74 83 83.68 93.75 93.66 84 84.50 93.75 93.74 85 85.59 93.75 93.62 86 86.54 93.75 93.73 87 87.54 93.75 93.71 88 88.58 93.75 93.66 89 89.55 93.75 93.76 90 90.60 93.75 93.66 91 91.53 93.75 93.60 92 92.53 93.75 93.83 93 93.49 93.75 93.70 94 94.53 100.00 99.93 95 95.58 109.38 109.35 96 96.50 109.37 109.37 97 97.56 109.37 109.39 98 98.52 109.38 109.31 99 99.56 109.38 109.35 100 100.56 109.37 109.25 110 110.59 124.89 124.96 120 120.62 125.00 125.04 130 130.51 140.62 140.50 140 140.58 140.62 140.63 150 150.60 156.26 156.22 160 160.55 171.88 171.77 170 170.52 171.87 171.85 180 180.49 187.49 187.47 190 190.56 203.13 202.94 200 200.57 203.13 203.05 210 210.57 218.74 218.64 220 220.58 234.39 234.31 230 230.56 234.37 234.31 240 240.58 250.00 249.87 250 250.57 249.99 250.04 260 260.54 265.63 265.38 270 270.54 281.25 281.26 280 280.59 281.26 281.27 290 290.53 296.86 296.76 300 300.57 312.51 312.43 310 310.58 312.50 312.43 320 320.57 328.12 328.10 330 330.62 343.75 343.68 340 340.56 343.75 343.75 350 350.57 359.37 359.29 360 360.55 375.01 374.91 370 370.56 375.00 374.94 380 380.49 390.62 390.57 390 390.57 390.63 390.46 400 400.51 406.25 406.30 410 410.52 421.87 421.70 420 420.57 421.87 421.88 430 430.57 437.50 437.42 440 440.57 453.13 452.96 450 450.57 453.13 453.09 460 460.59 468.74 468.65 470 470.55 484.38 484.26 480 480.59 484.37 484.36 490 490.61 500.00 499.90 500 500.55 500.01 499.97 510 510.56 515.62 515.49 520 520.59 531.25 531.19 530 530.57 531.25 531.27 540 540.68 546.87 546.77 550 550.54 562.51 562.45 560 560.61 562.49 562.55 570 570.54 578.13 577.90 580 580.54 593.75 593.75 590 590.56 593.75 593.75 600 600.56 609.38 609.23 610 610.63 625.00 624.92 620 620.57 624.99 624.99 630 630.64 640.63 640.45 640 640.52 640.63 640.52 650 650.48 656.24 656.05 660 660.59 671.88 671.78 670 670.58 671.88 671.83 680 680.53 687.50 687.45 690 690.60 703.12 703.00 700 700.60 703.13 703.07 710 710.59 718.74 718.66 720 720.70 734.38 734.27 730 730.64 734.37 734.32 740 740.52 750.01 749.96 750 750.65 749.99 749.93 760 760.54 765.63 765.71 770 770.62 781.25 781.35 780 780.54 781.25 781.18 790 790.55 796.87 797.00 800 800.53 812.51 812.40 810 810.57 812.49 812.50 820 820.58 828.13 828.14 830 830.62 843.75 843.69 840 840.57 843.76 843.78 850 850.56 859.37 859.24 860 860.60 875.00 874.96 870 870.66 874.99 875.07 880 880.60 890.63 890.50 890 890.50 890.62 890.62 900 900.57 906.25 906.20 910 910.63 921.87 921.68 920 920.56 921.87 921.81 930 930.56 937.51 937.47 940 940.56 953.12 952.99 950 950.58 953.13 952.95 960 960.60 968.75 968.66 970 970.51 984.37 984.24 980 980.55 984.38 984.33 990 990.62 999.99 999.88 1000 1000.52 1000.01 999.83 为方便直观查看，绘成图，分别为常数坐标轴和对数坐标轴：\n结果分析 从结果中可以看到：\nSleep的稳定性最好，偏差均在1ms左右。\nGetTickcount和Timer的结果高度重合，且呈阶梯状分布，阶梯差约15ms。\n经查MSDN，GetTickcount的分辨率受系统Timer的限制，通常在10ms~16ms范围内，测试结果与此吻合。\n总结 需要高精度延时的场景用Sleep，长延时用Sleep + 循环；一般精度的场景用GetTickcount + 循环；需要定时周期性处理的场景用Timer。\n用GetTickcount + 循环容易造成CPU占用率偏高，可以用GetTickcount + 循环 + Sleep(1)来降低CPU占用率：\n1 2 3 4 n := GetTickCount; repeat Sleep(1); until GetTickCount \u0026gt;= n + ms; 题外话 后来从别人的文章中发现了一种高精度的计时方法，用于评估代码段的执行时间：\n1 2 3 4 5 6 7 8 9 10 var Frequency, bCount, eCount: Int64; UsedTime: Double; begin QueryPerformanceFrequency(Frequency); QueryPerformanceCounter(bCount); //被评估代码段 QueryPerformanceCounter(eCount); UsedTime := (eCount - bCount) / Frequency * 1000; //单位：ms end; 使用这种计时方法重新运行后的结果如下：\n延时 Sleep GetTickCount Timer 1 1.94 15.48 15.60 2 2.85 15.63 15.57 3 3.84 15.63 15.57 4 4.82 15.62 15.57 5 5.90 15.63 15.54 6 6.76 15.63 15.56 7 7.81 15.62 15.55 8 8.77 15.63 15.60 9 9.79 15.63 15.55 10 10.73 15.62 15.56 11 11.76 15.63 15.58 12 12.79 15.63 15.59 13 13.76 15.62 15.54 14 14.76 15.63 15.61 15 15.76 15.63 15.57 16 16.75 24.99 24.93 17 17.78 31.26 31.13 18 18.71 31.25 31.18 19 19.72 31.26 31.18 20 20.73 31.25 31.17 21 21.67 31.25 31.19 22 22.70 31.26 31.18 23 23.82 31.25 31.20 24 24.66 31.25 31.14 25 25.62 31.26 31.22 26 26.72 31.25 31.14 27 27.70 31.25 31.19 28 28.62 31.26 31.14 29 29.73 31.25 31.19 30 30.57 31.26 31.18 31 31.63 31.25 31.12 32 32.57 41.72 41.65 33 33.60 46.87 46.83 34 34.60 46.87 46.80 35 35.61 46.87 46.81 36 36.55 46.87 46.80 37 37.62 46.87 46.78 38 38.59 46.87 46.81 39 39.58 46.87 46.82 40 40.60 46.87 46.79 41 41.58 46.87 46.75 42 42.61 46.87 46.83 43 43.59 46.87 46.82 44 44.63 46.87 46.76 45 45.58 46.87 46.79 46 46.56 46.87 46.74 47 47.60 50.01 49.81 48 48.51 62.50 62.34 49 49.60 62.49 62.42 50 50.56 62.50 62.37 51 51.57 62.50 62.46 52 52.59 62.49 62.36 53 53.51 62.50 62.42 54 54.58 62.50 62.37 55 55.60 62.50 62.38 56 56.56 62.49 62.42 57 57.56 62.50 62.38 58 58.57 62.50 62.43 59 59.61 62.49 62.39 60 60.59 62.51 62.34 61 61.54 62.50 62.44 62 62.57 62.50 62.43 63 63.61 74.99 74.89 64 64.55 78.12 78.06 65 65.56 78.13 78.07 66 66.52 78.12 78.04 67 67.57 78.12 78.08 68 68.53 78.13 78.05 69 69.59 78.12 78.02 70 70.57 78.12 78.06 71 71.58 78.13 78.04 72 72.56 78.12 78.06 73 73.62 78.13 78.05 74 74.59 78.12 78.06 75 75.58 78.13 78.05 76 76.61 78.12 78.01 77 77.63 78.12 78.10 78 78.60 78.13 78.01 79 79.58 93.75 93.64 80 80.59 93.75 93.68 81 81.58 93.75 93.67 82 82.62 93.75 93.69 83 83.58 93.75 93.61 84 84.55 93.75 93.65 85 85.60 93.75 93.67 86 86.57 93.75 93.67 87 87.60 93.75 93.69 88 88.62 93.75 93.62 89 89.59 93.76 93.70 90 90.60 93.75 93.66 91 91.65 93.75 93.66 92 92.58 93.75 93.63 93 93.62 93.75 93.70 94 94.61 100.00 99.78 95 95.59 109.37 109.24 96 96.61 109.38 109.31 97 97.62 109.38 109.29 98 98.65 109.38 109.32 99 99.61 109.37 109.29 100 100.59 109.38 109.34 110 110.57 125.01 124.91 120 120.56 125.00 125.03 130 130.52 140.62 140.52 140 140.51 140.62 140.57 150 150.60 156.25 156.21 160 160.58 171.88 171.77 170 170.60 171.87 171.86 180 180.59 187.50 187.43 190 190.60 203.13 202.99 200 200.61 203.13 203.13 210 210.59 218.74 218.64 220 220.62 234.38 234.28 230 230.60 234.37 234.31 240 240.59 250.00 249.97 250 250.58 249.99 250.00 260 260.75 265.63 265.59 270 270.56 281.25 281.14 280 280.61 281.25 281.26 290 290.62 296.88 296.75 300 300.62 312.49 312.45 310 310.57 312.50 312.52 320 320.55 328.12 328.01 330 330.59 343.75 343.67 340 340.54 343.75 343.72 350 350.57 359.38 359.30 360 360.57 374.99 374.96 370 370.60 375.00 374.93 380 380.61 390.62 390.57 390 390.53 390.62 390.55 400 400.62 406.25 406.20 410 410.58 421.87 421.81 420 420.58 421.88 421.89 430 430.56 437.50 437.38 440 440.56 453.12 453.06 450 450.68 453.13 453.03 460 460.65 468.76 468.73 470 470.71 484.37 484.27 480 480.72 484.37 484.39 490 490.69 499.99 499.87 500 500.66 500.00 499.95 510 510.63 515.63 515.61 520 520.61 531.25 531.17 530 530.58 531.25 531.29 540 540.55 546.88 546.80 550 550.53 562.50 562.39 560 560.50 562.50 562.42 570 570.47 578.12 578.09 580 580.45 593.75 593.69 590 590.42 593.75 593.79 600 600.39 609.37 609.23 610 610.57 625.00 624.93 620 620.59 625.00 624.96 630 630.55 640.63 640.54 640 640.61 640.63 640.56 650 650.60 656.25 656.27 660 660.60 671.87 671.77 670 670.63 671.87 671.88 680 680.56 687.50 687.43 690 690.61 703.13 703.00 700 700.61 703.12 703.11 710 710.56 718.75 718.67 720 720.55 734.38 734.27 730 730.60 734.37 734.31 740 740.56 750.00 750.01 750 750.56 750.00 749.91 760 760.58 765.62 765.51 770 770.59 781.25 781.22 780 780.56 781.25 781.24 790 790.58 796.87 796.82 800 800.56 812.51 812.37 810 810.60 812.50 812.54 820 820.59 828.12 827.99 830 830.60 843.75 843.67 840 840.58 843.75 843.77 850 850.57 859.37 859.28 860 860.58 875.00 874.89 870 870.54 875.00 874.97 880 880.58 890.63 890.57 890 890.55 890.63 890.57 900 900.53 906.24 906.16 910 910.61 921.87 921.76 920 920.63 921.87 921.84 930 930.56 937.50 937.43 940 940.57 953.12 953.06 950 950.59 953.13 953.05 960 960.55 968.75 968.63 970 970.44 984.38 984.30 980 980.38 984.38 984.28 990 990.36 999.99 999.99 1000 1000.32 1000.00 999.98 ","permalink":"https://afrusrsc.github.io/posts/program/pascal/delphi_delay/","summary":"从其它平台迁移而来\n开发过程中经常会需要使用到延时功能，Delphi中有不少实现延时的方法，网上已有不少文章做过说明和分析，但本着实践出真知的态度，还是亲自动手研究一番心里比较踏实。\n常用的延时方法 Sleep Sleep(n)，延时n毫秒，延时过程中程序不响应，一般延时较小时使用。\n在主线程中使用，延时较大（100+）的话会起程序假死，一般在子线程中使用较多。\n无论在主线程还是子线程中，延时较长的话（如 2000 ms），一般不一次性Sleep(2000)，而是分多次循环Sleep。有时为了能在延时过程中响应外部消息，还会加上Application.ProcessMessages;，如：\n1 2 3 4 5 6 //延时 2000 ms for i := 0 to 19 do begin Sleep(100); Application.ProcessMessages; end; Timer Timer为定时器，用于周期性地执行某个处理。也可用来实现延时，延时过程中不会引起程序假死，\nGetTickCount GetTickCount返回从操作系统启动到当前所经过的毫秒数，一般用于计算代码段的用时。配合循环使用也可达到延时的功能。\n1 2 3 4 n := GetTickCount; repeat Application.ProcessMessages; //若延时过程中需要响应消息可加上此句 until GetTickCount \u0026gt;= n + ms; //ms为延时的毫秒数 注意：使用以上代码进行延时的过程中，CPU使用率会异常地高（事实上，不加限制一直跑的循环都会导致CPU使用率过高）。\n小结 以上是对Sleep、Timer和GetTickCount用于延时的简单说明，个人经验：通常较小延时的场景用Sleep，较大延时的场景用Timer，评估代码段耗时的场景用GetTickCount。至于为什么这样用，以前是不清楚的，但通过对三者的精度分析，目前已知晓来龙去脉。\n延时精度分析 上文已经提到，一般用GetTickCount来分析代码段耗时，但由于本次GetTickCount在被测行列，故另寻他法。\n本次测试假定系统时间是足够精确的，因此使用Now分别在延时前后获取系统当前时间来进行耗时评估。\n为使测试更具代表性，每个测试点测试100次，取算术平均值。\n在1ms~100ms内，测试点步长为1ms，在100ms~1000ms内，测试点步长为10ms。\n为尽可能减小干扰，测试过程中未使用Application.ProcessMessages;，也未使用并行。\n测试结果 XE10编译，Win10下运行，经过近5个小时的测试，结果终于出炉了。\n延时(ms) Sleep GetTickCount Timer 1 1.70 15.58 15.64 2 2.","title":"Delphi中的延时"},{"content":" 从其它平台迁移而来\n结构体的方法 Delphi Delphi结构体的方法与类的方法几乎是一致的，主要区别是内存的管理方式和可见性不同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义 type TMyStruct = record No: Integer; Name: string; function ToString: string; end; //实现 function TMyStruct.ToString: string; begin Result := Format(\u0026#39;No:%d, Name:%s\u0026#39;, [Self.No, Self.Name]); end; //调用 var ms: TMyStruct; s: string; begin s := ms.ToString; end; Go 方法其实就是加了接收器的函数，语法如下：\n1 2 3 func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) { 函数体 } Go结构体的方法无需声明，直接实现即可。\n1 2 3 4 5 6 7 8 9 10 11 12 //结构体定义 type MyStruct struct { No int Name string } //结构体方法实现 func (s MyStruct) ToString() string { return fmt.Sprintf(\u0026#34;No:%d, Name:%s\u0026#34;, s.No, s.Name) } //调用 var ms MyStruct s := ms.ToString() 类型的方法 Delphi Delphi 2009以后，类型也可以有方法，最常用的是各基本类型的ToString方法。Integer类型的方法源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //Integer 类型的方法声明 TIntegerHelper = record helper for Integer { for LongInt type too } public const MaxValue = 2147483647; MinValue = -2147483648; function ToString: string; overload; inline; function ToBoolean: Boolean; inline; function ToHexString: string; overload; inline; function ToHexString(const MinDigits: Word): string; overload; inline; function ToSingle: Single; inline; function ToDouble: Double; inline; function ToExtended: Extended; inline; class function Size: Integer; inline; static; class function ToString(const Value: Integer): string; overload; inline; static; class function Parse(const S: string): Integer; inline; static; class function TryParse(const S: string; out Value: Integer): Boolean; inline; static; end; //Integer 类型的 ToString 方法实现 function TIntegerHelper.ToString: string; begin Result := IntToStr(Self); end; 可以看出，Delphi类型的方法是在结构体方法的基础上实现的。\nGo Go也可以为类型添加方法，但类型的定义和类型的方法必须在同一个包中。\n1 2 3 4 type myInt int func (i myInt) ToString() string { return strconv.Itoa(i) } 可以看出，在Go中，结构体只是众多类型中的一种，结构体的方法也只是类型的方法的其中一种。Go没有严格的类的概念，但是通过类型和方法的组合完全可以实现类的功能。\n","permalink":"https://afrusrsc.github.io/posts/program/go/go_delphi_method/","summary":"从其它平台迁移而来\n结构体的方法 Delphi Delphi结构体的方法与类的方法几乎是一致的，主要区别是内存的管理方式和可见性不同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义 type TMyStruct = record No: Integer; Name: string; function ToString: string; end; //实现 function TMyStruct.ToString: string; begin Result := Format(\u0026#39;No:%d, Name:%s\u0026#39;, [Self.No, Self.Name]); end; //调用 var ms: TMyStruct; s: string; begin s := ms.ToString; end; Go 方法其实就是加了接收器的函数，语法如下：\n1 2 3 func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) { 函数体 } Go结构体的方法无需声明，直接实现即可。","title":"从Delphi到Go——方法"},{"content":" 从其它平台迁移而来\nDelphi try\u0026hellip;finally\u0026hellip;end 1 2 3 4 5 6 //创建、打开、加锁等 try //具体处理 finally //释放、关闭、解锁等 end; raise 1 raise Exception.Create(\u0026#39;异常信息\u0026#39;); //手动抛出异常 try\u0026hellip;except\u0026hellip;end 1 2 3 4 5 6 7 8 9 try //可能产生异常的语句块 except //异常的相关处理 on E: Exception do begin //对应类型的异常的处理 end; end; Go defer 加defer的语句会延迟到函数调用结束返回时才执行，相当于finally...end区。存在多个defer语句时，最先出现的总是最后才执行。\n1 2 3 4 5 func F(){ //打开、加锁等 defer //关闭、解锁等 //具体处理 } panic 1 panic(异常信息) recover 1 2 3 4 5 6 7 func FF(){ defer func(){ e := recover() //异常处理 }() //可能产生异常的语句块，或调用 panic() 抛出异常 } 虽然panic/recover组合可以模拟try...except...end，但不建议在编写普通函数时也经常性使用这种特性。\nerror error是Go内置的错误接口，也是官方推荐的优先使用的错误处理方法。\nGo很多方法最后一个返回值都是error类型的err，在进行下一步操作前，需要先判断err是否为nil，为nil则继续，否则进行错误处理。\n1 2 3 4 5 6 r, e := callfunc() if e != nil { //错误处理 } else { //后续操作 } 至于自定义错误，在学完接口之后再说吧。\n","permalink":"https://afrusrsc.github.io/posts/program/go/go_delphi_except/","summary":"从其它平台迁移而来\nDelphi try\u0026hellip;finally\u0026hellip;end 1 2 3 4 5 6 //创建、打开、加锁等 try //具体处理 finally //释放、关闭、解锁等 end; raise 1 raise Exception.Create(\u0026#39;异常信息\u0026#39;); //手动抛出异常 try\u0026hellip;except\u0026hellip;end 1 2 3 4 5 6 7 8 9 try //可能产生异常的语句块 except //异常的相关处理 on E: Exception do begin //对应类型的异常的处理 end; end; Go defer 加defer的语句会延迟到函数调用结束返回时才执行，相当于finally...end区。存在多个defer语句时，最先出现的总是最后才执行。\n1 2 3 4 5 func F(){ //打开、加锁等 defer //关闭、解锁等 //具体处理 } panic 1 panic(异常信息) recover 1 2 3 4 5 6 7 func FF(){ defer func(){ e := recover() //异常处理 }() //可能产生异常的语句块，或调用 panic() 抛出异常 } 虽然panic/recover组合可以模拟try.","title":"从Delphi到Go——异常处理"},{"content":" 从其它平台迁移而来\nDelphi 事实上，Delphi并没有什么可以直接为函数传递可变参数（数量可变、类型可变）的语法，但是并不是说不可能实现，最常用的Format()函数就是最好的例子。\n虽然不能直接传递可变参数，但是通过一种叫做可变类型的开放数组即可实现为函数传递数量不定、类型不一的可变参数。\n可变类型 可变类型不是变体类型，而是一个记录类型TVarRec，在System单元中的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 TVarRec = record { do not pack this record; it is compiler-generated } case Integer of 0: (case Byte of vtInteger: (VInteger: Integer); vtBoolean: (VBoolean: Boolean); vtChar: (VChar: _AnsiChr); vtExtended: (VExtended: PExtended); {$IFNDEF NEXTGEN} vtString: (VString: _PShortStr); {$ENDIF !NEXTGEN} vtPointer: (VPointer: Pointer); vtPChar: (VPChar: _PAnsiChr); {$IFDEF AUTOREFCOUNT} vtObject: (VObject: Pointer); {$ELSE} vtObject: (VObject: TObject); {$ENDIF} vtClass: (VClass: TClass); vtWideChar: (VWideChar: WideChar); vtPWideChar: (VPWideChar: PWideChar); vtAnsiString: (VAnsiString: Pointer); vtCurrency: (VCurrency: PCurrency); vtVariant: (VVariant: PVariant); vtInterface: (VInterface: Pointer); vtWideString: (VWideString: Pointer); vtInt64: (VInt64: PInt64); vtUnicodeString: (VUnicodeString: Pointer); ); 1: (_Reserved1: NativeInt; VType: Byte; ); end; 开放数组 开放数组是在函数形参声明时使用的术语，语法为：\n1 v : array of Type 开放数组与动态数组极为类似，但意义不同，使用开放数组应注意：\n开放数组是形参，可传动态数组，也可传静态数组。\n开放数组索引总是从0到Length()-1，与实参索引无关。\n开放数组只能访问元素，不能对整个数组进行赋值操作。\n开放数组的实参为数组时会创建数组的副本，传递大数组可能导致栈溢出，为避免栈溢出，可使用const或var进行修饰。\n开放数组构造器 开放数组构造器的语法为：\n1 [实参1, 实参2, 实参3] 开放数组构造器允许在函数或过程调用中直接构造数组\n仅用于传递开放数组参数或可变类型开放数组参数\n可变类型的开放数组 可变类型的开放数组即开放数组的元素类型为可变类型，语法为：\n1 2 3 v : array of TVarRec //或 v : array of const //通常使用该语法 两者的区别是：array of TVarRec可以定义一般的数组变量，array of const只能声明形参为可变类型的开放数组。\n注意：可变类型的开放数组形参不能直接传递数组变量，实参必须通过开放数组构造器进行传递。\nGo Go有直接传递可变参数的语法：\n1 func Func(args ...type) //...type即为变长类型的形参，当type为interface{}时即可传递任意数量、任意类型的参数 ...type类型的形参只能有一个，且必须为最后一个形参。\n...type本质上是[]type的切片。\n调用时直接用逗号分隔各实参即可。\n","permalink":"https://afrusrsc.github.io/posts/program/go/go_delphi_func_args/","summary":"从其它平台迁移而来\nDelphi 事实上，Delphi并没有什么可以直接为函数传递可变参数（数量可变、类型可变）的语法，但是并不是说不可能实现，最常用的Format()函数就是最好的例子。\n虽然不能直接传递可变参数，但是通过一种叫做可变类型的开放数组即可实现为函数传递数量不定、类型不一的可变参数。\n可变类型 可变类型不是变体类型，而是一个记录类型TVarRec，在System单元中的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 TVarRec = record { do not pack this record; it is compiler-generated } case Integer of 0: (case Byte of vtInteger: (VInteger: Integer); vtBoolean: (VBoolean: Boolean); vtChar: (VChar: _AnsiChr); vtExtended: (VExtended: PExtended); {$IFNDEF NEXTGEN} vtString: (VString: _PShortStr); {$ENDIF !","title":"从Delphi到Go——函数的可变参数"},{"content":" 从其它平台迁移而来\n早期的Delphi版本是没有匿名函数的，不过可以定义一个函数类型来实现类似的功能；后期的版本已经支持匿名函数，随用随写。Go天生就支持匿名函数。\nDelphi 函数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //声明函数类型 type TMyProc = procedure(A: Integer); //过程 TMyFunc = function(x: Integer): Integer; //函数 //定义符合函数类型的函数 procedure MyProc(A: Integer); begin ShowMessage(IntToHex(A)); end; function MyFunc1(x: Integer): Integer; begin Result := x + x; end; function MyFunc2(x: Integer): Integer; begin Result := x * x; end; //使用 var mp: TMyProc; mf: TMyFunc; begin mp := MyProc; mf := MyFunc1; mp(mf(99)); end; //作为参数进行传递，这才是函数类型最主要的使用方法 procedure Test(x: Integer; Func: TMyFunc); begin ShowMessage(Func(x).ToString); end; Test(123, MyFunc1); Test(123, MyFunc2); 回调函数是函数类型最典型的应用，类的事件可以看作是特殊的回调函数。\n匿名函数 匿名函数的好处是可以随用随写，而不必事先把可能用到的实现都写好，而且尽可能把代码块的作用域缩到最小。\n1 2 3 4 5 6 7 8 9 10 11 12 13 //定义匿名函数类型 type TF = reference to function(n: Integer): string; //使用 var f: TF; begin f := function(a: Integer): string //注意，此处无分号 begin Result := a.ToString; end; ShowMessage(f(123)); f := nil; //匿名函数内代码的作用域到再次给匿名函数变量赋值为止 end; 匿名函数的用法与函数类型的用法一致。另外，Delphi已经提供好了几个常用的匿名函数类型：TProc、TProc\u0026lt;T\u0026gt;、TProc\u0026lt;T1,T2\u0026gt;、TProc\u0026lt;T1,T2,T3\u0026gt;、TProc\u0026lt;T1,T2,T3,T4\u0026gt;、TFunc\u0026lt;TResult\u0026gt;、TFunc\u0026lt;T,TResult\u0026gt;、TFunc\u0026lt;T1,T2,TResult\u0026gt;、TFunc\u0026lt;T1,T2,T3,TResult\u0026gt;、TFunc\u0026lt;T1,T2,T3,T4,TResult\u0026gt;和TPredicate\u0026lt;T\u0026gt;。\nDelphi还有一种常见的缩小函数作用域的写法，作用域是整个调用函数内，比匿名函数的作用域略大：\n1 2 3 4 5 6 7 8 procedure Test(x: Integer); function Func(A: Integer): Integer; //整个Test函数内均可调用 begin Result := A * A; end; begin ShowMessage(Func(x).ToString); end; Go 1 2 3 4 5 6 7 8 9 10 11 12 //匿名函数定义 func(形参列表)(返回值列表){ 函数体 } //定义的同时并进行调用 func(形参列表)(返回值列表){ 函数体 }(实参列表) //赋值给变量 f := func(形参列表)(返回值列表){ 函数体 } //之后可以使用f(实参列表)进行调用 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_delphi_func/","summary":"从其它平台迁移而来\n早期的Delphi版本是没有匿名函数的，不过可以定义一个函数类型来实现类似的功能；后期的版本已经支持匿名函数，随用随写。Go天生就支持匿名函数。\nDelphi 函数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //声明函数类型 type TMyProc = procedure(A: Integer); //过程 TMyFunc = function(x: Integer): Integer; //函数 //定义符合函数类型的函数 procedure MyProc(A: Integer); begin ShowMessage(IntToHex(A)); end; function MyFunc1(x: Integer): Integer; begin Result := x + x; end; function MyFunc2(x: Integer): Integer; begin Result := x * x; end; //使用 var mp: TMyProc; mf: TMyFunc; begin mp := MyProc; mf := MyFunc1; mp(mf(99)); end; //作为参数进行传递，这才是函数类型最主要的使用方法 procedure Test(x: Integer; Func: TMyFunc); begin ShowMessage(Func(x).","title":"从Delphi到Go——匿名函数"},{"content":" 从其它平台迁移而来\nDelphi中最基本的列表是TList类和TList\u0026lt;T\u0026gt;泛型类，还有线程安全的TThreadList类和TThreadList\u0026lt;T\u0026gt;泛型类，底层实现是数组。Go用的是container/list包，内部实现是双向链表。\nDelphi TList TList里存的是指针，使用时注意处理好指针即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //声明 var l: TList; //构造 l := TList.Create; //添加 l.Add(p); //元素个数 n := l.Count; //列表容量 cap := l.Capacity; //取值 p1 := l.Items[0]; p2 := l.Extract(p1); //找到指针p1并从列表中取出，列表中将不再有p1，若其后还有元素，则前移填充空缺。 p := l.First; //取第一个元素 p := l.Last; //取最后一个元素 //查找元素的索引 i := l.IndexOf(p); //修改 l.Items[0] := p2; //删除 l.Delete(0); l.Remove(p2); //清空 l.Clear; //只清空了内部的指针数组，并没有释放指针指向的内存 //释放 l.Free; 引用System.Contnrs单元后可以使用TObjectList类和TComponentList类，操作方法与TList相同，只是删除元素或清空列表后可自动释放元素。\nTThreadList TThreadList是加了锁的TList，所以多线程操作时是线程安全的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //声明 var tl: TThreadList; //构造 tl := TThreadList.Create; //添加 tl.Add(p); //删除 tl.Remove(p); //加锁 l := tl.LockList; //返回TList，方便更精细的操作 //解锁 tl.UnlockList; //清空 tl.Clear; //同TList，只清空了内部的指针数组，并没有释放指针指向的内存 //释放 tl.Free; TList 需要引用System.Generics.Collections单元，使用方法与TList类似。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //操作元素以记录为例 TR = record i: Integer; s: string; end; //声明 var rl: TList\u0026lt;TR\u0026gt;; //构造 rl := TList\u0026lt;TR\u0026gt;.Create; //添加 rl.Add(R1); //返回添加的位置 rl.Insert(1, R2); //在指定位置插入 //删除 rl.Remove(R1); //按元素删除 rl.Delete(0); //按索引删除一个元素 rl.DeleteRange(0, n); //按索引删除连续多个元素 R := rl.Extract(R2); //提取元素 R := rl.ExtractAt(0); //按索引提取元素 //清空 rl.Clear; //会自动释放元素所占内存 //释放 rl.Free; TThreadList TThreadList\u0026lt;T\u0026gt;是加了锁的TList\u0026lt;T\u0026gt;，多线程操作时是线程安全的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //声明 var rtl: TThreadList\u0026lt;TR\u0026gt;; //构造 rtl := TThreadList\u0026lt;TR\u0026gt;.Create; //添加 rtl.Add(R); //删除 rtl.Remove(R); //加锁 rl := rtl.LockList; //返回TList\u0026lt;TR\u0026gt;，方便更精细的操作 //解锁 rtl.UnlockList; //清空 rtl.Clear; //释放 rtl.Free; Go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //声明 var l list.List //l是List结构体 l := list.New() //l是指向List结构体的指针 //添加 e1 := l.PushFront(123) //在头部添加元素 e2 := l.PushBack(\u0026#34;abc\u0026#34;) //在尾部添加元素 e3 := l.InsertAfter(\u0026#34;xyz\u0026#34;, e1) //在指定元素后添加新元素 e4 := l.InsertBefore(456, e2) //在指定元素前添加新元素 //取值 e5 := l.Front() //返回第一个元素 e6 := l.Back() //返回最后一个元素 //从头顺序遍历 for i := e5; i != nil; i = i.Next() { fmt.Println(i.Value) } //从尾逆序遍历 for i := e6; i != nil; i = i.Prev() { fmt.Println(i.Value) } //移动元素 l.MoveToFront(e3) //把e3移动到头部 l.MoveToBack(e4) //把e4移动到尾部 l.MoveAfter(e1, e3) //把e1移动到e3后面 l.MoveBefore(e2, e1) //把e2移动到e1前面 //删除 l.Remove(e3) //元素个数 n := l.Len() //清空 l.Init() 由于Go语言语法糖的原因，指针与指针指向的对象的使用方法完全一致。\n","permalink":"https://afrusrsc.github.io/posts/program/go/go_delphi_list/","summary":"从其它平台迁移而来\nDelphi中最基本的列表是TList类和TList\u0026lt;T\u0026gt;泛型类，还有线程安全的TThreadList类和TThreadList\u0026lt;T\u0026gt;泛型类，底层实现是数组。Go用的是container/list包，内部实现是双向链表。\nDelphi TList TList里存的是指针，使用时注意处理好指针即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //声明 var l: TList; //构造 l := TList.Create; //添加 l.Add(p); //元素个数 n := l.Count; //列表容量 cap := l.Capacity; //取值 p1 := l.Items[0]; p2 := l.Extract(p1); //找到指针p1并从列表中取出，列表中将不再有p1，若其后还有元素，则前移填充空缺。 p := l.First; //取第一个元素 p := l.Last; //取最后一个元素 //查找元素的索引 i := l.IndexOf(p); //修改 l.","title":"从Delphi到Go——列表"},{"content":" 从其它平台迁移而来\n字典，又称为哈希表，是一种能够快速寻找值的理想结构。Go语言中对应的数据类型是map，Delphi中是TDictionary泛型类。\n声明 Delphi\n1 2 uses System.Generics.Collections; var 字典名: TDictionary\u0026lt;键类型, 值类型\u0026gt;; Go\n1 var 字典名 map[键类型]值类型 初始化 Delphi\n1 字典名 := TDictionary\u0026lt;键类型, 值类型\u0026gt;.Create(初始容量); Go\n1 2 3 4 //使用make构造 字典名 = make(map[键类型]值类型, 初始容量) //直接赋初值 字典名 = map[键类型]值类型{键1: 值1, 键2: 值2} 元素操作 Delphi\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 var m: TDictionary\u0026lt;Integer, string\u0026gt;; //构造 m := TDictionary\u0026lt;Integer, string\u0026gt;.Create; //添加元素 m.Add(1, \u0026#39;abc\u0026#39;); m.Add(2, \u0026#39;123\u0026#39;); //取元素个数 n := m.Count; //修改元素 m.Items[1] := \u0026#39;xyz\u0026#39;; //取值 v := m.Items[1]; //遍历 for k in m.Keys do //遍历键 ...; for v in m.Values do //遍历值 ...; //删除元素 m.Remove(1); //清空 m.Clear; //释放 m.Free; Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var m map[int]string //添加元素 m[1] = \u0026#34;abc\u0026#34; m[2] = \u0026#34;123\u0026#34; //取元素个数 n := len(m) //修改元素 m[1] = \u0026#34;xyz\u0026#34; //取值 v := m[1] //遍历 for k, v := range m { fmt.Println(k, v) } //删除元素 delete(1) //清空 m = map[int]string{} 并发操作 Delphi的TDictionary和TObjectDictionary在并发的应用场景下需要自己手动加锁。\nGo在并发场景下可以使用sync包中的Map。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //声明 var M sync.Map //添加元素 M.Store(1, \u0026#34;abc\u0026#34;) M.Store(2, \u0026#34;xyz\u0026#34;) //取值 v, ok := M.Load(1) //遍历 M.Range(func(k, v interface{}) bool { fmt.Println(k, v) return true }) //Range函数传入的参数是固定类型的匿名函数 //删除元素 M.Delete(2) ","permalink":"https://afrusrsc.github.io/posts/program/go/go_delphi_map/","summary":"从其它平台迁移而来\n字典，又称为哈希表，是一种能够快速寻找值的理想结构。Go语言中对应的数据类型是map，Delphi中是TDictionary泛型类。\n声明 Delphi\n1 2 uses System.Generics.Collections; var 字典名: TDictionary\u0026lt;键类型, 值类型\u0026gt;; Go\n1 var 字典名 map[键类型]值类型 初始化 Delphi\n1 字典名 := TDictionary\u0026lt;键类型, 值类型\u0026gt;.Create(初始容量); Go\n1 2 3 4 //使用make构造 字典名 = make(map[键类型]值类型, 初始容量) //直接赋初值 字典名 = map[键类型]值类型{键1: 值1, 键2: 值2} 元素操作 Delphi\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 var m: TDictionary\u0026lt;Integer, string\u0026gt;; //构造 m := TDictionary\u0026lt;Integer, string\u0026gt;.","title":"从Delphi到Go——字典"},{"content":" 从其它平台迁移而来\n静态数组 一维数组 声明 Delphi\n1 var 数组名 : array[索引范围] of 元素类型; //索引范围是子界类型，格式为：下限..上限 Go\n1 var 数组名 [数组长度]元素类型 Delphi的索引范围可以是任意的子界类型，而且是包含上下限的闭区间。子界可以是任意的序数类型（整型、字符型、枚举元素等），例如：0..8、5..11、'a'..'z'等。子界元素就是数组元素的下标。\nGo的数组长度只能是整型，下标为0~数组长度-1。\n初始化 Delphi\n1 2 var 数组名 : array[1..N] of 元素类型 = (元素1, 元素2, ……, 元素N); //如果先声明后赋值的话，赋值时就需要遍历数组对每个元素分别赋值 Go\n1 2 3 4 5 6 7 8 9 10 11 var 数组名 [N]元素类型 = [N]元素类型{元素0, 元素1, ……, 元素N-1} //由于初始化时元素个数已知，以上代码也可写为： var 数组名 [N]元素类型 = [...]元素类型{元素0, 元素1, ……, 元素N-1} //如果先声明后赋值的话，写法如下： var 数组名 [N]元素类型 数组名 = [...]元素类型{元素0, 元素1, ……, 元素N-1} //也可简写为： 数组名 := [...]元素类型{元素0, 元素1, ……, 元素N-1} //只初始化部分元素 数组名 := [N]元素类型{索引i: 元素i, 索引j: 元素j} 数组名 := [...]元素类型{索引i: 元素i, 索引j: 元素j} //不指定数据长度时，数组为包含初始化元素的最小的数组 元素操作 Delphi\n1 2 3 4 //取值 v := a[i]; //赋值 a[i] := v; Go\n1 2 3 4 //取值 v = a[i]; //赋值 a[i] = v; 遍历数组 Delphi\n1 2 3 4 5 6 var a : array[m..n] of Integer; for i := m to n do …… //XE之后（也可能更早）也支持以下语法 for v in a do …… Go\n1 2 3 4 5 var a [N]int for i, v := range a { …… } //也可以用传统写法，不过一般不那么写 比较数组 如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，如果两个数组的所有元素都是相等的时候数组才是相等的。\nDelphi需要手动遍历比较。Go可以直接用==、\u0026lt;\u0026gt;来比较。\n二维数组 声明 Delphi\n1 2 3 var 数组名 : array[第一维索引范围] of array[第二维索引范围] of 元素类型; 数组名 : array[第一维索引范围, 第二维索引范围] of 元素类型; //两种等效，一般使用这一种 Go\n1 var 数组名 [第一维长度][第二维长度]元素类型 事实上，Go只有一维数组，但是一维数组同时也是一种数据类型，通过组合也可以实现概念上的二维甚至多维数组。例如，上面的[第二维长度]元素类型就是该二维数组的数据类型，而该数据类型本身又是个一维数组。\n初始化 Delphi\n1 var a: array[0..1, 0..2] of Integer = ((1, 2, 3), (4, 5, 6)); Go\n1 2 3 4 5 6 7 8 9 var a [2][3]byte = [2][3]int{{1, 2, 3}, {4, 5, 6}} //可简写为 a := [2][3]int{{1, 2, 3}, {4, 5, 6}} //全部元素初始化时，第一维长度可以不指定，但第二维长度必须指定 a := [...][3]int{{1, 2, 3}, {4, 5, 6}} //只初始化部分元素 a := [2][3]int{0: {1, 2, 3}} //初始化第一维第0个元素的全部元素 a := [2][3]int{1: {2: 6}} //初始化第一维第1个元素的第二维第2个元素 a := [...][3]int{1: {2: 6}} //不指定第一维长度时，数组为包含初始化元素的最小的数组 元素操作 Delphi\n1 2 3 4 //取值 v := a[i, k]; //赋值 a[i, k] := v; Go\n1 2 3 4 //取值 v = a[i][j]; //赋值 a[i][j] = v; 遍历数组 Delphi\n1 2 3 4 5 6 7 var a : array[m..n, x..y] of Integer; for i := m to n do for j := x to y do …… //XE之后（也可能更早）也支持以下语法 for v in a do …… Go\n1 2 3 4 5 6 7 var a [M][N]int for i, ai := range a { for j, v := range ai { …… } } //也可以用传统写法，不过一般不那么写。另外可能有更好的方法而我不清楚 动态数组 Delphi\n1 2 3 4 5 6 7 //声明 var da: array of Integer; //构造 SetLength(da, 10); //首次调用会初始化元素，之后调用只分配长度不再初始化。 //具体使用与静态数组几乎完全一样 //静态数组的数组名事实上即指向该数组首地址的指针 //动态数组的数组名事实上指向该数组首地址的指针的指针 Go\nGo没有动态数组，但是有更为灵活的切片，切片完成可以实现动态数组的功能，而且更灵活更丰富。\n切片 声明 1 2 var s1 []元素类型 //一维切片 var s2 [][]元素类型 //二维切片 初始化 使用make()函数构造 1 2 3 4 5 6 切片名 = make([]元素类型, 元素个数, 切片容量) //len()函数返回切片的元素个数 //cap()函数返回切片的容量 //切片容量可以省略，省略后切片的容量=元素个数 //切片容量不能小于元素个数，否则会报运行时错误 //切片容量可以大于元素个数，意为一次性预先分配出至少可以容纳该数量元素的内存供使用，若不够时会自动扩容，一般按容量的2倍进行扩容 从已有数组或切片生成 1 2 3 4 5 6 7 8 9 10 切片名 = 已有切片[开始位置:结束位置] //该语句并没有发生内存分配，而只是将新的切片指向了已有的切片，两个切片共用一部分内存 //len()函数会返回切片元素个数 //开始位置、结束位置均为原切片的索引，且开始位置\u0026lt;=结束位置 //新的切片包含开始位置，不包含结束位置，但结束位置可以等于元素个数，用于取出末位元素 //取出的元素数量为：结束位置-开始位置 //省略开始位置，表示从连续区域开头到结束位置 //省略结束位置，表示从开始位置到整个连续区域末尾 //两者同时省略，与切片本身等效 //两者相等，等效于空切片，一般用于切片复位 切片操作 添加元素 1 2 3 4 5 6 7 8 9 10 11 12 13 var s1, s2 []int //添加一个元素 s1 = append(s1, 1) //添加多个元素 s2 = append(s2, 2, 4, 6) //添加一个切片的元素，必须加...对切片进行解包 s1 = append(s1, s2...) //注意：不能同时既添加元素又添加切片 //第一个参数也可以是其它切片 s3 := append(s2, 8) //s2也发生了变化 //在切片首部添加元素 s1 = append([]int{3}, s1...) //必定发生内存重新分配 //在切片第i个位置添加元素 s1 = append(s1[:i], append([]int{5}, s1[i:]...)...) 切片拷贝 1 2 3 4 copy(目标切片, 源切片) //目标切片必须分配过空间，且与源切片类型一致。 //若两个切片大小不一致，则按较少元素的切片的个数进行复制 //返回值为实际发生复制的元素个数 删除元素 Go没有删除切片元素的语法或接口，但可以利用切片的特性。\n1 2 3 4 5 6 7 8 9 //删除开头N个元素 s = s[N:] //移动指针 s = append(s[:0], s[N:]...) //移动数据 s = s[:copy(s, s[N:])] //删除中间N个元素 s = append(s[:i], s[i+N:]...) s = s[:i+copy(s[i:], s[i+N:])] //删除尾部N个元素 s = s[:len(s)-N] 修改元素 切片底层是数组，可像操作数组一样直接使用下标进行操作。\n","permalink":"https://afrusrsc.github.io/posts/program/go/go_delphi_array/","summary":"从其它平台迁移而来\n静态数组 一维数组 声明 Delphi\n1 var 数组名 : array[索引范围] of 元素类型; //索引范围是子界类型，格式为：下限..上限 Go\n1 var 数组名 [数组长度]元素类型 Delphi的索引范围可以是任意的子界类型，而且是包含上下限的闭区间。子界可以是任意的序数类型（整型、字符型、枚举元素等），例如：0..8、5..11、'a'..'z'等。子界元素就是数组元素的下标。\nGo的数组长度只能是整型，下标为0~数组长度-1。\n初始化 Delphi\n1 2 var 数组名 : array[1..N] of 元素类型 = (元素1, 元素2, ……, 元素N); //如果先声明后赋值的话，赋值时就需要遍历数组对每个元素分别赋值 Go\n1 2 3 4 5 6 7 8 9 10 11 var 数组名 [N]元素类型 = [N]元素类型{元素0, 元素1, ……, 元素N-1} //由于初始化时元素个数已知，以上代码也可写为： var 数组名 [N]元素类型 = [...]元素类型{元素0, 元素1, ……, 元素N-1} //如果先声明后赋值的话，写法如下： var 数组名 [N]元素类型 数组名 = [.","title":"从Delphi到Go——数组"},{"content":" 从其它平台迁移而来\n闲来无事，又开始扒拉起Delphi的源码，这次发现一个比较有意思的函数StringCodePage，作用是返回传入字符串的CodePage。至于什么是CodePage，暂且认为是字符编码吧。\n先测试一把：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var s1: AnsiString; s2: WideString; s3: UTF8String; cp1, cp2, cp3: Word; begin s1 := \u0026#39;123abc中国\u0026#39;; s2 := \u0026#39;123abc中国\u0026#39;; s3 := \u0026#39;123abc中国\u0026#39;; cp1 := StringCodePage(s1); //936 - GBK(简体中文) cp2 := StringCodePage(s2); //1200 - UCS-2LE Unicode 小端序 cp3 := StringCodePage(s3); //65001 - UTF-8 Unicode end; 来看下是怎么实现的：\n1 2 3 4 5 6 7 function StringCodePage(const S: UnicodeString): Word; overload; begin if S \u0026lt;\u0026gt; \u0026#39;\u0026#39; then Result := PWord(PByte(S) - 12)^ // StrRec.codePage else Result := Word(DefaultUnicodeCodePage); end; 原来字符串首地址逆向偏移12个字节所存放的Word型数据就是该字符串的CodePage信息。注释里出现了一个StrRec，看一下是何方神圣：\n1 2 3 4 5 6 StrRec = packed record codePage: Word; //代码页 elemSize: Word; //元素大小 refCnt: Integer; //引用计数 length: Integer; //字符串长度 end; 两个Word两个Integer刚好12B，那就看下所有字节吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function BytesToHex(p: PByte; len: Integer): string; var i: Integer; begin Result := \u0026#39;\u0026#39;; for i := 0 to len - 1 do Result := Result + \u0026#39; \u0026#39; + IntToHex((p + i)^, 2); Result := Trim(Result); end; var s1: AnsiString; s2: WideString; s3: UTF8String; s4: UnicodeString; hex1, hex2, hex3, hex4: string; begin s1 := \u0026#39;123abc中国\u0026#39;; s2 := \u0026#39;123abc中国\u0026#39;; s3 := \u0026#39;123abc中国\u0026#39;; s4 := \u0026#39;123abc中国\u0026#39;; hex1 := BytesToHex(PByte(s1) - 12, Length(s1) + 12); hex2 := BytesToHex(PByte(s2) - 12, Length(s2) * 2 + 12); hex3 := BytesToHex(PByte(s3) - 12, Length(s3) + 12); hex4 := BytesToHex(PByte(s4) - 12, Length(s4) * 2 + 12); //hex1: A8 03 01 00 01 00 00 00 0A 00 00 00 31 32 33 61 62 63 D6 D0 B9 FA //hex2: 86 06 D4 26 5E AC 00 18 10 00 00 00 31 00 32 00 33 00 61 00 62 00 63 00 2D 4E FD 56 //hex3: E9 FD 01 00 01 00 00 00 0C 00 00 00 31 32 33 61 62 63 E4 B8 AD E5 9B BD //hex4: B0 04 02 00 01 00 00 00 08 00 00 00 31 00 32 00 33 00 61 00 62 00 63 00 2D 4E FD 56 end; 查一下各个字符的编码备用：123abc的ASCII码就不必说了；中的GBK编码D6D0,Unicode编码4E2D，UTF-8编码E4B8AD；国的GBK编码B9FA,Unicode编码56FD，UTF-8编码E59BBD。\n先看s1，codePage：A8 03，elemSize：01 00，refCnt：01 00 00 00，length：0A 00 00 00，字符串内容：31 32 33 61 62 63 D6 D0 B9 FA。\n字符串内容比较好理解，与具体编码也都一一对上了，但是其它的又是怎么回事呢？用PWord和PInteger去取的话又是没问题的啊！其实是编译器大端、小端的问题，至于大小端问题这里不讨论，知道这里用的是小端就可以了。\n按小端来解析s1，codePage：03 A8=936，elemSize：00 01=1，refCnt：00 00 00 01=1，length：00 00 00 0A=10。\ns2就比较头大了，前8个字节总是变来变去，length：00 00 00 10=16，字符串内容按小端来解析也是没问题的。\n其中有这样一段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function _WStrLen(const S: _WideStr): Integer; inline; {$IFDEF CPU64BITS} begin Result := 0; if Pointer(S) \u0026lt;\u0026gt; nil then {$IFDEF MSWINDOWS} Result := PInteger(PByte(S) - 4)^ shr 1; {$ELSE} Result := PInteger(PByte(S) - 4)^; {$ENDIF} end; {$ELSE !CPU64BITS} begin Result := IntPtr(S); if Result \u0026lt;\u0026gt; 0 then {$IFDEF MSWINDOWS} Result := PInteger(PByte(Result - 4))^ shr 1; {$ELSE} Result := PInteger(PByte(Result - 4))^; {$ENDIF} end; {$ENDIF !CPU64BITS} 意思是说求WideString的长度时，windows平台下还需要右移一位，其实就是除以2。\ns3，codePage：FD E9=65001，elemSize：00 01=1，refCnt：00 00 00 01=1，length：00 00 00 0C=12，字符串内容与UTF-8编码一致。\ns4按小端来解析，codePage：04 B0=1200，elemSize：00 02=2，refCnt：00 00 00 01=1，length：00 00 00 08=8，字符串内容UCS-2LE编码一致。\n这里发现一个重大问题：WideString和UnicodeString虽然在内容上一样，但具体实现却是不同的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 var s1: AnsiString; s2: WideString; s3: UTF8String; s4: UnicodeString; begin Writeln(\u0026#39;@s1 : \u0026#39;, Cardinal(@s1)); Writeln(\u0026#39;@s1[1] : \u0026#39;, Cardinal(@s1[1])); Writeln(\u0026#39;@PByte(s1) : \u0026#39;, Cardinal(@PByte(s1))); Writeln(\u0026#39;PByte(s1) : \u0026#39;, Cardinal(PByte(s1))); s1 := \u0026#39;123abc中国\u0026#39;; Writeln(\u0026#39;s1 : \u0026#39;, s1); Writeln(\u0026#39;@s1 : \u0026#39;, Cardinal(@s1)); Writeln(\u0026#39;@s1[1] : \u0026#39;, Cardinal(@s1[1])); Writeln(\u0026#39;@PByte(s1) : \u0026#39;, Cardinal(@PByte(s1))); Writeln(\u0026#39;PByte(s1) : \u0026#39;, Cardinal(PByte(s1))); Writeln(\u0026#39;------------------------\u0026#39;); Writeln(\u0026#39;@s2 : \u0026#39;, Cardinal(@s2)); Writeln(\u0026#39;@s2[1] : \u0026#39;, Cardinal(@s2[1])); Writeln(\u0026#39;@PByte(s2) : \u0026#39;, Cardinal(@PByte(s2))); Writeln(\u0026#39;PByte(s2) : \u0026#39;, Cardinal(PByte(s2))); s2 := \u0026#39;123abc中国\u0026#39;; Writeln(\u0026#39;s2 : \u0026#39;, s2); Writeln(\u0026#39;@s2 : \u0026#39;, Cardinal(@s2)); Writeln(\u0026#39;@s2[1] : \u0026#39;, Cardinal(@s2[1])); Writeln(\u0026#39;@PByte(s2) : \u0026#39;, Cardinal(@PByte(s2))); Writeln(\u0026#39;PByte(s2) : \u0026#39;, Cardinal(PByte(s2))); Writeln(\u0026#39;------------------------\u0026#39;); Writeln(\u0026#39;@s3 : \u0026#39;, Cardinal(@s3)); Writeln(\u0026#39;@s3[1] : \u0026#39;, Cardinal(@s3[1])); Writeln(\u0026#39;@PByte(s3) : \u0026#39;, Cardinal(@PByte(s3))); Writeln(\u0026#39;PByte(s3) : \u0026#39;, Cardinal(PByte(s3))); s3 := \u0026#39;123abc中国\u0026#39;; Writeln(\u0026#39;s3 : \u0026#39;, s3); Writeln(\u0026#39;@s3 : \u0026#39;, Cardinal(@s3)); Writeln(\u0026#39;@s3[1] : \u0026#39;, Cardinal(@s3[1])); Writeln(\u0026#39;@PByte(s3) : \u0026#39;, Cardinal(@PByte(s3))); Writeln(\u0026#39;PByte(s3) : \u0026#39;, Cardinal(PByte(s3))); Writeln(\u0026#39;------------------------\u0026#39;); Writeln(\u0026#39;@s4 : \u0026#39;, Cardinal(@s4)); Writeln(\u0026#39;@s4[1] : \u0026#39;, Cardinal(@s4[1])); Writeln(\u0026#39;@PByte(s4) : \u0026#39;, Cardinal(@PByte(s4))); Writeln(\u0026#39;PByte(s4) : \u0026#39;, Cardinal(PByte(s4))); s4 := \u0026#39;123abc中国\u0026#39;; Writeln(\u0026#39;s4 : \u0026#39;, s4); Writeln(\u0026#39;@s4 : \u0026#39;, Cardinal(@s4)); Writeln(\u0026#39;@s4[1] : \u0026#39;, Cardinal(@s4[1])); Writeln(\u0026#39;@PByte(s4) : \u0026#39;, Cardinal(@PByte(s4))); Writeln(\u0026#39;PByte(s4) : \u0026#39;, Cardinal(PByte(s4))); Readln; end. 结果如图，不多解释了。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/delphi_string02/","summary":"从其它平台迁移而来\n闲来无事，又开始扒拉起Delphi的源码，这次发现一个比较有意思的函数StringCodePage，作用是返回传入字符串的CodePage。至于什么是CodePage，暂且认为是字符编码吧。\n先测试一把：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var s1: AnsiString; s2: WideString; s3: UTF8String; cp1, cp2, cp3: Word; begin s1 := \u0026#39;123abc中国\u0026#39;; s2 := \u0026#39;123abc中国\u0026#39;; s3 := \u0026#39;123abc中国\u0026#39;; cp1 := StringCodePage(s1); //936 - GBK(简体中文) cp2 := StringCodePage(s2); //1200 - UCS-2LE Unicode 小端序 cp3 := StringCodePage(s3); //65001 - UTF-8 Unicode end; 来看下是怎么实现的：\n1 2 3 4 5 6 7 function StringCodePage(const S: UnicodeString): Word; overload; begin if S \u0026lt;\u0026gt; \u0026#39;\u0026#39; then Result := PWord(PByte(S) - 12)^ // StrRec.","title":"再探Delphi字符串"},{"content":" 从其它平台迁移而来\n废话 长期从事Delphi开发，虽不敢说精通，但说很熟悉还是相当有自信的。不过，只会一门语言，而且还是这么老的语言，更是在大天朝很小众的语言，总感觉自己离饿死街头没多远了，所以趁着还没老再学个潮点的吧。\n先前考虑过Python，初步了解后觉得不太适合自己：\n解释型语言：部署时得先搞个运行环境，发布的程序就是源码本身，再加上这个执行效率，怎么想都还是编译型语言更合适。\n动态语言：无需声明，拿来就用，这已经很不合习惯了。想想一个变量，前一秒还是浮点数，下一秒就成字符串了，再一眨眼又成某个对象了……虽然一般不会有人这么写，但是挡不住手误啊，还是把这种小细节交给编译器更让人放心。\n所以，对于有点强迫症和洁癖的自己，最后还是选了Go，比较符合已有的编程习惯，学习成本应该相对会低些吧。\n至于Go嘛，想学是已经很久了，但由于种种原因却迟迟未开启，不过终究还是要迈出这一步的，所以就搞这么个系列来记录吧，一方面算是自我督促，另一方面也算是一种交流吧，当然，若一不留神帮上了谁，那自是开心极了。\n言归正传 已经初步了解过了Go，说来和Delphi还是有不少相似之处呢，从Delphi转向Go应该会比较轻松吧。\n工程结构 Delphi的工程算是比较自由的，源码的话，只要把单元路径引了或是直接包含进工程单元里就可以了，编译出的dcu和最终的exe指定下路径也就没问题了，通常我都使用下面这种结构：\n1 2 3 4 5 6 7 8 9 10 11 Project/ bin/ src/ dcu/ mod1/ *.dfm *.pas mod2/ *.dfm *.pas *.dpr 不过，每一个工程都要设置，而且我习惯将Debug和Release设置完全一样，也还真是够烦的。\nGo就没得选了，只有一种结构：\n1 2 3 4 5 6 7 8 9 10 11 Project/ bin/ pkg/ src/ *.go mod1/ *.go *_test.go mod2/ *.go *_test.go 整体和我原有的习惯差不多，还是蛮容易接受的，不过倒是要把这Project的路径加入到GOPATH系统变量里让人有一点小不爽。但是Go可以直接把测试都写了，这点还是蛮让我惊喜的，毕竟用了这么多年Delphi也没写过一行像样的测试。\n源码结构 Delphi典型的源码结构是这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 unit Unit1; interface uses ...//单元引用 type ...//公开类型定义 const ...//公开常量 var ...//公开变量 procedure Proc1;//公开过程声明 function Func1: Integer;//公开函数声明 implementation uses ...//私有单元引用 const ...//私有单元级常量 var ...//私有单元级变量 procedure Proc1; var ...//模块级变量 begin ...//公开过程实现 end; function Func1: Integer; const ...//模块级常量 begin ...//公开函数实现 end; procedure Proc2;//单元级私有过程实现 function Func2: Integer;//模块级私有函数实现 begin ... end; begin ... end; initialization ...//单元初始化代码 finalization ...//单元反初始化代码 end. Go的源码结构是这样：\n1 2 3 4 5 6 7 8 package pkg1 import \u0026#34;fmt\u0026#34; //导入包 const C1 //公开常量 const c2 //私有常量 var V1 //公开变量 var v2 //私有变量 func Func1(){}//公开方法 func func2(){}//私有方法 整体上来看，Delphi语意更明确，Go则更简洁，Delphi更集中，Go则和所有类c语言一样比较单一、灵活，各有各的好。倒是Go这用首字母大小写来区分公开私有让我这喜欢pascal命名法的有点尴尬。\n注释 Delphi\n1 2 3 4 5 6 7 8 9 10 //这是单行注释 { 这是多行注释第一行 这是多行注释第二行 } (* 这是另外一种多行注释 与{}可以互相包含 主要用于注释内容中有 } 的情况 *) Go\n1 2 3 4 5 //这是单行注释 /* 这是多行注释第一行 这是多行注释第二行 */ 文档 Delphi安装CnPack之后，可以使用xml风格的注释，写在方法前可以成为方法的文档说明。\nGo提供的godoc也可以从代码中提取顶级声明的首行注释以及每个对象的相关注释生成相关文档。\n运算符 Delphi\n赋值运算符：:= 算术运算符：+、-、*、/、div、mod 逻辑运算符：not、and、or、xor 位运算符：not、and、or、xor、shl、shr 关系运算符：=、\u0026lt;\u0026gt;、\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;= 指针运算符：^、+、-、=、\u0026lt;\u0026gt; 地址运算符：@ 字符串连接符：+ 集合运算符：+、-、*、\u0026lt;=、\u0026gt;=、=、=、\u0026lt;\u0026gt;、in 类运算符：as、is、=、\u0026lt;\u0026gt; Go\n赋值运算符：=、:=、+=、-=、*=、/=、%=、\u0026lt;\u0026lt;=、\u0026gt;\u0026gt;=、\u0026amp;=、|=、^= 算术运算符：+、-、*、/、%、++、-- 逻辑运算符：!、\u0026amp;\u0026amp;、|| 位运算符：\u0026lt;\u0026lt;、\u0026gt;\u0026gt;、\u0026amp;、|、^ 关系运算符：==、!=、\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;= 指针运算符：* 地址运算符：\u0026amp; 字符串连接符：+ 基本数据类型 Delphi\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //整型 ShortInt 1B -128~127 Byte 1B 0~255 SmallInt 2B -32768~32767 Word 2B 0~65535 LongInt 4B -2147483648~2147483647 LongWord 4B 0~4294967295 Int64 8B -9223372036854775808~9223372036854775807 UInt64 8B 0~18446744073709551615 Integer 4B -2147483648~2147483647 Cardinal 4B 0~4294967295 //浮点型 Single 4B Real48 6B //从未用过 Double 8B Real 8B Currency 8B //金融专用 //布尔型 Boolean 1B ByteBool 1B WordBool 2B LongBool 4B //字符型 AnsiChar 1B //ANSI编码 WideChar 2B //Unicode编码 Char //早期版本相当于AnsiChar，后期WideChar //字符串 ShortString //兼容老旧版本 AnsiString //ANSI编码 WideString //Unicode编码 String //早期版本相当于AnsiString，后期WideString //指针 Pointer //变体类型 Variant Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //整型 int8 1B -128~127 uint8 1B 0~255 int16 2B -32768~32767 uint16 2B 0~65535 int32 4B -2147483648~2147483647 uint32 4B 0~4294967295 int64 8B -9223372036854775808~9223372036854775807 uint64 8B 0~18446744073709551615 int //有符号，与平台相关 uint //无符号，与平台相关 //浮点型 float32 4B float64 8B //布尔型 bool //字符型 byte //uint8的别名，通常用于表明原始数据 rune //等价于int32，通常用于表示一个UTF-8字符 //字符串 string //UTF-8编码 //指针 uintptr //复数 complex64 complex128 //map类型 map[键类型] 值类型 //接口类型 interface{} //错误类型 error 整体上看，两者数据类型基本一致，不过Go直接支持了map和复数类型。另外，Go也没有变体类型，不过可以用接口类型interface{}来实现传任意类型。需要注意的是，Go的字符串是UTF-8编码而不是Unicode编码。\n数据类型转换 Delphi在数据类型兼容时可直接进行隐式转换，也可进行显式（强制）转换，语法为：类型B的值 := 类型B(类型A的值)；Go不存在隐式转换，需要转换时只能使用显式（强制）转换，语法为：类型B的值 = 类型B(类型A的值)。\n变量 Delphi\n1 2 3 4 5 6 7 8 9 //声明变量 var v1 : string; v2, v3 : Integer; //声明并初始化 var v4 : Double = 3.14; //变量赋值 v1 := \u0026#39;abc\u0026#39;; Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 //声明变量 var ( v1 string v2, v3 int ) //声明并初始化 var v4 float64 = 3.14 var v5 = 1234 //在函数内还可以这样 v6 := 2468 //变量赋值 v1 = \u0026#39;abc\u0026#39; v2, v3 = v3, v2 变量声明都用了关键字var，且都是变量在前，类型在后，也都支持批量声明，声明并初始化的语法也基本一致，赋值也几乎一致。\n不过Go还多了一些特性：\n支持类型推导，声明并初始化时可省略类型。\n在函数内部声明并初始化变量时还支持用:=的方式简写（不过这和Delphi的赋值符号一样，意义却大相径庭，使用时得留意了）。\n函数内部的变量可以像c++一样达到语块级的作用域和生命期。\n支持多重赋值，交换变量更简洁。\n支持匿名变量，即用_来占位。\n常量 Delphi\n1 2 3 4 const c1: string = \u0026#39;abc\u0026#39;; c2 = \u0026#39;123\u0026#39;; c3 = 456; Go\n1 2 3 4 5 6 7 const ( c1 string = \u0026#34;abc\u0026#34; c2 = \u0026#34;123\u0026#34; c3 = 456 c4 //与c3一样 c5, c6 = 1.2, true ) 都用了关键字const，都支持批量声明，也都支持类型推导，而且Go的类型推导更智能些，换句话说就叫更复杂些（主要是因为与别的混在一起了）。\n枚举 Delphi\n1 2 3 4 5 6 7 8 type myEnum=( eA, //0 eB, //1 eC = 10, //10 eD, //11 eE, //12 eF //13 ); Go\n1 2 3 4 5 6 7 8 const( eA = iota //0 eB //1 eC = 10 //10 eD //10 eE = iota //4 eF //5 ) Delphi使用关键字type来声明一个枚举类型，而且还需要命名，默认以0开始递增，也可以为某一元素指定值，其后元素依次递增。\nGo没有枚举的关键字，但使用const和iota也可以达到目的。iota每次遇到const就重置为0，每增加一个元素就自增1，无论元素有没有取iota的值。\n不过，一般情况下很少会为枚举的元素指定特定值。\n类型和别名 Delphi\n1 2 3 4 //定义类型 type myInt = type Integer; //类型别名 type myInt = Integer; Go\n1 2 3 4 //定义类型 type myInt int //类型别名 type myInt = int 数组 Delphi\n1 2 3 4 5 6 7 8 //静态数组 var r1 : array[0..9] of Byte; var r2 : array[0..1] of Boolean = (True, False); var r3 : array[0..3,0..1] of Integer; //二维静态数组 var r4 : array[0..3] of array[0..1] of Integer; //同上 //动态数组 var r5 : array of Integer; //一维动态数组 var r6 : array of array of Integer; //二维动态数组 Go\n1 2 3 4 5 6 7 //静态数组 var r1 [10]byte var r2 [2]bool{true,false} var r3, r4 [4][2]int //用切片来代替动态数组 var r5 []int var r6 [][]int Go没有专门的动态数组，不过有更为灵活、实用的切片，用切片完全可以实现动态数组的功能。\n结构体 Delphi\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //定义 type TEmp = record Name : string; Age : Integer; end; PEmp = ^TEmp; var emp : TEmp; p : PEmp; //赋值 p := @emp; emp.Name := \u0026#39;Sam\u0026#39;; //p^.Name := \u0026#39;Sam\u0026#39;; emp.Age := 10; //p^.Age := 10; //还有一种带packed的结构体，由于不会进行内存对齐而速度略慢，但用于dll时可避免内存混乱 type TRcd = packed record B : Byte; C : Integer; end; Go\n1 2 3 4 5 6 7 8 9 10 11 12 type TEmp struct { Name string Age int } var( emp TEmp p *TEmp ) p = *emp emp.Name = \u0026#34;Sam\u0026#34; //(*p).Name = \u0026#34;Sam\u0026#34; //p.Name = \u0026#34;Sam\u0026#34; emp.Age = 10 //(*p).Age = 10 //p.Age = 10 分支 Delphi\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //if if 布尔表达式 then ...; //if ... else ... if 布尔表达式 then ... else ...; //if ... else if ... if 条件表达式1 then ... else if 布尔表达式2 then ... else ...; //case语句 case 选项表达式 of 值1: ...; 值2: ...; else ...; end; Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 //if if 布尔表达式 { ... } //if ... else ... if 布尔表达式 { ... } else { ... } //if ... else if ... if 布尔表达式1 { ... } else if 布尔表达式2 { ... } else { ... } //switch switch 选项表达式 { case 值1: ... fallthrough //兼容C语言的case，强制执行下一个case case 值2: ... default: ... } switch{ case 选项表达式 == 值1: ... case 选项表达式 == 值2: ... default: ... } switch 类型表达式 { case 类型1: ... case 类型2: ... default: ... } 循环 Delphi\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //升幂记数循环 for 记数变量 := 起始值 to 终点值 do //起始值\u0026lt;终点值，变量每循环变化1 语句; //降幂记数循环 for 记数变量 := 起始值 downto 终点值 do //起始值\u0026gt;终点值，变量每循环变化1 语句; //高版本支持，2009+？ for 循环变量 in 集合 do 语句; //当型循环，当表达式值为真时执行循环 while 布尔表达式 do 语句; //直到型循环，当表达式值为真时退出循环 repeat 语句; until 布尔表达式; Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //类C的for循环 for 循环变量初始化; 条件表达式; 循环变量改变 { ... } //类C的while循环 for 条件表达式 { ... } //无限循环 for{ ... } //类C的for each for k, v := range R {//R可为数组、切片、map、字符串等 ... } 控制语句 goto 都用来直接跳转到指定标签处继续向下执行。Delphi需要先使用label声明标签，Go则直接使用标签，标签的语法均为：\n1 2 labelA: ... continue 都用来结束本次循环并进入下一次循环。在多层循环中，Go还可以在其后跟标签，用来结束标签对应的那层循环并进入下一次循环。\nbreak 都用来结束当前循环并执行当前循环之后的代码。在多层循环中，Go还可以在其后跟标签，用来结束标签对应的那层循环并执行循环之后的代码。\n函数 Delphi\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //过程，无返回值 procedure Proc1; begin ... end; procedure Proc2(i1, i2: Integer; s1, s2: string); begin ... Proc1; end; //函数，有返回值 function Func1: string; begin ... Result := \u0026#39;返回值\u0026#39;; Proc2(1, 2, \u0026#39;abc\u0026#39;, \u0026#39;def\u0026#39;); end; function Func2(i1, i2: Integer; s1, s2: string): string; begin ... Result := Func1(); end; Go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //无返回值 func f1() { ... } func f2(i1, i2 int, s1, s2 string) { ... f1() } //有返回值 func f3() string { r := \u0026#34;返回值\u0026#34; return r //必须带 r } func f4() (s string) { s = f3() return s //可省略 s } func f5() (r1 int, r2 string) { r1, r2 = f6(1, 2, \u0026#39;abc\u0026#39;, \u0026#39;def\u0026#39;) return r1, r2 //可省略 r1, r2，若不省略，则顺序必须一致 } func f6(i1, i2 int, s1, s2 string) (r1 int, r2 string) { r1 = i1 + i2 r2 = s1 + s2 return } Delphi无返回值的用procedure，有返回值的用function；Go统一用func。\n都接受0个或多个参数，Delphi同类型参数间用,分隔，不同类型参数间用;分隔；Go统一用,分隔。\nDelphi函数只能有1个返回值，且返回值固定由Result隐藏变量携带，Result可多次赋值，之后也可有其它语句；Go可以有0个或多个返回值，返回值变量可以声明也可以不声明，但必须由return返回且必须为最后一条语句，若返回值变量有多个且已声明，return后跟的返回值变量顺序必须与定义一致。\nDelphi无参过程/函数调用时，括号()可带可不带；Go无参函数调用时必须带()。\nDelphi被调用的过程/函数必须在主调过程/函数之前实现或在interface区已声明；Go函数没有声明只有实现，且不要求被调函数在主调函数之前定义。\n以下概念比较庞杂，三言两语难以说清楚，暂且告一段落\n错误处理 接口 面向对象 并发 ","permalink":"https://afrusrsc.github.io/posts/program/go/go_delphi_base/","summary":"从其它平台迁移而来\n废话 长期从事Delphi开发，虽不敢说精通，但说很熟悉还是相当有自信的。不过，只会一门语言，而且还是这么老的语言，更是在大天朝很小众的语言，总感觉自己离饿死街头没多远了，所以趁着还没老再学个潮点的吧。\n先前考虑过Python，初步了解后觉得不太适合自己：\n解释型语言：部署时得先搞个运行环境，发布的程序就是源码本身，再加上这个执行效率，怎么想都还是编译型语言更合适。\n动态语言：无需声明，拿来就用，这已经很不合习惯了。想想一个变量，前一秒还是浮点数，下一秒就成字符串了，再一眨眼又成某个对象了……虽然一般不会有人这么写，但是挡不住手误啊，还是把这种小细节交给编译器更让人放心。\n所以，对于有点强迫症和洁癖的自己，最后还是选了Go，比较符合已有的编程习惯，学习成本应该相对会低些吧。\n至于Go嘛，想学是已经很久了，但由于种种原因却迟迟未开启，不过终究还是要迈出这一步的，所以就搞这么个系列来记录吧，一方面算是自我督促，另一方面也算是一种交流吧，当然，若一不留神帮上了谁，那自是开心极了。\n言归正传 已经初步了解过了Go，说来和Delphi还是有不少相似之处呢，从Delphi转向Go应该会比较轻松吧。\n工程结构 Delphi的工程算是比较自由的，源码的话，只要把单元路径引了或是直接包含进工程单元里就可以了，编译出的dcu和最终的exe指定下路径也就没问题了，通常我都使用下面这种结构：\n1 2 3 4 5 6 7 8 9 10 11 Project/ bin/ src/ dcu/ mod1/ *.dfm *.pas mod2/ *.dfm *.pas *.dpr 不过，每一个工程都要设置，而且我习惯将Debug和Release设置完全一样，也还真是够烦的。\nGo就没得选了，只有一种结构：\n1 2 3 4 5 6 7 8 9 10 11 Project/ bin/ pkg/ src/ *.go mod1/ *.go *_test.go mod2/ *.go *_test.go 整体和我原有的习惯差不多，还是蛮容易接受的，不过倒是要把这Project的路径加入到GOPATH系统变量里让人有一点小不爽。但是Go可以直接把测试都写了，这点还是蛮让我惊喜的，毕竟用了这么多年Delphi也没写过一行像样的测试。\n源码结构 Delphi典型的源码结构是这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 unit Unit1; interface uses .","title":"从Delphi到Go——基础"},{"content":" 从其它平台迁移而来\n在从数据库中查询数据时，有时需要事先取得字段内容的大小，再根据情况进行处理。\n对于ADO之类返回TField类型的，可以使用DataSize属性，但是！！！这里有很深的坑！！！。\n首先看如下代码：\n1 2 3 4 if ADOQuery.FieldByName(\u0026#39;Test\u0026#39;).DataSize \u0026gt; 3 then {处理1} else {处理2}; 按预想，当Test字段里的数据超过3B时，应该执行处理1的代码，但事实上无论该内容长短，都是执行处理2的代码，WHY?\n扒一下Delphi的源码就明白了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 function TField.GetDataSize: Integer; begin Result := 0; end; function TStringField.GetDataSize: Integer; begin Result := Size + 1; end; function TWideStringField.GetDataSize: Integer; begin Result := (Size + 1) * SizeOf(WideChar); end; function TIntegerField.GetDataSize: Integer; begin Result := SizeOf(Integer); end; function TLongWordField.GetDataSize: Integer; begin Result := SizeOf(LongWord); end; function TSmallintField.GetDataSize: Integer; begin Result := SizeOf(SmallInt); end; function TShortintField.GetDataSize: Integer; begin Result := SizeOf(ShortInt); end; function TByteField.GetDataSize: Integer; begin Result := SizeOf(Byte); end; function TLargeintField.GetDataSize: Integer; begin Result := SizeOf(Largeint); end; function TWordField.GetDataSize: Integer; begin Result := SizeOf(Word); end; function TFloatField.GetDataSize: Integer; begin Result := SizeOf(Double); end; function TSingleField.GetDataSize: Integer; begin Result := SizeOf(Single); end; function TExtendedField.GetDataSize: Integer; begin Result := SizeOf(Extended); end; function TBooleanField.GetDataSize: Integer; begin Result := SizeOf(WordBool); end; function TDateTimeField.GetDataSize: Integer; begin Result := SizeOf(TDateTime); end; function TSQLTimeStampField.GetDataSize: Integer; begin Result := SizeOf(TSQLTimeStamp); end; function TSQLTimeStampOffsetField.GetDataSize: Integer; begin Result := SizeOf(TSQLTimeStampOffset); end; function TDateField.GetDataSize: Integer; begin Result := SizeOf(Integer); end; function TTimeField.GetDataSize: Integer; begin Result := SizeOf(Integer); end; function TBytesField.GetDataSize: Integer; begin Result := Size; end; function TVarBytesField.GetDataSize: Integer; begin Result := Size + SizeOf(Word) {Length Prefix}; end; function TBCDField.GetDataSize: Integer; begin // SizeOf(TBcd) is used here instead of SizeOf(Currency) because some // datasets store the currency data in TBcd format in the record buffer. // For these classes (TBDEDataset \u0026amp; TClientDataset) a call to // TField.GetData(Buffer, True) will return a TBcd. Result := SizeOf(TBcd); end; function TFMTBCDField.GetDataSize: Integer; begin Result := SizeOf(TBcd); end; function TBlobField.GetDataSize: Integer; begin // Blob data is not stored in the record buffer and can not be read // with a call to TField.GetData. Use GetBlobSize instead. Result := 0; end; function TReferenceField.GetDataSize: Integer; begin Result := FSize + 2; end; 也就是说，不能直接取DataSize，而是需要转换为实际的类型后再取DataSize，而且TBlobField是特例，需要使用TBlobField.BlobSize。那么，刚才的例子应该这样写（假设字段类型是Blob）：\n1 2 3 4 if TBlobField(ADOQuery.FieldByName(\u0026#39;Test\u0026#39;)).BlobSize \u0026gt; 3 then {处理1} else {处理2}; ","permalink":"https://afrusrsc.github.io/posts/program/pascal/delphi_field_datasize/","summary":"从其它平台迁移而来\n在从数据库中查询数据时，有时需要事先取得字段内容的大小，再根据情况进行处理。\n对于ADO之类返回TField类型的，可以使用DataSize属性，但是！！！这里有很深的坑！！！。\n首先看如下代码：\n1 2 3 4 if ADOQuery.FieldByName(\u0026#39;Test\u0026#39;).DataSize \u0026gt; 3 then {处理1} else {处理2}; 按预想，当Test字段里的数据超过3B时，应该执行处理1的代码，但事实上无论该内容长短，都是执行处理2的代码，WHY?\n扒一下Delphi的源码就明白了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 function TField.","title":"关于TField.DataSize的坑"},{"content":" 从其它平台迁移而来\n想学golang也就是Go语言由来已久，但苦于不像Delphi、C#这等有现成的IDE，第一步就卡壳了。所幸网上资源丰富，在尝试后终于把环境搭起来了，在此做个记录以备忘。\n安装 Git 安装Go Tools时需要用到。而且，搞开发不用Git？图样图森破！\nGit 官网（Git for windows 国内镜像），安装略。若已安装WSL则可直接使用WSL里的Git。\n安装 golang 由于众所周知的原因，Go的官网并不总是能访问，其实在国内是有一个官方镜像的。下载安装什么的就略过了。\n环境变量 安装好之后在命令行里运行go env即可查看Go环境变量。\nGOROOT：就是Go的安装目录，如C:\\Go。\nGOPATH：Go的工程目录，不能是Go的安装目录，可以有多个目录，多个目录之间用;分隔，且下面安装的Go Tools会安装在第一个目录。如：C:\\Users\\Administrator\\go。\n安装 VS Code 下载VS Code，并安装，没什么好说的。\n安装配置中文：打开VS Code，按Ctrl+Shift+P，输入display，选择Configure Display Language回车，选择zh-cn回车，若无则选择Install additional languages...回车，在左侧选择中文安装，安装完之后根据提示重启。\n按Ctrl+Shift+X搜索Go，安装微软的Go插件。\n关闭VS Code。\n安装 Go Tools 旧方案 主要是完全由VS Code来下载速度会异常感人。\n打开命令行依次执行以下语句 1 2 3 4 ::下载tools git clone https://github.com/golang/tools.git %GOPATH%\\src\\golang.org\\x\\tools ::下载lint git clone https://github.com/golang/lint.git %GOPATH%\\src\\golang.org\\x\\lint 待全部下载完之后，打开VS Code。\nCtrl+N新建一个文档，选择语言模式为Go，会有Analysis Tools Missing的提示，点Install坐等完成（共11个），安装完成之后查看是否全部成功，最后重启VS Code。\n重启后在刚才新建的文档里写上go代码并保存，按F5调试，验证效果。\n自备梯子后，可直接运行以下批处理进行Go Tools的安装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ::代码补全 go get -v github.com/stamblerre/gocode cd /d C:\\Users\\Administrator\\go\\bin del /f /q gocode-gomod.exe ren gocode.exe gocode-gomod.exe go get -v github.com/mdempsky/gocode go get -v github.com/uudashr/gopkgs/v2/cmd/gopkgs go get -v github.com/ramya-rao-a/go-outline go get -v github.com/acroca/go-symbols go get -v golang.org/x/tools/cmd/gorename go get -v github.com/cweill/gotests/... go get -v github.com/fatih/gomodifytags go get -v github.com/josharian/impl go get -v github.com/davidrjenni/reftools/cmd/fillstruct go get -v github.com/haya14busa/goplay/cmd/goplay go get -v github.com/godoctor/godoctor go get -v github.com/go-delve/delve/cmd/dlv go get -v github.com/rogpeppe/godef ::Docs Tool go get -v github.com/zmb3/gogetdoc go get -v golang.org/x/tools/cmd/guru ::Format Tool go get -v golang.org/x/tools/cmd/goimports go get -v github.com/sqs/goreturns go get -v winterdrache.de/goformat/goformat ::Lint Tool go get -v golang.org/x/lint/golint go get -v github.com/golangci/golangci-lint/cmd/golangci-lint go get -v github.com/mgechev/revive go get -v honnef.co/go/tools/... ::Go language server go get -v golang.org/x/tools/gopls 新方案 感谢七牛！安装完go之后就在命令行里执行以下语句，更改为国内代理，然后再使用，一切就都变得无比顺滑~\n1 go env -w GOPROXY=https://goproxy.cn,direct ","permalink":"https://afrusrsc.github.io/posts/program/go/go_vscod/","summary":"从其它平台迁移而来\n想学golang也就是Go语言由来已久，但苦于不像Delphi、C#这等有现成的IDE，第一步就卡壳了。所幸网上资源丰富，在尝试后终于把环境搭起来了，在此做个记录以备忘。\n安装 Git 安装Go Tools时需要用到。而且，搞开发不用Git？图样图森破！\nGit 官网（Git for windows 国内镜像），安装略。若已安装WSL则可直接使用WSL里的Git。\n安装 golang 由于众所周知的原因，Go的官网并不总是能访问，其实在国内是有一个官方镜像的。下载安装什么的就略过了。\n环境变量 安装好之后在命令行里运行go env即可查看Go环境变量。\nGOROOT：就是Go的安装目录，如C:\\Go。\nGOPATH：Go的工程目录，不能是Go的安装目录，可以有多个目录，多个目录之间用;分隔，且下面安装的Go Tools会安装在第一个目录。如：C:\\Users\\Administrator\\go。\n安装 VS Code 下载VS Code，并安装，没什么好说的。\n安装配置中文：打开VS Code，按Ctrl+Shift+P，输入display，选择Configure Display Language回车，选择zh-cn回车，若无则选择Install additional languages...回车，在左侧选择中文安装，安装完之后根据提示重启。\n按Ctrl+Shift+X搜索Go，安装微软的Go插件。\n关闭VS Code。\n安装 Go Tools 旧方案 主要是完全由VS Code来下载速度会异常感人。\n打开命令行依次执行以下语句 1 2 3 4 ::下载tools git clone https://github.com/golang/tools.git %GOPATH%\\src\\golang.org\\x\\tools ::下载lint git clone https://github.com/golang/lint.git %GOPATH%\\src\\golang.org\\x\\lint 待全部下载完之后，打开VS Code。\nCtrl+N新建一个文档，选择语言模式为Go，会有Analysis Tools Missing的提示，点Install坐等完成（共11个），安装完成之后查看是否全部成功，最后重启VS Code。\n重启后在刚才新建的文档里写上go代码并保存，按F5调试，验证效果。\n自备梯子后，可直接运行以下批处理进行Go Tools的安装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ::代码补全 go get -v github.","title":"Windows + VS Code搭建 Go 开发环境"},{"content":" 从其它平台迁移而来\n在开发过程中，不可避免的要用到多线程，而线程的同步、释放等又可能引入新的问题，不过网上已有许多资料，这里重点说下我使用的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 type TMyThread = class(TThread) protected procedure Execute; override; public constructor Create(...); destructor Destroy; override; //使用 reintroduce 关键字可以明确通知编译器屏蔽父类的同名方法而使用自己的方法。 procedure Free; reintroduce; end; constructor TMyThread.Create(...); begin { 在这里创建相关对象，可以省去先挂起线程再恢复的操作 } inherited Create; end; destructor TMyThread.Destroy; begin { 在这里释放相关资源 } inherited Destroy; end; procedure TMyThread.Execute; begin FreeOnTerminate := True; while not Terminated do begin { 线程处理 } Sleep(100); //根据实际情况设置 end; end; procedure TMyThread.Free; begin //终止线程 Terminate; //等待线程结束 while not Finished do Sleep(1); end; 这样一来，就可以像普通类一样使用Free来释放线程了，但是不能使用FreeAndNil进行释放。\n当然，一定要调用Free才行。良好的编程习惯还是要有的！\n2019-09-07 最近又研究了一下安全结束线程的方法，又有一些新发现。\nDelphi 2007及以前是没有线程的Finished属性的（好像是Delphi 2009以后才有的，具体没有深究），以上方法无法使用。\n线程自己的Free方法其实是很完善的（用Delphi XE 10.3，其它未测试），可以直接使用，但前提是不使用FreeOnTerminate := True;，否则会调用两次Destroy，肯定要报错了！如此看来，若坚持谁创建谁释放的原则，FreeOnTerminate := True;根本没有用武之地。\n既然Free可以使用，FreeAndNil自然也可以使用。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/delphi_thread/","summary":"从其它平台迁移而来\n在开发过程中，不可避免的要用到多线程，而线程的同步、释放等又可能引入新的问题，不过网上已有许多资料，这里重点说下我使用的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 type TMyThread = class(TThread) protected procedure Execute; override; public constructor Create(...); destructor Destroy; override; //使用 reintroduce 关键字可以明确通知编译器屏蔽父类的同名方法而使用自己的方法。 procedure Free; reintroduce; end; constructor TMyThread.Create(...); begin { 在这里创建相关对象，可以省去先挂起线程再恢复的操作 } inherited Create; end; destructor TMyThread.","title":"Delphi安全结束线程"},{"content":" 从其它平台迁移而来\n在开发多屏应用程序的时候，经常需要把某个窗口置到某个屏上的某个位置。以下是一个Delphi写的置屏方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 procedure ShowInMonitor(Sender: TObject; AIndex: Integer; ALeft: Integer = 0; ATop: Integer = 0); var lM: TMonitor; begin if Sender is TControl then begin if AIndex \u0026gt; Screen.MonitorCount - 1 then begin AIndex := 0; end; lM := Screen.Monitors[AIndex]; (Sender as TControl).Left := lM.Left + ALeft; (Sender as TControl).Top := lM.Top + ATop; end; end; Sender是需要置屏的窗口；AIndex是置屏的目标屏号，从0开始；ALeft是水平偏移量，ATop是垂直偏移量，默认均为0，即在目标屏的左上角。\n坑 通常情况下，使用该方法对当前窗口置屏，是没有任何问题的。\n但是，对于动态创建的窗口，很可能就会发现不正常。今天一上午都在弄这货，始终没搞定，到下午突然发现症结，然后一下子就好了，在此做个记录备忘。\n问题很简单：是调用顺序的问题。正确的调用顺序应该是Show-\u0026gt;ShowInMonitor。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/delphi_screen_monitor/","summary":"从其它平台迁移而来\n在开发多屏应用程序的时候，经常需要把某个窗口置到某个屏上的某个位置。以下是一个Delphi写的置屏方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 procedure ShowInMonitor(Sender: TObject; AIndex: Integer; ALeft: Integer = 0; ATop: Integer = 0); var lM: TMonitor; begin if Sender is TControl then begin if AIndex \u0026gt; Screen.MonitorCount - 1 then begin AIndex := 0; end; lM := Screen.Monitors[AIndex]; (Sender as TControl).Left := lM.Left + ALeft; (Sender as TControl).Top := lM.Top + ATop; end; end; Sender是需要置屏的窗口；AIndex是置屏的目标屏号，从0开始；ALeft是水平偏移量，ATop是垂直偏移量，默认均为0，即在目标屏的左上角。","title":"关于窗口置屏的那个坑"},{"content":" 从其它平台迁移而来\n在用Delphi开发数据库应用过程中，经常需要用到DBBrid来显示或编辑数据库表，但相对于IDE自带的DBBrid，DBGridEh显然要更好用一些（cxDBGrid也同样好使，这里只对DBGridEh进行说明）。\n在数据库表结构设计时，通常会习惯使用整型字段来存储如男、女、已修改、已删除、已作废等具有标记性的信息，好处是占存储空间小且可扩展性强，缺点是显示方式不友好，但是，使用DBGridEh的一些设置可以弥补这个缺陷。\n假设数据库里的表T_Demo里有一个表示性别的字段Sex，其用0表示男，1表示女，2表示未知，用DBGridEh显示时仍为0、1、2，十分不友好。这时只要做一点美化即可。\n在DBGridEh的对应列的KeyList属性里分别加入0、1、2三个数字，每个数字一行，用代码实现的话就是： 1 2 3 4 5 //这里假设第一列就是性别，以下代码相同 DBGridEh.Columns[0].KeyList.Clear; DBGridEh.Columns[0].KeyList.Append(\u0026#39;0\u0026#39;); DBGridEh.Columns[0].KeyList.Append(\u0026#39;1\u0026#39;); DBGridEh.Columns[0].KeyList.Append(\u0026#39;2\u0026#39;); 在DBGridEh的对应列的PickList属性里分别加入男、女、未知三行，用代码实现是： 1 2 3 4 DBGridEh.Columns[0].PickList.Clear; DBGridEh.Columns[0].PickList.Append(\u0026#39;男\u0026#39;); DBGridEh.Columns[0].PickList.Append(\u0026#39;女\u0026#39;); DBGridEh.Columns[0].PickList.Append(\u0026#39;未知\u0026#39;); 这样，原先显示为0、1、2的性别就变成了男、女、未知。也可以加上图片来进一步美化。\n放置一个TImagList控件，并命名为ilSex，然后分别添加三个图片，比如像卫生间的男、女图片和问号，注意添加后图片对应的索引，否则会张冠李戴。\n在DBGridEh的ImagList属性里关联ilSex，并且设置ShowImageAndText属性为True，用代码是：\n1 2 DBGridEh.ImagList := ilSex; DBGridEh.ShowImageAndText := True; 这样，性别这一列就有图片有文字，比0、1、2要友好很多，而且在编辑的时候也可以直接下拉进行选择来实现性别的录入。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/ehlib_dbgrideh_field_dict/","summary":"从其它平台迁移而来\n在用Delphi开发数据库应用过程中，经常需要用到DBBrid来显示或编辑数据库表，但相对于IDE自带的DBBrid，DBGridEh显然要更好用一些（cxDBGrid也同样好使，这里只对DBGridEh进行说明）。\n在数据库表结构设计时，通常会习惯使用整型字段来存储如男、女、已修改、已删除、已作废等具有标记性的信息，好处是占存储空间小且可扩展性强，缺点是显示方式不友好，但是，使用DBGridEh的一些设置可以弥补这个缺陷。\n假设数据库里的表T_Demo里有一个表示性别的字段Sex，其用0表示男，1表示女，2表示未知，用DBGridEh显示时仍为0、1、2，十分不友好。这时只要做一点美化即可。\n在DBGridEh的对应列的KeyList属性里分别加入0、1、2三个数字，每个数字一行，用代码实现的话就是： 1 2 3 4 5 //这里假设第一列就是性别，以下代码相同 DBGridEh.Columns[0].KeyList.Clear; DBGridEh.Columns[0].KeyList.Append(\u0026#39;0\u0026#39;); DBGridEh.Columns[0].KeyList.Append(\u0026#39;1\u0026#39;); DBGridEh.Columns[0].KeyList.Append(\u0026#39;2\u0026#39;); 在DBGridEh的对应列的PickList属性里分别加入男、女、未知三行，用代码实现是： 1 2 3 4 DBGridEh.Columns[0].PickList.Clear; DBGridEh.Columns[0].PickList.Append(\u0026#39;男\u0026#39;); DBGridEh.Columns[0].PickList.Append(\u0026#39;女\u0026#39;); DBGridEh.Columns[0].PickList.Append(\u0026#39;未知\u0026#39;); 这样，原先显示为0、1、2的性别就变成了男、女、未知。也可以加上图片来进一步美化。\n放置一个TImagList控件，并命名为ilSex，然后分别添加三个图片，比如像卫生间的男、女图片和问号，注意添加后图片对应的索引，否则会张冠李戴。\n在DBGridEh的ImagList属性里关联ilSex，并且设置ShowImageAndText属性为True，用代码是：\n1 2 DBGridEh.ImagList := ilSex; DBGridEh.ShowImageAndText := True; 这样，性别这一列就有图片有文字，比0、1、2要友好很多，而且在编辑的时候也可以直接下拉进行选择来实现性别的录入。","title":"DBGridEh显示、编辑标记字段"},{"content":" 从其它平台迁移而来\n生成指定范围内的随机数，有相应的随机函数（如RandomRange(x, y)可生成x \u0026lt;= d \u0026lt; y的随机整数），或者在基本的随机函数上稍加修改也可生成；生成 n 个随机数，只需调用 n 次随机函数即可；生成 n 个不重复的随机数，就会有一点点小麻烦。\n常规思路 一般来说，要生成n个不重复的随机数，只需判断每次生成的随机数有没有和这前生成的随机数重复即可，若重复即抛弃，不重复则记录。\n但是，这样要进行很多额外的判断，而且当生成的量变大时，这样的判断次数也几乎是呈指数级的增加（具体复杂度没有进行详细分析）。\n另一种思路 如果每生成一个随机整数，就在一个整数序列上对应的位置做一个标记，那么只需要判断标记的个数有没有达到n即可，然后把有标记的整数取出就是 n 个不重复的随机整数。（其实该思路是借鉴了某个排序算法的思路，具体算法名称不记得了）\n首先来考虑生成 n 个[0, m)的不重复的随机数方法，n \u0026lt; m。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var i: Integer; tmpMark: array of Integer; begin SetLength(tmpMark, m); repeat Randomize; i := RandomRange(0, m); //[0,m)半开半闭区间 tmpMark[i] := 1; until SumInt(tmpMark) = n; for i := 0 to m - 1 do if tmpMark[i] = 1 then i; //i即为随机出的不重复的整数 end; 本例中借助长度为m的数组tmpMark来进行标记，同时使用delphi自带的SumInt（在Math单元）函数来计算标记的个数，有标记的tmpMark下标即为随机出的整数。\n对于[x, y)区间，可以在[0, m)的基础上进行平移来实现，n \u0026lt; y - x。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var l, i: Integer; tmpMark: array of Integer; begin l := y - x; SetLength(tmpMark, l); repeat Randomize; i := RandomRange(x, y); //[x,y)半开半闭区间 tmpMark[i - x] := 1; until SumInt(tmpMark) = n; for i := 0 to l - 1 do if tmpMark[i] = 1 then i + x; //i+x即为随机出的不重复的整数 end; ","permalink":"https://afrusrsc.github.io/posts/program/pascal/random_int/","summary":"从其它平台迁移而来\n生成指定范围内的随机数，有相应的随机函数（如RandomRange(x, y)可生成x \u0026lt;= d \u0026lt; y的随机整数），或者在基本的随机函数上稍加修改也可生成；生成 n 个随机数，只需调用 n 次随机函数即可；生成 n 个不重复的随机数，就会有一点点小麻烦。\n常规思路 一般来说，要生成n个不重复的随机数，只需判断每次生成的随机数有没有和这前生成的随机数重复即可，若重复即抛弃，不重复则记录。\n但是，这样要进行很多额外的判断，而且当生成的量变大时，这样的判断次数也几乎是呈指数级的增加（具体复杂度没有进行详细分析）。\n另一种思路 如果每生成一个随机整数，就在一个整数序列上对应的位置做一个标记，那么只需要判断标记的个数有没有达到n即可，然后把有标记的整数取出就是 n 个不重复的随机整数。（其实该思路是借鉴了某个排序算法的思路，具体算法名称不记得了）\n首先来考虑生成 n 个[0, m)的不重复的随机数方法，n \u0026lt; m。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var i: Integer; tmpMark: array of Integer; begin SetLength(tmpMark, m); repeat Randomize; i := RandomRange(0, m); //[0,m)半开半闭区间 tmpMark[i] := 1; until SumInt(tmpMark) = n; for i := 0 to m - 1 do if tmpMark[i] = 1 then i; //i即为随机出的不重复的整数 end; 本例中借助长度为m的数组tmpMark来进行标记，同时使用delphi自带的SumInt（在Math单元）函数来计算标记的个数，有标记的tmpMark下标即为随机出的整数。","title":"生成指定范围和个数的不重复的随机整数"},{"content":" 从其它平台迁移而来\n在Delphi未加入FireDAC之前，似乎是没有内存表控件的（也许有，可能我不知道吧），但是可以用TClientDataSet控件来做内存表使用，即使有了FireDAC可以使用TFDMemTable，我还是觉得TClientDataSet更好用一些。\n做内存表使用 创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 with ClientDataSet do begin Close; //定义字段 with FieldDefs do begin Clear; Add(\u0026#39;Field1\u0026#39;, ftInteger, 0, False); Add(\u0026#39;Field2\u0026#39;, ftString, 0, False); ...... end; //创建结构 CreateDataSet; Open; end; 排序 在定义字段后，创建结构前，也可以指定排序字段。\n1 IndexFieldNames := \u0026#39;Field1\u0026#39;; 做缓存使用 需要结合TDataSetProvider来使用。以下示例以使用ADO组件为例。\n拉取数据 方法1 TDBGrid-\u0026gt;TDataSource-\u0026gt;TClientDataSet-\u0026gt;TDataSetProvider-\u0026gt;TADOQuery-\u0026gt;TADOConnection\n1 2 3 4 5 6 7 ClientDataSet.ProviderName := DataSetProvider.Name; //设计器里设置过就不需要了 with ClientDataSet do begin Close; CommandText:=\u0026#39;select * from T_Table\u0026#39;; Open; end; 方法2 TDBGrid-\u0026gt;TDataSource\nTClientDataSet-\u0026gt;TDataSetProvider-\u0026gt;TADOQuery-\u0026gt;TADOConnection\n1 ClientDataSet.Data := DataSetProvider.Data; 提交数据 使用方法1时，可以直接使用下面的语句：\n1 2 3 ClientDataSet.ApplyUpdates(-1); //或 DataSetProvider.ApplyUpdates(ClientDataSet.Date, -1, Count); 按理说这样就可以了，而且不需要写SQL语句，但事实是Insert一般没问题，Update就很容易出错，所以提交还是自己老老实实写SQL语句比较保险。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 with ClientDataSet do begin First; while not Eof do begin case UpdateStatus of usModified: begin //更新处理 end; usInserted: begin //插入处理 end; usDeleted: begin //删除处理 end; end; Next; end; end; ","permalink":"https://afrusrsc.github.io/posts/program/pascal/delphi_clientdataset/","summary":"从其它平台迁移而来\n在Delphi未加入FireDAC之前，似乎是没有内存表控件的（也许有，可能我不知道吧），但是可以用TClientDataSet控件来做内存表使用，即使有了FireDAC可以使用TFDMemTable，我还是觉得TClientDataSet更好用一些。\n做内存表使用 创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 with ClientDataSet do begin Close; //定义字段 with FieldDefs do begin Clear; Add(\u0026#39;Field1\u0026#39;, ftInteger, 0, False); Add(\u0026#39;Field2\u0026#39;, ftString, 0, False); ...... end; //创建结构 CreateDataSet; Open; end; 排序 在定义字段后，创建结构前，也可以指定排序字段。\n1 IndexFieldNames := \u0026#39;Field1\u0026#39;; 做缓存使用 需要结合TDataSetProvider来使用。以下示例以使用ADO组件为例。\n拉取数据 方法1 TDBGrid-\u0026gt;TDataSource-\u0026gt;TClientDataSet-\u0026gt;TDataSetProvider-\u0026gt;TADOQuery-\u0026gt;TADOConnection\n1 2 3 4 5 6 7 ClientDataSet.ProviderName := DataSetProvider.Name; //设计器里设置过就不需要了 with ClientDataSet do begin Close; CommandText:=\u0026#39;select * from T_Table\u0026#39;; Open; end; 方法2 TDBGrid-\u0026gt;TDataSource","title":"TClientDataSet的使用以及遇到的坑"},{"content":" 从其它平台迁移而来\n由于工作需要，项目中有使用到海康威视的产品，不可避免的就要使用海康的SDK进行二次开发。开发过程中磕磕绊绊的，踩了不少坑，这里做一个简单的记录，算是给健忘的自己提个醒吧。\nDelphi版本的接口 Gitee地址\n首先，自己一直使用Delphi进行开发，然而海康官方只提供了C/C++的接口和示例，无奈只能自己改写了。改写完的部分已经上传，希望能有人共同来完善。\n由于Delphi商业使用的限制，现已转到Lazarus，全面拥抱开源。\n坑 播放声音 预览时播放声音，回放时播放声音，甚至使用播放库播放已下载的视频时播放声音，这些对于前端摄像头自带麦克的场景肯定是刚需（另接麦克的情况暂未测试），然而按照官方SDK文档和示例代码写出的程序死活就是没有声音，这样的情况似乎不少人都遇到过，但是，好像并没有见谁把解决方法公开过。\n其实，这个问题特别简单，只需要把HCNetSDKCom目录下的OpenAL32.dll拷贝到PlayCtrl.dll所在的目录下就可以了。这下就明白了吧，没有声音的原因其实就是使用NET_DVR_OpenSound调了PlayCtrl.dll，而PlayCtrl.dll又调了OpenAL32.dll来播放声音，但是由于PlayCtrl.dll没有找到OpenAL32.dll所以没有声音，而且这个有问题的返回值也并没有一层层的返回给NET_DVR_OpenSound函数，结果就是函数返回调用成功了，但就是死活没声音。\nPlayCtrl.dll不是PlayCtrl.dll 使用海康SDK进行二次开发的，一般也会使用到海康的播放库，但是有一个问题是需要注意的，那就是SDK里的PlayCtrl.dll并不是播放库里的PlayCtrl.dll。虽然它们长得一样，名字也一样，但它们的本质却是完全不一样的，是不能互相替代的！有兴趣的朋友可以使用eXeScope详细查看。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/sdk_hcnetsdk/","summary":"从其它平台迁移而来\n由于工作需要，项目中有使用到海康威视的产品，不可避免的就要使用海康的SDK进行二次开发。开发过程中磕磕绊绊的，踩了不少坑，这里做一个简单的记录，算是给健忘的自己提个醒吧。\nDelphi版本的接口 Gitee地址\n首先，自己一直使用Delphi进行开发，然而海康官方只提供了C/C++的接口和示例，无奈只能自己改写了。改写完的部分已经上传，希望能有人共同来完善。\n由于Delphi商业使用的限制，现已转到Lazarus，全面拥抱开源。\n坑 播放声音 预览时播放声音，回放时播放声音，甚至使用播放库播放已下载的视频时播放声音，这些对于前端摄像头自带麦克的场景肯定是刚需（另接麦克的情况暂未测试），然而按照官方SDK文档和示例代码写出的程序死活就是没有声音，这样的情况似乎不少人都遇到过，但是，好像并没有见谁把解决方法公开过。\n其实，这个问题特别简单，只需要把HCNetSDKCom目录下的OpenAL32.dll拷贝到PlayCtrl.dll所在的目录下就可以了。这下就明白了吧，没有声音的原因其实就是使用NET_DVR_OpenSound调了PlayCtrl.dll，而PlayCtrl.dll又调了OpenAL32.dll来播放声音，但是由于PlayCtrl.dll没有找到OpenAL32.dll所以没有声音，而且这个有问题的返回值也并没有一层层的返回给NET_DVR_OpenSound函数，结果就是函数返回调用成功了，但就是死活没声音。\nPlayCtrl.dll不是PlayCtrl.dll 使用海康SDK进行二次开发的，一般也会使用到海康的播放库，但是有一个问题是需要注意的，那就是SDK里的PlayCtrl.dll并不是播放库里的PlayCtrl.dll。虽然它们长得一样，名字也一样，但它们的本质却是完全不一样的，是不能互相替代的！有兴趣的朋友可以使用eXeScope详细查看。","title":"使用海康威视SDK的那些坑"},{"content":" 从其它平台迁移而来\n背景 自定义一个图形控件（继承自TGraphicControl类），需要在不同区域显示不同字体的内容，此时会需要在设计器中加入多个字体，方法是在控件的published区增加对应的字体属性即可（使用Ctrl+Shift+C可快速生成），如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 TMyGraphicControl = class(GraphicControl) private FText1Font: TFont; FText2Font: TFont; procedure SetText1Font(const Value: TFont); procedure SetText2Font(const Value: TFont); protected procedure Paint; override; public { public declarations } published property Text1Font:TFont read FText1Font write SetText1Font; property Text2Font:TFont read FText2Font write SetText2Font; end; 这样就可以在设计器里像使用原生控件一样使用自己的控件了。\n问题 但是，如果在设计期选择了弹出字体对话框进行设置字体，IDE就会报错（大意是读或写某个地址异常），而在运行期则正常！\n原因 对比查看Delphi自带的控件源码，终于找到了原因。\n1 2 3 4 5 6 7 8 9 10 //Delphi TControl类设置字体属性的方法 procedure TControl.SetFont(Value: TFont); begin FFont.Assign(Value); end; //自己设置字体属性的方法 procedure TMyGraphicControl.SetText1Font(const Value: TFont); begin FText1Font := Value; end; 由此，真相大白！\nTFont是类，其实例使用:=赋值时，实例上是把实例的指针指向了值的来源；而使用Assign方法，则是把各字段值复制了一份存放在实例的字段中。在运行期，对字体赋值，值的来源在上下文环境中是确定且存在的；在设计期通过设计器直接对字体各子项赋值，实际上是在逐一对其字段赋值；而在设计期通过字体对话框进行赋值，实际是产生了一条Windows消息，消息传递完成之后内容就会销毁，所以使用:=赋值就会产生地址读写的异常。\n总结 对类的实例进行赋值时，一定要想清楚最终想要的效果是什么，由此来确定是使用:=还是Assign方法。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/delphi_custom_graphic_control/","summary":"从其它平台迁移而来\n背景 自定义一个图形控件（继承自TGraphicControl类），需要在不同区域显示不同字体的内容，此时会需要在设计器中加入多个字体，方法是在控件的published区增加对应的字体属性即可（使用Ctrl+Shift+C可快速生成），如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 TMyGraphicControl = class(GraphicControl) private FText1Font: TFont; FText2Font: TFont; procedure SetText1Font(const Value: TFont); procedure SetText2Font(const Value: TFont); protected procedure Paint; override; public { public declarations } published property Text1Font:TFont read FText1Font write SetText1Font; property Text2Font:TFont read FText2Font write SetText2Font; end; 这样就可以在设计器里像使用原生控件一样使用自己的控件了。\n问题 但是，如果在设计期选择了弹出字体对话框进行设置字体，IDE就会报错（大意是读或写某个地址异常），而在运行期则正常！\n原因 对比查看Delphi自带的控件源码，终于找到了原因。\n1 2 3 4 5 6 7 8 9 10 //Delphi TControl类设置字体属性的方法 procedure TControl.","title":"Delphi自定义图形控件的自定义字体属性在设计期报错的解决办法"},{"content":" 从其它平台迁移而来\nConditional VER Product Product Version Package Version VER330 Delphi / C++Builder XE10.3 Rio 26 260 VER320 Delphi / C++Builder XE10.2 Tokyo 25 250 VER310 Delphi / C++Builder XE10.1 Berlin 24 240 VER300 Delphi / C++Builder XE10 Seattle 23 230 VER290 Delphi / C++Builder XE8 22 220 VER280 Delphi / C++Builder XE7 21 210 VER270 Delphi / C++Builder XE6 20 200 VER260 Delphi / C++Builder XE5 19 190 VER250 Delphi / C++Builder XE4 18 180 VER240 Delphi / C++Builder XE3 17 170 VER230 Delphi / C++Builder XE2 16 160 VER220 Delphi / C++Builder XE 15 150 VER210 Delphi / C++Builder 2010 14 140 VER200 Delphi / C++Builder 2009 12 120 VER190 Delphi 2007 for .Net 11 110 VER180 or VER185 Delphi / C++Builder 2007 for Win32 11 110 VER180 Delphi / C++Builder 2006 (Win32 / .Net) 10 100 VER170 Delphi 2005 (Win32 / .Net) 9 90 VER160 Delphi 8 for .Net 8 80 VER150 Delphi 7 (and 7.1) 7 70 VER140 Delphi / C++Builder 6 6 60 VER130 Delphi / C++Builder 5 5 NA VER125 C++Builder 4 4 NA VER120 Delphi 4 4 NA VER110 C++Builder 3 3 NA VER100 Delphi 3 3 NA VER93 C++Builder 1 NA VER90 Delphi 2 2 NA VER80 Delphi 1 1 NA VER70 Borland Pascal 7.0 NA NA VER60 Turbo Pascal 6.0 NA NA VER55 Turbo Pascal 5.5 NA NA VER50 Turbo Pascal 5.0 NA NA VER40 Turbo Pascal 4.0 NA NA VER30 Turbo Pascal 3 NA NA VER20 Turbo Pascal 2 NA NA VER10 Turbo Pascal 1 NA NA ","permalink":"https://afrusrsc.github.io/posts/program/pascal/delphi_version/","summary":"从其它平台迁移而来\nConditional VER Product Product Version Package Version VER330 Delphi / C++Builder XE10.3 Rio 26 260 VER320 Delphi / C++Builder XE10.2 Tokyo 25 250 VER310 Delphi / C++Builder XE10.1 Berlin 24 240 VER300 Delphi / C++Builder XE10 Seattle 23 230 VER290 Delphi / C++Builder XE8 22 220 VER280 Delphi / C++Builder XE7 21 210 VER270 Delphi / C++Builder XE6 20 200 VER260 Delphi / C++Builder XE5 19 190 VER250 Delphi / C++Builder XE4 18 180 VER240 Delphi / C++Builder XE3 17 170 VER230 Delphi / C++Builder XE2 16 160 VER220 Delphi / C++Builder XE 15 150 VER210 Delphi / C++Builder 2010 14 140 VER200 Delphi / C++Builder 2009 12 120 VER190 Delphi 2007 for .","title":"Delphi版本号对照表"},{"content":" 从其它平台迁移而来\n前言 线程、进程的概念实际上已经纠结N久了，不过好在多少有些了解了，但总感觉还不是那么通透。\n碰巧晚饭时与室友争论了一个问题，与线程的问题很类同，为了能通俗易懂的给室友讲明白，着实消耗了不少脑细胞。所幸最终他表示明白了（至于是真是假便不清楚了，不过至少我自己感觉通透了许多）。\n鉴于抱着一颗开源共享的心，便稍加整理，拿来浪一下啦！\nCPU 其实，CPU是个很笨的家伙，笨到只会做最简单的事，而且一次还只能做一件最简单的事，而它能做的所有的事掰着指头数来数去也就那么几件。多了、复杂了，抱歉，不会！\nCPU仅会做的那几件事呢，就叫做CPU指令。\n虽然CPU这家伙很笨，但还是有优点的，而且这优点还很让人喜欢。什么优点呢？快！准！\n时间片 虽然CPU只会那么几个指令，但是已经够了，因为那些复杂的事都可以用这些指令进行排列组合来完成。所以啊，CPU一点儿也不怕麻烦。\n由于CPU干活又快又准，所以很多事都可以让他来做。但是CPU这小子实在是太傻愣傻愣了，为了防止这傻小子闷着头只顾做手头上的事，把其它事都抛到了脑后，就有个头脑还算灵光的家伙跑来指挥CPU，这个家伙就是操作系统（更准确的说是分时操作系统），也叫OS。\nOS规定CPU做一件事只能用一小段时间（这一小段时间就叫时间片），而且时间到了必须放下手头的事，去做下一件事，不管手头上的事有没有做完。事实上OS把每一件事的进度都记录了下来，下次轮到这件事时就让CPU接着原来的进度继续干下去。\n由于CPU干活实在是太快太快了，所以感觉就像同时在做所有安排给他的事。\n进程\u0026amp;线程 不管是进程还是线程，其实都是任务。任务也分大小的，一个大任务可以包含若干小任务，而且一个大任务至少要有一个小任务。一个大任务就是一个进程，一个小任务就是一个线程。\n把这些任务交给OS，OS就根据情况做规划，给每个任务分配合理的时间片，然后安排CPU来完成。\n单线程\u0026amp;多线程 一个大任务只有一个小任务，那这个大任务就叫做单线程，否则就叫多线程。\n举个栗子：\n小明在唱歌，而且在唱歌是其它的事都不做。这就是单线程。\n小明一边唱歌，一边跳舞。这就是多线程。\n小明一边唱歌，一边吃饭。这也是多线程，只不过这两个小任务都用到了嘴巴，所以执行起来就会麻烦很多，解决麻烦的办法就是线程同步。\n多进程 直接举栗子：\n小明自己放风筝。这就是单进程。\n小明和小红都在放自己的风筝。这是一种多进程，只不过两个进程是独立的。\n小明和小红一起放大蜈蚣风筝。这是另一种多进程，进程之间需要配合，也存在类似多线程的麻烦。这方面的问题没有详细了解过，就不多扯了。\n多线程\u0026amp;多进程 再次举栗子：\n小明一边唱歌，一边跳舞。这是多线程，用的都是小明的身体（资源）。\n小明唱歌，小红跳舞。这是多进程，各自用各自的身体（资源）。\n小明和小红合唱。这也是多进程，各自用各自的身体（资源）。\n多核 单核、多核是针对CPU来说的。\n继续举栗子说明：\n普通人。单核。\n哪吒。多核。\n如有不对之处，还望大侠指正！\n","permalink":"https://afrusrsc.github.io/posts/program/misc/processes_threads_kernels/","summary":"从其它平台迁移而来\n前言 线程、进程的概念实际上已经纠结N久了，不过好在多少有些了解了，但总感觉还不是那么通透。\n碰巧晚饭时与室友争论了一个问题，与线程的问题很类同，为了能通俗易懂的给室友讲明白，着实消耗了不少脑细胞。所幸最终他表示明白了（至于是真是假便不清楚了，不过至少我自己感觉通透了许多）。\n鉴于抱着一颗开源共享的心，便稍加整理，拿来浪一下啦！\nCPU 其实，CPU是个很笨的家伙，笨到只会做最简单的事，而且一次还只能做一件最简单的事，而它能做的所有的事掰着指头数来数去也就那么几件。多了、复杂了，抱歉，不会！\nCPU仅会做的那几件事呢，就叫做CPU指令。\n虽然CPU这家伙很笨，但还是有优点的，而且这优点还很让人喜欢。什么优点呢？快！准！\n时间片 虽然CPU只会那么几个指令，但是已经够了，因为那些复杂的事都可以用这些指令进行排列组合来完成。所以啊，CPU一点儿也不怕麻烦。\n由于CPU干活又快又准，所以很多事都可以让他来做。但是CPU这小子实在是太傻愣傻愣了，为了防止这傻小子闷着头只顾做手头上的事，把其它事都抛到了脑后，就有个头脑还算灵光的家伙跑来指挥CPU，这个家伙就是操作系统（更准确的说是分时操作系统），也叫OS。\nOS规定CPU做一件事只能用一小段时间（这一小段时间就叫时间片），而且时间到了必须放下手头的事，去做下一件事，不管手头上的事有没有做完。事实上OS把每一件事的进度都记录了下来，下次轮到这件事时就让CPU接着原来的进度继续干下去。\n由于CPU干活实在是太快太快了，所以感觉就像同时在做所有安排给他的事。\n进程\u0026amp;线程 不管是进程还是线程，其实都是任务。任务也分大小的，一个大任务可以包含若干小任务，而且一个大任务至少要有一个小任务。一个大任务就是一个进程，一个小任务就是一个线程。\n把这些任务交给OS，OS就根据情况做规划，给每个任务分配合理的时间片，然后安排CPU来完成。\n单线程\u0026amp;多线程 一个大任务只有一个小任务，那这个大任务就叫做单线程，否则就叫多线程。\n举个栗子：\n小明在唱歌，而且在唱歌是其它的事都不做。这就是单线程。\n小明一边唱歌，一边跳舞。这就是多线程。\n小明一边唱歌，一边吃饭。这也是多线程，只不过这两个小任务都用到了嘴巴，所以执行起来就会麻烦很多，解决麻烦的办法就是线程同步。\n多进程 直接举栗子：\n小明自己放风筝。这就是单进程。\n小明和小红都在放自己的风筝。这是一种多进程，只不过两个进程是独立的。\n小明和小红一起放大蜈蚣风筝。这是另一种多进程，进程之间需要配合，也存在类似多线程的麻烦。这方面的问题没有详细了解过，就不多扯了。\n多线程\u0026amp;多进程 再次举栗子：\n小明一边唱歌，一边跳舞。这是多线程，用的都是小明的身体（资源）。\n小明唱歌，小红跳舞。这是多进程，各自用各自的身体（资源）。\n小明和小红合唱。这也是多进程，各自用各自的身体（资源）。\n多核 单核、多核是针对CPU来说的。\n继续举栗子说明：\n普通人。单核。\n哪吒。多核。\n如有不对之处，还望大侠指正！","title":"多线程、多进程、多核"},{"content":" 从其它平台迁移而来\n有时候，我们会下载到或者从邮箱接收到一些莫名其妙的文件——只有名字，没有后缀名（文件扩展名），排除不安全因素后，确定这就是我们想要的文件，但是不知道文件格式或者不知道用什么软件来打开查看，对于大多数人来说这可是个比较头疼的问题。\n但是，如果掌握一些基础知识的话，这样的问题其实是很好解决的！\n知识点一： 文件后缀名（扩展名）和文件格式没有半毛钱关系！\n文件格式实际上是由文件开头的若干字节来描述的，这些文件描述称为文件头（注意，不是c/c++里的.h头文件）。\n那么，后缀名是用来做什么的呢？后缀名仅仅是为了方便从文件名中知道文件是什么格式，一方面给用户（你，我，他）看，另一方面给操作系统看，由操作系统判断使用哪个阅读器、浏览器、工具等软件打开，而这些软件对文件的解析就是根据文件头的描述来进行的。\n知识点二： 本质上所有的文件都是二进制文件！\n文本、源码（其实也是文本）、word、excel、ppt、pdf、dll、exe、图片、压缩包……都是二进制文件，因为现代计算机系统只认识0和1。不信的话可以用十六进制工具打开来查看。\n好了，有了这两个基础知识，我们就可以进行继续了。上面提到了十六进制工具，这里我们要使用的神器也正是它！\n这是一张png图片，用十六进制打开后是这样的，可以明显看到有PNG字样。\n这是一个pdf文件，也可以明显看到PDF字样。\n就不再贴图了，套路就是这么个套路，下面就直接上整理好的常用的对应表了！\n文件格式 文件头 bmp图片 42 4D (BM) png图片 89 50 4E 47 (‰PNG) jpg图片 FF D8 pdf文档 25 50 44 46 (%PDF) zip压缩包 50 4B (PK) rar压缩包 52 61 72 (Rar) 7z压缩包 37 7A (7z) docx、xlsx、pptx 50 4B (PK) dll或exe 4D 5A (MZ) 可看到，Microsoft Office 2007 及以上版本的 docx、xlsx、pptx 与 zip压缩包的文件头是一样的，是不是搞错了？没错，Microsoft Office 2007 及以上版本的 docx、xlsx、pptx 实际上就是一个 zip压缩包，不信的小伙伴儿们可以把后缀名改为zip用解压工具打开看看真面目。\n就到这里吧，更多文件格式就烦请亲自动手尝试了，说不定会有什么惊奇的发现呢！\n","permalink":"https://afrusrsc.github.io/posts/program/misc/file_type/","summary":"从其它平台迁移而来\n有时候，我们会下载到或者从邮箱接收到一些莫名其妙的文件——只有名字，没有后缀名（文件扩展名），排除不安全因素后，确定这就是我们想要的文件，但是不知道文件格式或者不知道用什么软件来打开查看，对于大多数人来说这可是个比较头疼的问题。\n但是，如果掌握一些基础知识的话，这样的问题其实是很好解决的！\n知识点一： 文件后缀名（扩展名）和文件格式没有半毛钱关系！\n文件格式实际上是由文件开头的若干字节来描述的，这些文件描述称为文件头（注意，不是c/c++里的.h头文件）。\n那么，后缀名是用来做什么的呢？后缀名仅仅是为了方便从文件名中知道文件是什么格式，一方面给用户（你，我，他）看，另一方面给操作系统看，由操作系统判断使用哪个阅读器、浏览器、工具等软件打开，而这些软件对文件的解析就是根据文件头的描述来进行的。\n知识点二： 本质上所有的文件都是二进制文件！\n文本、源码（其实也是文本）、word、excel、ppt、pdf、dll、exe、图片、压缩包……都是二进制文件，因为现代计算机系统只认识0和1。不信的话可以用十六进制工具打开来查看。\n好了，有了这两个基础知识，我们就可以进行继续了。上面提到了十六进制工具，这里我们要使用的神器也正是它！\n这是一张png图片，用十六进制打开后是这样的，可以明显看到有PNG字样。\n这是一个pdf文件，也可以明显看到PDF字样。\n就不再贴图了，套路就是这么个套路，下面就直接上整理好的常用的对应表了！\n文件格式 文件头 bmp图片 42 4D (BM) png图片 89 50 4E 47 (‰PNG) jpg图片 FF D8 pdf文档 25 50 44 46 (%PDF) zip压缩包 50 4B (PK) rar压缩包 52 61 72 (Rar) 7z压缩包 37 7A (7z) docx、xlsx、pptx 50 4B (PK) dll或exe 4D 5A (MZ) 可看到，Microsoft Office 2007 及以上版本的 docx、xlsx、pptx 与 zip压缩包的文件头是一样的，是不是搞错了？没错，Microsoft Office 2007 及以上版本的 docx、xlsx、pptx 实际上就是一个 zip压缩包，不信的小伙伴儿们可以把后缀名改为zip用解压工具打开看看真面目。","title":"简单确定文件格式"},{"content":" 从其它平台迁移而来\n这几天被Prepare这个东西搞死了，虽然用它解决了目前的问题，但是完全不知道为什么，如有大侠知道还望指教，不胜感激！\n首先，说下开发环境：\nwin10 x64(1709 [10.0.16299.125])+Delphi XE7 up1(自带FireDAC)+Firebird 3.0.2.32703_0(数据库字符集使用UTF8)\n问题一：中文模糊查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var CompanyType: Integer FDQuery1.Close; FDQuery1.SQL.Text := \u0026#39;SELECT * FROM companyinfo \u0026#39; + \u0026#39;WHERE (tag = 0) AND (companytype = :companytype) AND \u0026#39; + \u0026#39;((companyname LIKE :Text) OR (pym LIKE :Text))\u0026#39; + \u0026#39; ORDER BY TIMES DESC\u0026#39;; //FDQuery1.Prepare; //写在这里会报错，提示如下，大致意思是： //数据库 companytype 字段是SmallInt类型，却赋了一个Integer类型的值 {--------------------------- [FireDAC][Phys][FB]-338. Param [COMPANYTYPE] type changed from [ftSmallInt] to [ftInteger]. Query must be reprepared. Possible reason: an assignment to a TFDParam.AsXXX property implicitly changed the parameter data type. Hint: use the TFDParam.Value or appropriate TFDParam.AsXXX property. --------------------------- } FDQuery1.ParamByName(\u0026#39;companytype\u0026#39;).AsInteger := CompanyType; FDQuery1.Prepare; //必须！而且只能在这里！否则不支持中文模糊查询 FDQuery1.ParamByName(\u0026#39;Text\u0026#39;).AsString := \u0026#39;%\u0026#39; + btnedtKeyWord.Text + \u0026#39;%\u0026#39;; FDQuery1.Open(); 问题二：RecordCount 和 Eof 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //这是有问题的 FDQuery1.SQL.Text := \u0026#39;select TAG from truckinfo where (TAG in (0,1)) and (PLATENUM = :PlateNum)\u0026#39;; FDQuery1.Prepare; //必须！否则 RecordCount 始终为 0，而 Eof 始终为 True FDQuery1.ParamByName(\u0026#39;PlateNum\u0026#39;).AsString := PlateStr; FDQuery1.Open; if FDQuery1.RecordCount \u0026gt; 0 then //或者是 if not FDQuery1.Eof then begin ... end; //--------------------------------------------------------------------- //但是在其它地方都是正常的 //例1 FDQuery1.SQL.Text := \u0026#39;SELECT * FROM clientinfo WHERE (tag = 0) AND (id = :id)\u0026#39;; FDQuery1.ParamByName(\u0026#39;id\u0026#39;).AsInteger := AID; FDQuery1.Open(); if FDQuery1.Eof then begin ... end; //例2 FDQuery1.SQL.Text := \u0026#39;SELECT * FROM employee WHERE tag \u0026lt;= 0 ORDER BY id\u0026#39;; FDQuery1.Open(); while not FDQuery1.Eof do begin ... end; 虽然两个问题目前都解决了，而且可以很好的正常运行，但是完全不知道为什么，尤其是问题二。\n最近又遇到了另一种类似的问题，不过规律好像也发现了，就是：参数有中文字段的话，必须使用Prepare才能正常查询到结果，而且Prepare必须在中文字段参数之前。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/firedac_fdquery_firebird/","summary":"从其它平台迁移而来\n这几天被Prepare这个东西搞死了，虽然用它解决了目前的问题，但是完全不知道为什么，如有大侠知道还望指教，不胜感激！\n首先，说下开发环境：\nwin10 x64(1709 [10.0.16299.125])+Delphi XE7 up1(自带FireDAC)+Firebird 3.0.2.32703_0(数据库字符集使用UTF8)\n问题一：中文模糊查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var CompanyType: Integer FDQuery1.Close; FDQuery1.SQL.Text := \u0026#39;SELECT * FROM companyinfo \u0026#39; + \u0026#39;WHERE (tag = 0) AND (companytype = :companytype) AND \u0026#39; + \u0026#39;((companyname LIKE :Text) OR (pym LIKE :Text))\u0026#39; + \u0026#39; ORDER BY TIMES DESC\u0026#39;; //FDQuery1.Prepare; //写在这里会报错，提示如下，大致意思是： //数据库 companytype 字段是SmallInt类型，却赋了一个Integer类型的值 {--------------------------- [FireDAC][Phys][FB]-338.","title":"使用FireDAC的TFDQuery查询Firebird遇到的坑"},{"content":" 从其它平台迁移而来\n在软件开发过程中，尤其是涉及到数据库的项目，通常都会遇到字符编码的问题。\n其中，中文字符集编码常用的有GB2312和GBK，以及万国码UTF8，另外还有GB18030。\nASCII码每个字符占一个字节；GB2312是GBK的子集，两个字符集都是每个字符占两个字节；GB18030是GBK的取代版本，每个字符占一个、两个或四个字节；UFT8是万国码，每个字符占一个、两个或三个字节。\n下图是GBK字符编码表。\n图是265*256的矩阵，表示两个字节可以表示的所有字符。水平方向表示高字节，从左至右为0000~FF00；垂直方向表示低字节，从上到下为0000~00FF。\n左侧0区：0000~007F，ASCII码区。\n右下色块区：8140~FEFE（需剔除a区即817F~FE7F），GBK编码区。\n具体说明 GBK编码分三部分。\n一、汉字区 2区：B0A1~F7FE，GBK/2，GB2312汉字区，GB2312汉字6763个。\nGB13000.1扩充汉字区\n3区：8140~A0FE，GBK/3，GB13000.1中的CJK汉字6080个。\n4区：AA40~FEA0，GBK/4，CJK汉字和增补的汉字8160个。\n二、图形符号区 1区：A1A1~A9FE，GBK/1，GB2312非汉字符号区。除GB2312的符号外，还有10个小写罗马数字和GB12345增补的符号。计符号717个。\n5区：A840~A9A0，GBK/5，GB13000.1扩充非汉字区。包含BIG-5非汉字符号、结构符和汉字〇。计符号166个。\n三、用户自定义区 A区：AAA1~AFFE，码位564个。\nB区：F8A1~FEFE，码位658个。\nC区：A140~A7A0，码位672个。\n","permalink":"https://afrusrsc.github.io/posts/program/misc/gbk/","summary":"从其它平台迁移而来\n在软件开发过程中，尤其是涉及到数据库的项目，通常都会遇到字符编码的问题。\n其中，中文字符集编码常用的有GB2312和GBK，以及万国码UTF8，另外还有GB18030。\nASCII码每个字符占一个字节；GB2312是GBK的子集，两个字符集都是每个字符占两个字节；GB18030是GBK的取代版本，每个字符占一个、两个或四个字节；UFT8是万国码，每个字符占一个、两个或三个字节。\n下图是GBK字符编码表。\n图是265*256的矩阵，表示两个字节可以表示的所有字符。水平方向表示高字节，从左至右为0000~FF00；垂直方向表示低字节，从上到下为0000~00FF。\n左侧0区：0000~007F，ASCII码区。\n右下色块区：8140~FEFE（需剔除a区即817F~FE7F），GBK编码区。\n具体说明 GBK编码分三部分。\n一、汉字区 2区：B0A1~F7FE，GBK/2，GB2312汉字区，GB2312汉字6763个。\nGB13000.1扩充汉字区\n3区：8140~A0FE，GBK/3，GB13000.1中的CJK汉字6080个。\n4区：AA40~FEA0，GBK/4，CJK汉字和增补的汉字8160个。\n二、图形符号区 1区：A1A1~A9FE，GBK/1，GB2312非汉字符号区。除GB2312的符号外，还有10个小写罗马数字和GB12345增补的符号。计符号717个。\n5区：A840~A9A0，GBK/5，GB13000.1扩充非汉字区。包含BIG-5非汉字符号、结构符和汉字〇。计符号166个。\n三、用户自定义区 A区：AAA1~AFFE，码位564个。\nB区：F8A1~FEFE，码位658个。\nC区：A140~A7A0，码位672个。","title":"GBK编码"},{"content":" 从其它平台迁移而来\n汉化 在DevExpress选项卡找到TcxLocalizer控件放到窗体上，为了通用，我是放到DataModule窗体上。 准备好汉化的资源文件或配置文件（我使用的是后者），在DataModule的Create事件里写上如下代码 1 2 3 4 5 6 7 with cxLocalizer1 do begin StorageType := lstIni; LoadFromFile(IniPath + \u0026#39;DevChs.ini\u0026#39;); locale := 2052; Active := True; end; 在有cxGrid或其实Dev控件的单元引用DataModule单元。 更改视觉样式 在DevExpress选项卡找到TcxLookAndFeelController控件放到DataModule窗体上。\n在有cxGrid或其它Dev控件的单元引用DataModule单元。\n在要更改视觉样式的代码段里设置TcxLookAndFeelController控件的Kind属性和NativeStyle属性。\n让cxGrid的数据以斑马线的方式显示，即奇偶行分别使用不同样式 在DevExpress选项卡找到TcxStyleRepository控件放到DataModule窗体上。\n双击cxStyleRepository控件，打开如下窗口，点Add添加两个样式，并命名。\n分别在属性中设置不同的样式，颜色、字体、字号、字体颜色等。 在有cxGrid的单元中引用DataModule单元。\n选中cxGrid的cxGridDBTableView，展开Styles，分别关联ContentEven和ContentOdd。\n另外也可设置Header、Selection和Inactive。Header改变的是表头的样式，Selection改变的是当前选择行的样式，Inactive改变的是cxGrid失去焦点时当前选择行的样式。\n不显示分组框 设置cxGridDBTableView的OptionsView下的GroupByBox属性为False。\n显示合计等脚注 设置cxGridDBTableView的OptionsView下的Footer属性为True。\n点cxGrid的Customize...按钮，弹出对话框，选择Summary标签页，在Footer子标签页中点Add增加合计项目。\n选择增加的项目，在属性中设置关联的列、字段名等属性。 设置行号 增加一列，不关联数据库字段，设置好属性。\n在该列的OnGetDataText事件中写如下代码：\n1 AText := IntToStr(ARecordIndex + 1); 编辑完成前光标不能离开当前行 在cxGridDBTableView的OnCanFocusRecord事件中写入类似以下的代码： 1 AAllow := DbState in [dsBrowse]; 只读 设置cxGridDBTableView.OptionsData.Editing属性为False。\n选择整行 设置cxGridDBTableView.OptionsSelection.CellSelect属性为False。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/devexpress_cxgrid/","summary":"从其它平台迁移而来\n汉化 在DevExpress选项卡找到TcxLocalizer控件放到窗体上，为了通用，我是放到DataModule窗体上。 准备好汉化的资源文件或配置文件（我使用的是后者），在DataModule的Create事件里写上如下代码 1 2 3 4 5 6 7 with cxLocalizer1 do begin StorageType := lstIni; LoadFromFile(IniPath + \u0026#39;DevChs.ini\u0026#39;); locale := 2052; Active := True; end; 在有cxGrid或其实Dev控件的单元引用DataModule单元。 更改视觉样式 在DevExpress选项卡找到TcxLookAndFeelController控件放到DataModule窗体上。\n在有cxGrid或其它Dev控件的单元引用DataModule单元。\n在要更改视觉样式的代码段里设置TcxLookAndFeelController控件的Kind属性和NativeStyle属性。\n让cxGrid的数据以斑马线的方式显示，即奇偶行分别使用不同样式 在DevExpress选项卡找到TcxStyleRepository控件放到DataModule窗体上。\n双击cxStyleRepository控件，打开如下窗口，点Add添加两个样式，并命名。\n分别在属性中设置不同的样式，颜色、字体、字号、字体颜色等。 在有cxGrid的单元中引用DataModule单元。\n选中cxGrid的cxGridDBTableView，展开Styles，分别关联ContentEven和ContentOdd。\n另外也可设置Header、Selection和Inactive。Header改变的是表头的样式，Selection改变的是当前选择行的样式，Inactive改变的是cxGrid失去焦点时当前选择行的样式。\n不显示分组框 设置cxGridDBTableView的OptionsView下的GroupByBox属性为False。\n显示合计等脚注 设置cxGridDBTableView的OptionsView下的Footer属性为True。\n点cxGrid的Customize...按钮，弹出对话框，选择Summary标签页，在Footer子标签页中点Add增加合计项目。\n选择增加的项目，在属性中设置关联的列、字段名等属性。 设置行号 增加一列，不关联数据库字段，设置好属性。\n在该列的OnGetDataText事件中写如下代码：\n1 AText := IntToStr(ARecordIndex + 1); 编辑完成前光标不能离开当前行 在cxGridDBTableView的OnCanFocusRecord事件中写入类似以下的代码： 1 AAllow := DbState in [dsBrowse]; 只读 设置cxGridDBTableView.OptionsData.Editing属性为False。\n选择整行 设置cxGridDBTableView.OptionsSelection.CellSelect属性为False。","title":"cxGrid基本用法小记"},{"content":" 从其它平台迁移而来\n1.在FireDAC选项卡中找到TFDStoredProc控件，放到窗体上，并把Connection属性设置为准备好的数据库连接控件上。\n2.在需要执行存储过程的位置写入类似以下的代码：\n1 2 3 4 5 6 7 8 9 FDStoredProc1.StoredProcName := \u0026#39;SP_StoredProcName\u0026#39;; FDStoredProc1.Prepare; //必须，否则会报找不到参数的错误 FDStoredProc1.ParamByName(\u0026#39;I_ID\u0026#39;).AsInteger := id; //无返回值或返回值由输出参数传递时 FDStoredProc1.ExecProc; UserName := FDStoredProc1.ParamByName(\u0026#39;O_USERNAME\u0026#39;).AsString; //有返回值或数据集时 FDStoredProc1.Open(); UserName := FDStoredProc1.FindField(\u0026#39;O_USERNAME\u0026#39;).AsString; 3.以上为存储过程返回单个值或单条记录时的用法，存储过程返回多条记录（即数据表）的用法暂未研究。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/firedac_fdstoredproc/","summary":"从其它平台迁移而来\n1.在FireDAC选项卡中找到TFDStoredProc控件，放到窗体上，并把Connection属性设置为准备好的数据库连接控件上。\n2.在需要执行存储过程的位置写入类似以下的代码：\n1 2 3 4 5 6 7 8 9 FDStoredProc1.StoredProcName := \u0026#39;SP_StoredProcName\u0026#39;; FDStoredProc1.Prepare; //必须，否则会报找不到参数的错误 FDStoredProc1.ParamByName(\u0026#39;I_ID\u0026#39;).AsInteger := id; //无返回值或返回值由输出参数传递时 FDStoredProc1.ExecProc; UserName := FDStoredProc1.ParamByName(\u0026#39;O_USERNAME\u0026#39;).AsString; //有返回值或数据集时 FDStoredProc1.Open(); UserName := FDStoredProc1.FindField(\u0026#39;O_USERNAME\u0026#39;).AsString; 3.以上为存储过程返回单个值或单条记录时的用法，存储过程返回多条记录（即数据表）的用法暂未研究。","title":"FireDAC之TFDStoredProc"},{"content":" 从其它平台迁移而来\n1.在FireDAC选项卡中找到TFDQuery控件，放到窗体上，并把Connection属性设置为准备好的数据库连接控件上。\n2.在需要查询或执行SQL语句的位置写入类似以下的代码：\n1 2 3 4 5 6 7 8 //查询，有返回集 FDQuery1.SQL.Text := \u0026#39;SELECT * FROM DBTable WHERE id = :id\u0026#39;; FDQuery1.ParamByName(\u0026#39;id\u0026#39;).AsInteger := 1; FDQuery1.Open(); //执行SQL语句，无返回集 FDQuery1.SQL.Text := \u0026#39;DELETE FROM DBTable WHERE id = :id\u0026#39;; FDQuery1.ParamByName(\u0026#39;id\u0026#39;).AsInteger := 1; FDQuery1.ExecSQL; 3.若查询结果需要连接到数据集，则在DataAccess选项卡中找到TDataSource控件，放到窗体上，并把DataSet属性连接到TFDQuery控件。然后把数据感知控件（如cxGrid等）的DataSource属性连接到TDataSource控件。\n4.若只需要取出查询结果并进行后续处理，可使用如下代码取出结果：\n1 2 3 id := FDQuery1.FindField(\u0026#39;id\u0026#39;).AsInteger; DeptName := FDQuery1.FindField(\u0026#39;deptname\u0026#39;).AsString; Money := FDQuery1.FindField(\u0026#39;money\u0026#39;).AsFloat; ","permalink":"https://afrusrsc.github.io/posts/program/pascal/firedac_fdquery/","summary":" 从其它平台迁移而来\n1.在FireDAC选项卡中找到TFDQuery控件，放到窗体上，并把Connection属性设置为准备好的数据库连接控件上。\n2.在需要查询或执行SQL语句的位置写入类似以下的代码：\n1 2 3 4 5 6 7 8 //查询，有返回集 FDQuery1.SQL.Text := \u0026#39;SELECT * FROM DBTable WHERE id = :id\u0026#39;; FDQuery1.ParamByName(\u0026#39;id\u0026#39;).AsInteger := 1; FDQuery1.Open(); //执行SQL语句，无返回集 FDQuery1.SQL.Text := \u0026#39;DELETE FROM DBTable WHERE id = :id\u0026#39;; FDQuery1.ParamByName(\u0026#39;id\u0026#39;).AsInteger := 1; FDQuery1.ExecSQL; 3.若查询结果需要连接到数据集，则在DataAccess选项卡中找到TDataSource控件，放到窗体上，并把DataSet属性连接到TFDQuery控件。然后把数据感知控件（如cxGrid等）的DataSource属性连接到TDataSource控件。\n4.若只需要取出查询结果并进行后续处理，可使用如下代码取出结果：\n1 2 3 id := FDQuery1.FindField(\u0026#39;id\u0026#39;).AsInteger; DeptName := FDQuery1.FindField(\u0026#39;deptname\u0026#39;).AsString; Money := FDQuery1.FindField(\u0026#39;money\u0026#39;).AsFloat; ","title":"FirdDAC之TFDQuery使用"},{"content":" 从其它平台迁移而来\n建立DataModule\n在FireDAC选项卡中找到我们的主角TFDConnection控件，并放到DataModule窗体上，把LoginPrompt设为False，这样在连接时就不会弹出登陆对话框了。然后再找到TFDManager控件，也放到DataModule窗体上，并且把Active属性设为True，这样一来，在引用了本单元的其它单元中，就可以直接把FireDAC控件的Connection连接到本单元的TFDConnection了。\n在FireDAC Links选项卡中找到所需要连接的数据的驱动链接控件，放到DataModule窗体上。本例中使用的是FireBird数据库，因此就选择了TFDPhysFBDriverLink，其它数据库参照执行（本人接触的数据库不多，各数据库间的差异不敢妄言，但整体使用思路和方法应是不差的）。 在FireDAC UI选项卡中找到TFDGUIxWaitCursor控件，放到DataModule窗体上。该控件其实只是个光标，可修改ScreenCursor属性来改变光标。 至此，拖控件的工作基本上就做完了，下面该写代码了（虽然代码中有相当一部分工作可以直接在设计器中修改属性来达到，但建议用代码来实现，一方面便于DEBUG，另一方面也易于进行数据库的变更、迁移等）。\n在DataModule的Create事件中写入类似以下的代码（也可写在其它地主，但要保证必须在任何数据库操作代码前运行）： 1 2 3 4 5 6 7 8 9 10 11 12 FDPhysFBDriverLink1.VendorLib := DllPath + \u0026#39;fbclient.dll\u0026#39;; FDConnection1.Params.DriverID := \u0026#39;FB\u0026#39;; FDConnection1.Params.Database := HostName + \u0026#39;/\u0026#39; + DBPort + \u0026#39;:\u0026#39; + DBFilePathAndName; FDConnection1.Params.UserName := UserName; FDConnection1.Params.Password := Password; FDConnection1.Params.Add(\u0026#39;CharacterSet=utf8\u0026#39;); try FDConnection1.Open(); except on E:Exception do ShowMessage(E.Message); end; 注意：FDConnection1.Params.Add('CharacterSet=utf8');这句是设置客户端连接数据库是默认使用的字符集，一定要与所连接的数据库使用的默认字符集一致，否则将会发生很多奇怪的事情。而且该项无法在设计器的属性中进行设置！\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/firedac_fdconnection/","summary":"从其它平台迁移而来\n建立DataModule\n在FireDAC选项卡中找到我们的主角TFDConnection控件，并放到DataModule窗体上，把LoginPrompt设为False，这样在连接时就不会弹出登陆对话框了。然后再找到TFDManager控件，也放到DataModule窗体上，并且把Active属性设为True，这样一来，在引用了本单元的其它单元中，就可以直接把FireDAC控件的Connection连接到本单元的TFDConnection了。\n在FireDAC Links选项卡中找到所需要连接的数据的驱动链接控件，放到DataModule窗体上。本例中使用的是FireBird数据库，因此就选择了TFDPhysFBDriverLink，其它数据库参照执行（本人接触的数据库不多，各数据库间的差异不敢妄言，但整体使用思路和方法应是不差的）。 在FireDAC UI选项卡中找到TFDGUIxWaitCursor控件，放到DataModule窗体上。该控件其实只是个光标，可修改ScreenCursor属性来改变光标。 至此，拖控件的工作基本上就做完了，下面该写代码了（虽然代码中有相当一部分工作可以直接在设计器中修改属性来达到，但建议用代码来实现，一方面便于DEBUG，另一方面也易于进行数据库的变更、迁移等）。\n在DataModule的Create事件中写入类似以下的代码（也可写在其它地主，但要保证必须在任何数据库操作代码前运行）： 1 2 3 4 5 6 7 8 9 10 11 12 FDPhysFBDriverLink1.VendorLib := DllPath + \u0026#39;fbclient.dll\u0026#39;; FDConnection1.Params.DriverID := \u0026#39;FB\u0026#39;; FDConnection1.Params.Database := HostName + \u0026#39;/\u0026#39; + DBPort + \u0026#39;:\u0026#39; + DBFilePathAndName; FDConnection1.Params.UserName := UserName; FDConnection1.Params.Password := Password; FDConnection1.Params.Add(\u0026#39;CharacterSet=utf8\u0026#39;); try FDConnection1.Open(); except on E:Exception do ShowMessage(E.Message); end; 注意：FDConnection1.Params.Add('CharacterSet=utf8');这句是设置客户端连接数据库是默认使用的字符集，一定要与所连接的数据库使用的默认字符集一致，否则将会发生很多奇怪的事情。而且该项无法在设计器的属性中进行设置！","title":"FireDAC连接数据库"},{"content":" 从其它平台迁移而来\n探索 之前提到了Delphi的字符串，但并未展开说，这里就详细探讨下Delphi的字符串类型。\n废话不多说，直接上源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 program StringTest; {$APPTYPE CONSOLE} uses SysUtils; var s1, s2, s3: string; begin Writeln(\u0026#39;Now time : \u0026#39;,FormatDateTime(\u0026#39;HH:MM:SS.ZZZ\u0026#39;,Now())); Writeln(\u0026#39;--------------------------------\u0026#39;); Writeln(\u0026#39;s1 = \u0026#39;, s1); Writeln(\u0026#39;@s1 = \u0026#39;, Cardinal(@s1)); Writeln(\u0026#39;@s1[1] = \u0026#39;, Cardinal(@s1[1])); Write(\u0026#39;Input s1 : \u0026#39;); Readln(s1); Writeln(\u0026#39;s1 = \u0026#39;, s1); Writeln(\u0026#39;@s1 = \u0026#39;, Cardinal(@s1)); Writeln(\u0026#39;@s1[1] = \u0026#39;, Cardinal(@s1[1])); Writeln(\u0026#39;--------------------------------\u0026#39;); s2 := \u0026#39;Hello \u0026#39;; s3 := \u0026#39;Delphi \u0026#39;; Writeln(\u0026#39;s2 = \u0026#39;, s2); Writeln(\u0026#39;s3 = \u0026#39;, s3); Writeln(\u0026#39;@s2 = \u0026#39;, Cardinal(@s2)); Writeln(\u0026#39;@s3 = \u0026#39;, Cardinal(@s3)); Writeln(\u0026#39;@s2[1] = \u0026#39;, Cardinal(@s2[1])); Writeln(\u0026#39;@s3[1] = \u0026#39;, Cardinal(@s3[1])); Writeln(\u0026#39;--------------------------------\u0026#39;); s2 := s2 + s3; Writeln(\u0026#39;s2 := s2 + s3\u0026#39;); Writeln(\u0026#39;s2 = \u0026#39;, s2); Writeln(\u0026#39;s3 = \u0026#39;, s3); Writeln(\u0026#39;@s2 = \u0026#39;, Cardinal(@s2)); Writeln(\u0026#39;@s3 = \u0026#39;, Cardinal(@s3)); Writeln(\u0026#39;@s2[1] = \u0026#39;, Cardinal(@s2[1])); Writeln(\u0026#39;@s3[1] = \u0026#39;, Cardinal(@s3[1])); Writeln(\u0026#39;--------------------------------\u0026#39;); s3 := s2 + s3; Writeln(\u0026#39;s3 := s2 + s3\u0026#39;); Writeln(\u0026#39;s2 = \u0026#39;, s2); Writeln(\u0026#39;s3 = \u0026#39;, s3); Writeln(\u0026#39;@s2 = \u0026#39;, Cardinal(@s2)); Writeln(\u0026#39;@s3 = \u0026#39;, Cardinal(@s3)); Writeln(\u0026#39;@s2[1] = \u0026#39;, Cardinal(@s2[1])); Writeln(\u0026#39;@s3[1] = \u0026#39;, Cardinal(@s3[1])); Readln; end. 运行结果如下：\n从运行结果可以看出：\n字符串类型实际是分两部分进行保存的，一部分是字符串变量名（本质是指针），另一部分是字符串内容（本质是字符串数组，且第0个元素存放的是字符串的长度）。\n字符串在未初始化/未赋值时，字符串内容的地址为0，即系统未对其进行分配内存；但字符串变量名的地址是存在的，可以理解为字符串变量已经完成了占位工作，方便后续工作的展开。\n字符串在赋值、拼接时，变量名地址不变，内容地址改变，说明后来的字符串内容是在另外一个位置重新生成的新字符串，和原来的字符串没有任何关系。\n字符串变量名的地址远小于字符内容的地址，说明两者是在完全不同的内存区域。事实上，字符串变量名是在栈区，字符串内容是在堆区。\n过一段时间之后再次运行，结果如下：\n对比两次运行，可以看出：\n字符串变量名地址未发生变化，字符串内容地址却完全不同，进一步说明变量名是分配在栈区，内容是分配在堆区。 至于是在程序的栈区和堆区还是在内存的栈区和堆区，暂不可知。因此又先后把该测试程序打开两次，把该测试程序复制一个副本几乎同时打开，运行结果如下图：\n由此可以看出：\n变量名确实是分配在栈区，而内容是分配在堆区。\n这里的栈区和堆区，极有可能是内存的栈区和堆区，但也不排除是Delphi专门做过优化的原因。\n结论 字符串变量名分配在栈区，内容分配在堆区。\n字符串未初始化/未赋值时，Delphi只为变量名分配了内存空间，为字符串赋值时才为内容分配内存空间。\n字符串在进行拼接时，拼接后的字符串是在另一段完全不同的内存空间中，而且是在堆区。由于堆栈性质的不同，堆的执行效率不如栈，因此，当进行大量的字符串拼接时，这将会成为性能瓶颈之一。\n","permalink":"https://afrusrsc.github.io/posts/program/pascal/delphi_string01/","summary":"从其它平台迁移而来\n探索 之前提到了Delphi的字符串，但并未展开说，这里就详细探讨下Delphi的字符串类型。\n废话不多说，直接上源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 program StringTest; {$APPTYPE CONSOLE} uses SysUtils; var s1, s2, s3: string; begin Writeln(\u0026#39;Now time : \u0026#39;,FormatDateTime(\u0026#39;HH:MM:SS.","title":"深入Delphi的字符串类型"},{"content":" 从其它平台迁移而来\n之前一直使用的是Delphi 7，现在准备转向Delphi XE7，据说数据类型上有一些微小的调整，便想亲自验证一下，也顺便加深一下自己对Delphi数据类型的认识，毕竟之前仅仅是在用而从未考虑过类型在内存中的形态。\n验证方法很简单，就是在控制台用Sizeof()把相应数据类型的字节数显示出来。源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 program TypeSize; {$APPTYPE CONSOLE} uses SysUtils; type Emnu = (one, two, three, four); Range1 = $0..$FF; Range2 = $0..$FFFF; Range3 = $0..$FFFFFFFF; arr1 = array of Byte; arr2 = array[0..9] of Byte; arr3 = array[0..9] of Integer; rcd1 = record end; rcd2 = record b: Byte; end; rcd3 = record i: Integer; end; rcd4 = record i: Integer; j: Integer; end; rcd5 = record b: Byte; i: Integer; end; rcd6 = record r: Real; end; rcd7 = record r: Real; i: Integer; end; obj1 = object end; obj2 = object c: Char; end; obj3 = object i: Integer; o: obj2; end; begin Writeln(\u0026#39; Type | Bytes\u0026#39;); Writeln(\u0026#39;--------------------------------\u0026#39;); Writeln(\u0026#39;AnsiChar = \u0026#39;, SizeOf(AnsiChar)); Writeln(\u0026#39;WideChar = \u0026#39;, SizeOf(WideChar)); Writeln(\u0026#39;Char = \u0026#39;, SizeOf(Char)); Writeln(\u0026#39;Byte = \u0026#39;, SizeOf(Byte)); Writeln(\u0026#39;ShortInt = \u0026#39;, SizeOf(ShortInt)); Writeln(\u0026#39;SmallInt = \u0026#39;, SizeOf(SmallInt)); Writeln(\u0026#39;LongInt = \u0026#39;, SizeOf(LongInt)); Writeln(\u0026#39;Int64 = \u0026#39;, SizeOf(Int64)); Writeln(\u0026#39;Byte = \u0026#39;, SizeOf(Byte)); Writeln(\u0026#39;Word = \u0026#39;, SizeOf(Word)); Writeln(\u0026#39;LongWord = \u0026#39;, SizeOf(LongWord)); Writeln(\u0026#39;Integer = \u0026#39;, SizeOf(Integer)); Writeln(\u0026#39;Cardinal = \u0026#39;, SizeOf(Cardinal)); Writeln(\u0026#39;Boolean = \u0026#39;, SizeOf(Boolean)); Writeln(\u0026#39;ByteBool = \u0026#39;, SizeOf(ByteBool)); Writeln(\u0026#39;WordBool = \u0026#39;, SizeOf(WordBool)); Writeln(\u0026#39;LongBool = \u0026#39;, SizeOf(LongBool)); Writeln(\u0026#39;Single = \u0026#39;, SizeOf(Single)); Writeln(\u0026#39;Real48 = \u0026#39;, SizeOf(Real48)); Writeln(\u0026#39;Double = \u0026#39;, SizeOf(Double)); Writeln(\u0026#39;Extended = \u0026#39;, SizeOf(Extended)); Writeln(\u0026#39;Comp = \u0026#39;, SizeOf(Comp)); Writeln(\u0026#39;Currency = \u0026#39;, SizeOf(Currency)); Writeln(\u0026#39;Real = \u0026#39;, SizeOf(Real)); Writeln(\u0026#39;ShortString = \u0026#39;, SizeOf(ShortString)); Writeln(\u0026#39;AnsiString = \u0026#39;, SizeOf(AnsiString)); Writeln(\u0026#39;WideString = \u0026#39;, SizeOf(WideString)); Writeln(\u0026#39;String = \u0026#39;, SizeOf(string)); Writeln(\u0026#39;Variant = \u0026#39;, SizeOf(Variant)); Writeln(\u0026#39;Pointer = \u0026#39;, SizeOf(Pointer)); Writeln(\u0026#39;--------------------------------\u0026#39;); Writeln(\u0026#39;Emnu = \u0026#39;, SizeOf(Emnu)); Writeln(\u0026#39;Range(0,FF) = \u0026#39;, SizeOf(Range1)); Writeln(\u0026#39;Range(0,FFFF) = \u0026#39;, SizeOf(Range2)); Writeln(\u0026#39;Range(0,FFFFFFFF) = \u0026#39;, SizeOf(Range3)); Writeln(\u0026#39;Array() = \u0026#39;, SizeOf(arr1)); Writeln(\u0026#39;Array(10)Byte = \u0026#39;, SizeOf(arr2)); Writeln(\u0026#39;Array(10)Int = \u0026#39;, SizeOf(arr3)); Writeln(\u0026#39;Record() = \u0026#39;, SizeOf(rcd1)); Writeln(\u0026#39;Record(1 byte) = \u0026#39;, SizeOf(rcd2)); Writeln(\u0026#39;Record(1 int) = \u0026#39;, SizeOf(rcd3)); Writeln(\u0026#39;Record(2 int) = \u0026#39;, SizeOf(rcd4)); Writeln(\u0026#39;Record(1 byte, 1 int) = \u0026#39;, SizeOf(rcd5)); Writeln(\u0026#39;Record(1 real) = \u0026#39;, SizeOf(rcd6)); Writeln(\u0026#39;Record(1 real, 1 int) = \u0026#39;, SizeOf(rcd7)); Writeln(\u0026#39;Object() = \u0026#39;, SizeOf(obj1)); Writeln(\u0026#39;Object(1 char) = \u0026#39;, SizeOf(obj2)); Writeln(\u0026#39;Object(1 int, 1 obj(char)) = \u0026#39;, SizeOf(obj3)); Readln; end. 分别用Delphi 7和Delphi XE7编译，运行结果如图：\n从运行结果可以看出：\nDelphi 7和Delphi XE7数据类型的唯一区别就是默认的字符集发生的变化，Delphi 7中 Char = AnsiChar，Delphi XE7中Char = WideChar，即Delphi 7默认使用ANSI编码，Delphi XE7默认使用Unicode编码。相应的，Delphi XE7中String = WideString，PChar = PWideChar。\nAnsiString、WideString、String和Pointer一样占用4B的空间，说明，字符串类型的本质其实就是指针。由于Delphi对字符封装得很好，使用起来感觉和整型、浮点型等没有什么差别，但毕竟还是不一样的，这是需要注意的（有关情况我会在另一篇中详细说明）。\n枚举类型4个元素占1B，其它数量时也是1B，说明枚举类型实际存储的是元素的索引，或者说枚举类型的元素实际是对应索引值的一个别名。至于超过256个元素的情况未进行测试，即枚举类型元素上限未测。\n子界类型与枚举类型比较类似，当元素个数少于256时用1B存储，超过256个时用2B，2B不够时用4B（没有3B的情况），以此推测，4B不够时将用8B、16B等。\n静态数组占用的是连续的内存区域，其大小为数组元素大小的总合；动态数组在未指定数组大小时只有4B，说明动态数组的本质也是指针（有关细节会同字符串一同说明）。\n记录类型的大小一般来说是其元素类型的大小*元素的个数，无元素时0B；如果元素类型不一致，元素类型统一按较大的类型的大小进行存储（猜想是为了方便寻址，拿空间换时间，提高运行速度）。\nObject类型是Delphi较早的一种类型，与记录类型很类似，不同的是其占用空间的大小为其元素大小的总合。估计Object类型就是记录类型的前身，而在记录类型出现后也依然没有消亡，想必仅仅是为了兼容古老的程序吧。\n**补充：**记录类型加packed修饰时，其大小为所有元素大小之和，与C语言中的结构体一致，因此，在编写兼容C的接口时，通常使用加packed的记录类型。\n1 2 3 rcd = packed record ... end; ","permalink":"https://afrusrsc.github.io/posts/program/pascal/delphi_type/","summary":"从其它平台迁移而来\n之前一直使用的是Delphi 7，现在准备转向Delphi XE7，据说数据类型上有一些微小的调整，便想亲自验证一下，也顺便加深一下自己对Delphi数据类型的认识，毕竟之前仅仅是在用而从未考虑过类型在内存中的形态。\n验证方法很简单，就是在控制台用Sizeof()把相应数据类型的字节数显示出来。源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 program TypeSize; {$APPTYPE CONSOLE} uses SysUtils; type Emnu = (one, two, three, four); Range1 = $0.","title":"Delphi中的数据类型"},{"content":"个人资料 半路出家的程序员，凭兴趣完全自学，比较注重基础，虽是纯野生，但许多方面不逊于科班出身的正规军。\n十多年间，先后接触/学习了VB、Excel VBA、c/c++、c#、Delphi、Lazarus、python、go等编程语言，其中最熟悉的是pascal（即Delphi和Lazarus），其次是go；从事过桌面、服务器、嵌入式（单片机、PLC）的开发，最擅长的还数上位机开发；其它如安防、传感器、机械、机电、有限元、密码学、区块链等领域，也略有涉入。\n捐赠打赏 如果内容对您有帮助，欢迎捐赠打赏以表示支持！\n","permalink":"https://afrusrsc.github.io/about/","summary":"个人资料 半路出家的程序员，凭兴趣完全自学，比较注重基础，虽是纯野生，但许多方面不逊于科班出身的正规军。\n十多年间，先后接触/学习了VB、Excel VBA、c/c++、c#、Delphi、Lazarus、python、go等编程语言，其中最熟悉的是pascal（即Delphi和Lazarus），其次是go；从事过桌面、服务器、嵌入式（单片机、PLC）的开发，最擅长的还数上位机开发；其它如安防、传感器、机械、机电、有限元、密码学、区块链等领域，也略有涉入。\n捐赠打赏 如果内容对您有帮助，欢迎捐赠打赏以表示支持！","title":"👨🏻‍💻关于"}]