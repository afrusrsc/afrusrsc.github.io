<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>编程 on 慢步道人</title>
    <link>https://afrusrsc.github.io/categories/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on 慢步道人</description>
    <generator>Hugo -- 0.125.7</generator>
    <language>zh</language>
    <copyright>2017-2025 Jesse Jin</copyright>
    <lastBuildDate>Mon, 26 May 2025 10:27:45 +0800</lastBuildDate>
    <atom:link href="https://afrusrsc.github.io/categories/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go多版本共存</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_multi_version/</link>
      <pubDate>Mon, 26 May 2025 10:27:45 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_multi_version/</guid>
      <description>场景 工作需要，一般使用的是相对较低的go版本，且较长时间内不会轻易变更；自己尝鲜或参与某个开源项目，又会使用另外的go版本。在不同项目间切换工作，通常需要切换到对应的go版本（虽然go目前是向下兼容的，高版本可以正确编译低版本，但开发人员即便熟知不同版本间的差异，也不能百分百保证不使用到高版本的特性）。
解决方案 网上也有很多方案，尝试后摸索出了比较符合自己风格和习惯的方案。
创建一个存放go不同版本的目录，用于将不同版本下载到该目录统一管理，并以版本号命名 1 mkdir $HOME/gosdk 编写下载脚本download_go.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/bin/bash if test &amp;#34;${1}&amp;#34; == &amp;#34;&amp;#34;; then echo &amp;#39;请传入正确的版本号，如：&amp;#39;${0}&amp;#39; 1.21.1&amp;#39; else # 统一管理目录 gosdk=$HOME/gosdk # 下载 gopkg=go${1}.linux-amd64.tar.gz if ! test -e ${gopkg}; then wget -c https://dl.google.com/go/${gopkg} fi # 删除可能冲突的文件 rm -rf ${gosdk}/go rm -rf ${gosdk}/go${1} # 解压 tar -C ${gosdk}/ -xzf ${gopkg} # 重命名 mv ${gosdk}/go ${gosdk}/go${1} # 删除安装包 rm ${gopkg} # 配置环境变量 go env -w GOPROXY=https://goproxy.</description>
    </item>
    <item>
      <title>Lazarus插件式窗口设计尝试</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_plugin_form/</link>
      <pubDate>Mon, 05 May 2025 19:06:17 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_plugin_form/</guid>
      <description>前言 先前就尝试过使用Lazarus写一个插件式的桌面应用框架，主程序只负责整体的插件管理以及为插件提供页签式的展示容器，具体的功能实现都由插件（动态库）来完成。
但是之前比较零散的几次尝试，多或少有些问题，比较有代表性的如：
无法以模式窗口显示插件内的子窗口
插件内的窗口在任务栏上显示的是和主程序分离的两个程序
动态库无法卸载
使用接口无法释放动态库里的对象
无法跨平台（主要针对windows）
近来又进行了一次系统性的尝试，以前的一些也针对性的研究了下，并找到了目前来看比较合适的解决方案，并将阶段性成果开源了，具体地址见文末。
旧问题解决 模式窗口 这个问题其实早在Lazarus官方的wiki（Form in Dll）上就有解决方案了。
在此基础上也尝试进行一些魔改，过程就不多说了，经验总结如下：
DisableFormsCallBack和EnableFormsCallback两个回调必须为普通过程，改为类方法会导致模式窗口失效
TApplicationCallback可以和插件动态库内的管理类合并，做为插件入口的统一管理，甚至做为插件统一接口的实现
视觉上为同一程序 Form in Dll中已经涉及，即在CreateParams中将Params.WndParent赋值为主程序中对应容器的句柄。
卸载/释放 对于动态库的卸载，在Lazarus的dll卸载问题中已有提到，本次直接避免。
对于对象的释放，这前的尝试犯了一个很严重的错误，即未遵守谁创建谁释放这一原则。接口中增加专门的释放函数，用于释放通过接口创建的对象。但，对于接口创建的对象，主程序除了释放外，也不应该（事实上也不能）进行其它操作，否则会抛内存访问异常。
共享内存管理器 如果仅使用基本数据类型的话，这就是个伪命题，但若使用高阶数据类型的话还是会方便很多，毕竟字符串其实并不算是真正的基本类型。
文章在Lazarus中使用ShareMem解决了在Windows平台上共享内存管理器的问题。在QQ群的交流中，群友啊D提出使用GetMemoryManager和SetMemoryManager，目前来看是能解决该问题的。
跨平台一致性 Lazarus本身就是跨平台的，只注意避免使用平台专用的api即可，或者对不同平台的api进行封装。
对于插件式的动态库，exports导出的函数统一使用Name关键字强制命名。同时，对于32位CPU，导出函数统一使用cdecl而不是stdcall进行传参约束；对于64位CPU，导出函数统一使用默认的传参约束，即不使用任何关键字，由编译器管理。
新的问题 基于有限的测试，Linux的gtk2中显示模式窗口时主窗体还能进行最大化、最小化、移动等操作，但不能操作窗体内的元素，这与Windows上的行为表现不太一致
插件动态库创建的窗体，嵌入主程序容器后，并不能像嵌入自身容器内那样可以方便的自适应大小和位置
TODO 解决新发现的问题
主程序页签式容器的实现
主程序插件的管理
开源地址 Github地址：https://github.com/afrusrsc/x-framework
Gitee地址：https://gitee.com/afrusrsc/x-framework</description>
    </item>
    <item>
      <title>ANSI转义序列</title>
      <link>https://afrusrsc.github.io/posts/program/misc/ansi_es/</link>
      <pubDate>Thu, 17 Apr 2025 20:28:24 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/misc/ansi_es/</guid>
      <description>起因 近来，翻看gin源码时，无意间看到了green = &amp;quot;\033[97;42m&amp;quot;这种不明所以的代码，遂充满疑惑和好奇，于是就搜索探究了一番，这才知道这叫ANSI转义序列。
ANSI转义序列 简单说，就是一种标准化的终端控制序列，用于设置文本样式、颜色和背景等。先放个代码吧，以免不知所云。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import &amp;#34;fmt&amp;#34; func main() { for i := 0; i &amp;lt;= 10; i++ { fmt.Printf(&amp;#34;这是\033[%[1]dm&amp;lt;文本属性&amp;gt;%2[1]d\033[0m\n&amp;#34;, i) } s := []int{30, 31, 32, 33, 34, 35, 36, 37} for _, v := range s { fmt.Printf(&amp;#34;这是\033[%[1]dm&amp;lt;16色标准前景色&amp;gt;%2[1]d\033[0m\t\033[%[2]dm&amp;lt;16色亮前景色&amp;gt;%2[2]d\033[0m\n&amp;#34;, v, v+60) fmt.Printf(&amp;#34;这是\033[%[1]dm&amp;lt;16色标准背景色&amp;gt;%2[1]d\033[0m\t\033[%[2]dm&amp;lt;16色亮背景色&amp;gt;%2[2]d\033[0m\n&amp;#34;, v+10, v+70) } for i := 0; i &amp;lt; 256; i++ { fmt.</description>
    </item>
    <item>
      <title>Go命令行加进度条</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_progressbar/</link>
      <pubDate>Fri, 21 Mar 2025 21:38:23 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_progressbar/</guid>
      <description>背景 文件去重功能做好了，但当文件比较多或文件比较大的时候，耗时也会比较久，想加个进度条来直观显示处理进度。
简单尝试了下github.com/schollz/progressbar这个库，完全能满足目前的需求。
使用 安装 1 go get -u github.com/schollz/progressbar/v3 # 注意带版本v3 一般使用 1 2 3 4 5 6 bar := progressbar.Default(n, &amp;#34;描述&amp;#34;) defer bar.Close() i := 0; i &amp;lt; n; i++ { bar.Add(1) // 工作代码 } n为总数，当n&amp;gt;0时，显示的是常规的进度条；当n=-1时，显示一个计数的进度。
还有其它比较细的控制及其它场景的使用，等有空了再细细研究下。</description>
    </item>
    <item>
      <title>用Go写一个文件去重工具</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_duplicate_cleaner/</link>
      <pubDate>Thu, 20 Mar 2025 16:19:57 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_duplicate_cleaner/</guid>
      <description>背景 想自己做这个功能，主要是因为Duplicate Cleaner这个商业软件只有几天的试用时间，而且文件去重这个逻辑也非常简单。
graph TD a[获取文件清单及大小] --&gt; b[按大小分组] --&gt; c[排除只有一个文件的组] --&gt; d[计算文件Hash值] --&gt; e[按Hash值分组] --&gt; f[排除只有一个文件的组] --&gt; g[选择需要删除的文件] --&gt; h[删除] 问题 计算文件Hash值，使用了hash.Hash接口，自然也用到了goroutine来缩短耗时，但是在测试的时候发现功能不太好用，时好时坏，准确说是有时能获取到重复列表，有时不能。
一点点排查，并且把代码段发给DeepSeek，最终确定是因为hash.Hash不是并发安全的。
修复方法很简单，只要在goroutine内实例化即可。修改之后达到了预期。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func calcHashs(files []*FileInfo, hashName string) { g := sync.WaitGroup{} for _, file := range files { g.Add(1) go func(f *FileInfo) { defer g.Done() h := newHash(hashName) hashValue, err := calcHash(f.</description>
    </item>
    <item>
      <title>Gin功能列表</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_gin_funclist/</link>
      <pubDate>Sun, 23 Feb 2025 19:48:17 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_gin_funclist/</guid>
      <description>gin版本v1.10.0
包函数 方法 含义 说明 BasicAuth 创建一个HTTP基本认证（Basic HTTP Authorization）的中间件 底层调用BasicAuthForRealm BasicAuthForProxy 创建一个HTTP代理基本认证（Basic HTTP Proxy - Authorization）的中间件 BasicAuthForRealm 创建一个HTTP基本认证（Basic HTTP Authorization）的中间件 Bind 创建一个用于将请求中的数据绑定到指定的接口对象上的中间件 CreateTestContext 创建一个干净的Engine实例和一个与之关联的上下文对象用于测试 CreateTestContextOnly 在已有的Engine实例基础上创建一个独立的上下文用于测试 CustomRecovery 根据自定义的处理函数创建一个恢复中间件 底层调用CustomRecoveryWithWriter CustomRecoveryWithWriter 创建一个自定义的恢复中间件 Default 返回一个默认的Engine实例 默认含Logger和Recovery两个中间件 Dir 返回一个http.FileSystem接口的实现，该实现可被http.FileServer使用 DisableBindValidation 关闭默认的验证器 DisableConsoleColor 禁用控制台的颜色输出 EnableJsonDecoderDisallowUnknownFields 开启JSON解码器的DisallowUnknownFields功能 即遇到未知字段时就报错 EnableJsonDecoderUseNumber 开启JSON解码器的UseNumber功能 即将数字解码为json.Number类型，而不是float64，以在需要时精确地转换为整数或浮点数，从而避免精度丢失的问题 ErrorLogger 创建一个能够处理任意类型的错误的中间件 底层调用ErrorLoggerT ErrorLoggerT 创建一个能够处理指定类型的错误的中间件 ForceConsoleColor 强制在控制台输出带有颜色的内容 IsDebugging 判断当前框架是否处于调试模式 Logger 使用默认配置来创建一个日志中间件 底层调用LoggerWithConfig LoggerWithConfig 根据传入的配置来创建一个日志中间件 LoggerWithFormatter 根据指定的格式来创建一个日志中间件 底层调用LoggerWithConfig LoggerWithWriter 根据指定的输出目标创建一个日志中间件 底层调用LoggerWithConfig Mode 返回当前Gin框架的运行模式 有debug、release和test三种模式 New 返回一个全新的、没有任何中间件的Engine实例 Recovery 使用默认配置创建一个恢复中间件 底层调用RecoveryWithWriter RecoveryWithWriter 根据指定输出目标创建一个恢复中间件 底层调用CustomRecoveryWithWriter SetMode 设置gin框架的运行模式 WrapF 将标准的http.</description>
    </item>
    <item>
      <title>Lazarus在Linux上使用自定义动态库</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_dll_linux/</link>
      <pubDate>Thu, 20 Feb 2025 21:51:24 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_dll_linux/</guid>
      <description>前置知识 Windows上叫动态链接库，通常以*.dll形式命名；Linux上叫共享库，通常以lib*.so形式命名。（此处统一叫动态库）
Windows上dll路径的一般搜索顺序为：当前目录-&amp;gt;系统目录（如：C:\Windows\System32、C:\Windows\SysWOW64）-&amp;gt;Windows目录（如C:\Windows）-&amp;gt;PATH环境变量指定的目录。
Linux上so路径的一般搜索顺序为：编译时使用-rpath指定的路径-&amp;gt;LD_LIBRARY_PATH环境变量指定的路径-&amp;gt;系统默认库路径（如/lib、/usr/lib等）-&amp;gt;/etc/ld.so.conf和/etc/ld.so.conf.d/目录中配置的路径。
Lazarus/Delphi调用动态库有两种形式：静态调用和动态调用。
静态调用：主程序启动时加载，若动态库不存在或不匹配，则主程序抛异常并中止；主程序退出时卸载。
动态调用：主程序在需要时可随时加载，不需要时可随时卸载；动态库发生异常时，一般不会导致主程序中止。
使用动态库 动态库 动态库本身不需要特殊设置，正常编译、构建即可。（以名为dll的动态库为例，实际文件名为libdll.so）
主程序 编译时 静态调用方式 主程序直接编译会报错：Warning: linker:/usr/bin/ld: cannot find -ldll: No such file or directory，意思是链接器找不到名为dll的动态库文件。
解决方案 打开Project Options-&amp;gt;Compiler Options-&amp;gt;Compilation and Linking，勾选Pass options to linker with &amp;quot;-k&amp;quot;, delimiter is space，并在下方填入-L’动态库所在路径’，保存即可正常编译。
动态调用方式 主程序直接编译即可。
运行时 静态调用方式 此时编译后的程序并不能正常运行，会报错error while loading shared libraries: libdll.so: cannot open shared object file: No such file or directory，意思是加载动态库时找不到名为libdll.so的动态库文件。
这是前面提到的路径搜索顺序导致的，可将动态库放入相应的搜索路径下，也可使用-rpath指定路径。对于自定的动态库，建议使用-rpath指定路径，最好指定的路径为当前路径（与Windows保持一致）。
解决方案 打开Project Options-&amp;gt;Compiler Options-&amp;gt;Compilation and Linking，勾选Pass options to linker with &amp;quot;-k&amp;quot;, delimiter is space，并在下方填入-rpath=&#39;$ORIGIN&#39;（与之前的-L’动态库所在路径’之间要添加一个空格），保存并重新编译，即可正常运行。</description>
    </item>
    <item>
      <title>Lazarus为应用添加版本信息</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_add_appver/</link>
      <pubDate>Tue, 12 Nov 2024 20:08:32 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_add_appver/</guid>
      <description>需求背景 在开发过程中，我们经常需要给应用添加版本信息，以便于追踪和管理应用的版本。
对于windows平台，直接在Project-&amp;gt;Project Options...对话框中的Project Options-&amp;gt;Version Info内进行设置即可。
但是，对于非windows平台，该方案便不可行。
而且，该方案还存在一个明显的问题：版本信息需要手动维护，未能与版本控制系统进行有效关联，很可能出现应用与源码不一致的情况。
解决思路 不使用Version Info功能，但取其把版本信息编译到可执行文件中的思想。
借鉴vscode的关于方案，版本信息中包含版本号和提交ID即可使应用和源码进行关联。
只要解决了在构建时动态获取版本信息的问题，便可以解决该问题。
解决方案 经多种尝试，最终确定的方案如下：
在源码中添加ver.inc文件，用于存储版本信息，在关于界面等进行展示。
编写脚本，获取版本信息并写入ver.inc文件。
打开Project-&amp;gt;Project Options...对话框，在Compiler Options-&amp;gt;Compiler Commands-&amp;gt;Execute before中添加脚本的路径。
正常构建应用即可。
如要跨平台，可分别编写对应平台的脚本并创建对应的Build mode，在Build modes中选择对应的模式，然后配置对应的脚本，正常构建即可。
附脚本 以使用git为例：
windows 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @echo off ::获取版本号 git describe --tags &amp;gt;nul 2&amp;gt;nul if errorlevel 1 ( set VER_NO=0.0 ) else ( for /f &amp;#34;delims=&amp;#34; %%a in (&amp;#39;git describe --tags&amp;#39;) do set VER_NO=%%a ) ::获取提交id git rev-parse HEAD &amp;gt;nul 2&amp;gt;nul if errorlevel 1 ( set COMMIT_ID=0000000000000000000000000000000000000000 ) else ( for /f &amp;#34;delims=&amp;#34; %%b in (&amp;#39;git rev-parse HEAD&amp;#39;) do set COMMIT_ID=%%b ) ::写入文件 echo const &amp;gt; ver.</description>
    </item>
    <item>
      <title>Go path包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_path/</link>
      <pubDate>Sun, 03 Nov 2024 22:12:48 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_path/</guid>
      <description>path包 path包仅适用于处理由正斜杠/分隔的路径，例如URL。
不能处理带有盘符或反斜杠\的Windows路径。
包函数 方法 含义 说明 Base 返回路径的最后一个元素 会先移除路径末尾的斜杠，空路径返回.，纯斜杠返回/ Clean 返回与输入路径等效的最短路径名 Dir 返回路径的目录部分 Ext 返回路径中以.分隔的文件扩展名 无.则返回空字符串 IsAbs 判断路径是否为绝对路径 只有以/开头的才是绝对路径 Join 将路径元素连接成路径 Match 判断路径是否匹配模式 Split 将路径拆分为目录和文件 filepath包 处理方式与目标操作系统定义的文件路径相兼容。 包函数 方法 含义 说明 Abs 返回绝对路径 Base 返回路径的最后一个元素 会先移除路径末尾的斜杠，空路径返回.，纯斜杠返回/ Clean 返回与输入路径等效的最短路径名 Dir 返回路径的目录部分 EvalSymlinks 返回路径中的符号链接所指向的真实路径 Ext 返回路径中以.分隔的文件扩展名 无.则返回空字符串 FromSlash 将路径中/的斜杠替换为特定操作系统的分隔符字符 linux中的\不会被替换 ToSlash 将路径中特定操作系统的分隔符字符替换为/ linux中的\不会被替换 Glob 返回与模式匹配的所有路径 IsAbs 判断路径是否为绝对路径 只有以/开头的才是绝对路径 IsLocal 判断路径是否为本地路径，即是否在当前路径下 仅词法分析，不考虑文件系统 Join 将路径元素连接成路径 Localize 将一个以/分隔的路径转换为一个操作系统路径 Match 判断路径是否匹配模式 Rel 返回从basepath到targpath的相对路径 Split 将路径拆分为目录和文件 SplitList 将一个包含多个以特定操作系统路径分隔符（如:或;）分隔的路径字符串拆分成单个的路径元素 分隔符取决于当前操作系统 VolumeName 返回路径的卷名 适用于Windows平台 Walk 遍历路径下的所有目录和文件并对其调用fn WalkDir 遍历路径下的所有目录和文件并对其调用fn 比Walk更优更高效 </description>
    </item>
    <item>
      <title>Go sync包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_sync/</link>
      <pubDate>Wed, 30 Oct 2024 22:45:48 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_sync/</guid>
      <description>Mutex 无需显式初始化，直接声明变量即可使用。
互斥锁，同一时刻只能有一个协程持有锁，不分读写。
方法 含义 说明 Lock 加锁 Unlock 解锁 未加锁时调用会导致panic TryLock 尝试加锁 立即返回，成功返回true，失败返回false RWMutex 无需显式初始化，直接声明变量即可使用。
读写锁，同一时刻可以有多个协程持有读锁，但是只能有一个协程持有写锁。
有写锁时，其他协程无法获取读锁和写锁。
有读锁时，其他协程可以获取读锁，但是无法获取写锁。
方法 含义 说明 RLock 加读锁 RUnlock 解读锁 未加读锁时调用会导致panic TryRLock 尝试加读锁 立即返回，成功返回true，失败返回false Lock 加写锁 Unlock 解写锁 未加写锁时调用会导致panic TryLock 尝试加写锁 立即返回，成功返回true，失败返回false Map 无需显式初始化，直接声明变量即可使用。 方法 含义 说明 Store 存储键值对 Load 加载键对应的值 Delete 删除键对应的值 Clear 清除所有键值对 Swap 交换指定键对应的旧值和新值，并返回旧值和操作之前键是否存在 LoadAndDelete 加载键对应的值并删除键值对 LoadOrStore 加载键对应的值，如果键不存在则存储键值对 CompareAndDelete 比较键对应的值是否等于指定值，如果相等则删除键值对 CompareAndSwap 比较键对应的值是否等于指定值，如果相等则替换键对应的值 Range 遍历键值对 传入函数返回false时停止遍历 WaitGroup 无需显式初始化，直接声明变量即可使用。 方法 含义 说明 Add 添加计数器 启动协程前调用，传入协程数量 Done 减少计数器 协程执行完毕后调用 Wait 等待计数器变为0 主协程调用，等待所有协程执行完毕 Once 无需显式初始化，直接声明变量即可使用。 方法 含义 说明 Do 执行函数 传入函数，只会执行一次 Pool 需显式初始化，为New指定创建对象的函数。</description>
    </item>
    <item>
      <title>Go flag包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_flag/</link>
      <pubDate>Sun, 27 Oct 2024 11:03:21 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_flag/</guid>
      <description>简介 flag用于实现命令行标志的解析。
一般流程 定义命令行标志
解析命令行标志
获取解析标志外的命令行参数
使用解析后的标志和参数
支持的标志格式 -flag：短标志
--flag：长标志
-flag=value：短标志和值
-flag value：短标志和值，仅限非布尔标志
解析规则 标志解析会在遇到第一个非标志参数（-被视为非标志参数）或者终止符--之后停止。
1 0 t f T F true false TRUE FALSE True False均可被解析为布尔值。
标志解析的返回值均为对应类型的指针。
包函数 方法 含义 说明 NewFlagSet 创建一个新的标志集 通常用于创建子命令的标志集 Lookup 查找标志集中的标志 Set 设置标志集中的标志的值 NArg 返回实际传入的命令行参数的数量 调用Parse之后生效，不包含命令行标志 Arg 返回第i个命令行参数 从0开始 NFlag 返回实际传入的命令行标志的数量 调用Parse之后生效 Parsed 返回标志是否已被解析 Parse 解析命令行标志 Bool 定义一个布尔型标志 BoolVar 定义一个布尔型标志并绑定到指定变量 Int 定义一个整数标志 IntVar 定义一个整数标志并绑定到指定变量 Int64 定义一个64位整数标志 Int64Var 定义一个64位整数标志并绑定到指定变量 Uint 定义一个无符号整数标志 UintVar 定义一个无符号整数标志并绑定到指定变量 Uint64 定义一个64位无符号整数标志 Uint64Var 定义一个64位无符号整数标志并绑定到指定变量 Float64 定义一个64位浮点数标志 Float64Var 定义一个64位浮点数标志并绑定到指定变量 Duration 定义一个时间间隔标志 DurationVar 定义一个时间间隔标志并绑定到指定变量 String 定义一个字符串标志 StringVar 定义一个字符串标志并绑定到指定变量 Var 定义一个自定义类型标志并绑定到对应变量 自定义类型需要实现flag.</description>
    </item>
    <item>
      <title>Go log包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_log/</link>
      <pubDate>Sat, 26 Oct 2024 19:43:48 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_log/</guid>
      <description>Logger 方法 含义 说明 Fatal Fatalf Fatalln 记录一条严重错误后执行os.Exit(1) Panic Panicf Panicln 记录一条严重错误后引发panic Print Printf Println 记录一条普通信息 Flags 返回当前Logger的输出标志 SetFlags 设置当前Logger的输出标志 Prefix 返回当前Logger的前缀 SetPrefix 设置当前Logger的前缀 Writer 返回当前Logger的输出目标 SetOutput 设置当前Logger的输出目标 Output 直接输出日志 更接近底层，可指定调用等级 包函数 方法 含义 说明 Default 返回默认的Logger New 创建一个新的Logger Fatal Fatalf Fatalln 记录一条严重错误后执行os.Exit(1) 使用默认的Logger Panic Panicf Panicln 记录一条严重错误后引发panic 使用默认的Logger Print Printf Println 记录一条普通信息 使用默认的Logger Flags 返回默认Logger的输出标志 SetFlags 设置默认Logger的输出标志 Prefix 返回默认Logger的前缀 SetPrefix 设置默认Logger的前缀 Writer 返回默认Logger的输出目标 SetOutput 设置默认Logger的输出目标 Output 使用默认的Logger直接输出日志 </description>
    </item>
    <item>
      <title>Go bufio包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_bufio/</link>
      <pubDate>Fri, 25 Oct 2024 21:23:15 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_bufio/</guid>
      <description>Reader 方法 含义 说明 Buffered 返回从当前缓冲区内可以读取的字节数量 Discard 跳过接下来的n字节 Peek 查看接下来的n字节 不移动读指针 Read 从bufio.Reader中读取内容到字节切片 ReadByte 从bufio.Reader中读取一个字节 ReadBytes 从bufio.Reader中读取数据，直到遇到指定的分隔符delim 包含分隔符 ReadLine 从bufio.Reader中读取一行数据 不包含换行符，建议使用Reader.ReadBytes(&#39;\n&#39;)、Reader.ReadString(&#39;\n&#39;)或者Scanner ReadRune 从bufio.Reader中读取一个rune ReadSlice 从bufio.Reader中读取数据，直到遇到指定的分隔符delim 包含分隔符，建议使用Reader.ReadBytes或ReadString ReadString 从bufio.Reader中读取数据，直到遇到指定的分隔符delim 包含分隔符 Reset 重置bufio.Reader Size 返回底层缓冲区的大小 UnreadByte 回退最后读取的一个字节 UnreadRune 回退最后读取的一个rune WriteTo 将数据从bufio.Reader写入到io.Writer Writer 方法 含义 说明 Available 返回当前缓冲区中可以写入的字节数量 AvailableBuffer 返回一个空的缓冲区，容量是Available返回的值 Buffered 返回当前缓冲区中已经写入的字节数量 Flush 将缓冲区中的数据写入到io.Writer ReadFrom 从io.Reader读取数据到bufio.Writer Reset 重置bufio.Writer Size 返回底层缓冲区的大小 Write 将数据写入bufio.Writer WriteByte 将一个字节写入bufio.Writer WriteRune 将一个rune写入bufio.Writer WriteString 将一个字符串写入bufio.Writer Scanner 方法 含义 说明 Buffer 设置在扫描时要使用的初始缓冲区，及在扫描过程中可能分配的最大缓冲区大小 Bytes 返回由最近一次调用Scanner.</description>
    </item>
    <item>
      <title>Go io/fs包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_io_fs/</link>
      <pubDate>Thu, 24 Oct 2024 22:02:04 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_io_fs/</guid>
      <description>包函数 方法 含义 说明 FileInfoToDirEntry 将fs.FileInfo转换为fs.DirEntry FormatDirEntry 将fs.DirEntry格式化为字符串 FormatFileInfo 将fs.FileInfo格式化为字符串 Glob 获取指定模式的文件列表 ReadDir 读取指定目录中的内容，返回DirEntry切片 ReadFile 读取指定文件的内容，返回字节切片 Stat 获取文件信息，返回FileInfo Sub 获取指定目录的子目录 ValidPath 验证路径是否合法 WalkDir 遍历目录 </description>
    </item>
    <item>
      <title>Go io包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_io/</link>
      <pubDate>Thu, 24 Oct 2024 20:05:22 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_io/</guid>
      <description>OffsetWriter OffsetWriter是io.Writer的一个实现，它可以将写入的数据偏移指定的字节数后写入到另一个io.Writer中。
方法 含义 说明 Write 将数据写入io.Writer WriteAt 将数据写入io.Writer，从指定位置开始 Seek 设置指针位置 SectionReader SectionReader是io.Reader的一个实现，它可以从另一个io.Reader中读取指定范围的数据。
方法 含义 说明 Outer 获取底层的ReaderAt、偏移量和长度 Read 从io.Reader读取内容到字节切片 读取后指针位置会移动 ReadAt 从io.Reader读取内容到字节切片，从指定位置开始 读取后指针位置不会移动 Seek 设置指针位置 Size 返回区间的大小 PipeReader PipeReader是io.Reader的一个实现，它可以从另一个io.Reader中读取数据。
方法 含义 说明 Read 从管道读取内容到字节切片 Close 关闭PipeReader CloseWithError 关闭PipeReader并返回错误 PipeWriter PipeWriter是io.Writer的一个实现，它可以将数据写入到另一个io.Reader中。
方法 含义 说明 Write 将数据写入io.Writer Close 关闭PipeWriter CloseWithError 关闭PipeWriter并返回错误 包函数 方法 含义 说明 Copy 将数据从io.Reader复制到io.Writer CopyBuffer 将数据从io.Reader复制到io.Writer，使用指定的缓冲区 CopyN 将数据从io.Reader复制到io.Writer，最多复制n个字节 LimitReader 从io.Reader创建一个限制的读取范围的io.Reader MultiReader 将多个io.Reader组合成一个io.Reader 先后读取，类似内容拼接 MultiWriter 将多个io.Writer组合成一个io.Writer 同时写入 NewOffsetWriter 从io.Writer创建一个带有偏移量的io.Writer NewSectionReader 从io.</description>
    </item>
    <item>
      <title>Go os包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_os/</link>
      <pubDate>Wed, 23 Oct 2024 23:49:39 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_os/</guid>
      <description>File 方法 含义 说明 Close 关闭文件 Chdir 改变当前工作目录 *File必须为目录 Chmod 修改文件权限 Chown 修改文件所有者和组 Fd 返回文件描述符 Name 返回文件名 Read 从文件读取内容到字节切片 读取后指针位置会移动 ReadAt 从文件读取内容到字节切片，从指定位置开始 读取后指针位置不会移动 ReadDir 获取目录下的列表，返回DirEntry切片 *File必须为目录 Readdir 获取目录下的列表，返回FileInfo切片 *File必须为目录 Readdirnames 获取指定目录下的文件名 *File必须为目录 ReadFrom 从io.Reader读取内容到文件 读取后指针位置会移动，本质上是写文件 Seek 设置指针位置 SetDeadline 设置文件I/O超时时间 只有部分文件类型支持 SetReadDeadline 设置文件读取超时时间 只有部分文件类型支持 SetWriteDeadline 设置文件写入超时时间 只有部分文件类型支持 Stat 获取文件信息，返回FileInfo Sync 将文件内容同步到磁盘 SyscallConn 获取与文件操作相关的系统调用连接 Truncate 截断文件 Write 将字节切片中的数据写入文件 写入后指针位置会移动 WriteAt 将字节切片中的数据写入文件，从指定位置开始 写入后指针位置不会移动 WriteString 将字符串写入文件 写入后指针位置会移动 WriteTo 将数据写入io.Writer 写入后指针位置会移动，本质上是读文件 FileInfo 方法 含义 说明 IsDir 返回文件是否是目录 ModTime 返回文件的修改时间 Name 返回文件名 Size 返回文件的大小 Sys 返回文件的系统信息 FileMode 方法 含义 说明 IsDir 返回文件是否是目录 IsRegular 返回文件是否是普通文件 Perm 返回文件的权限 String 返回文件的字符串表示形式 Type 返回文件的类型 Process 方法 含义 说明 Kill 杀掉进程 Release 释放与Process对象相关的资源 Signal 向进程发送信号 Wait 等待进程退出 ProcessState 用于获取已结束进程状态信息。</description>
    </item>
    <item>
      <title>Go time包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_time/</link>
      <pubDate>Tue, 22 Oct 2024 22:23:20 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_time/</guid>
      <description>Time 方法 说明 Add 在该时间上加个时间得到新时间 AddDate 在该时间上加个日期得到新时间 After 判断该时间是否在另一个时间之后 AppendFormat 将该时间格式化为字符串并追加到字节切片中 Before 判断该时间是否在另一个时间之前 Clock 返回当前时间的时、分、秒 Compare 和另一个时间比较大小，返回-1、0、1 Date 返回该时间的年、月、日 Day 返回该时间的日 Equal 判断该时间是否和另一个时间相等 Format 将该时间格式化为字符串 GoString 返回该时间的字符串表示形式 GobDecode 从字节切片中解码该时间 GobEncode 将该时间编码为字节切片 Hour 返回该时间的小时 ISOWeek 返回该时间所在的ISO周 In 返回该时间在指定时区对应的时间 IsDST 判断该时间是否在夏令时 IsZero 判断一个时间值是否为零值 Local 返回该时间在本地时区对应的时间 Location 返回该时间所在的时区 MarshalBinary 将该时间序列化为二进制格式 MarshalJSON 将该时间序列化为JSON格式 MarshalText 将该时间序列化为文本格式 Minute 返回该时间的分钟 Month 返回该时间的月份 Nanosecond 返回该时间的纳秒 Round 将该时间舍入到指定的时间单位 Second 返回该时间的秒 String 返回该时间的字符串表示形式 Sub 在该时间上减去另一个时间得到新时间 Time 返回该时间的时间戳 Truncate 将该时间截断到指定的时间单位 UTC 返回该时间在UTC时区对应的时间 Unix 返回该时间的Unix时间戳，单位：秒 UnixMicro 返回该时间的Unix时间戳，单位：微秒 UnixMilli 返回该时间的Unix时间戳，单位：毫秒 UnixNano 返回该时间的Unix时间戳，单位：纳秒 UnmarshalBinary 从二进制格式反序列化该时间 UnmarshalJSON 从JSON格式反序列化该时间 UnmarshalText 从文本格式反序列化该时间 Weekday 返回该时间所在的星期几 Year 返回该时间的年份 YearDay 返回该时间所在的年中的第几天 Zone 返回该时间所在的时区名称和偏移量（单位：秒） ZoneBounds 返回该时间所在的时区的夏令时开始和结束时间 包函数 函数名 含义 说明 Now 返回当前时间 Date 构造指定的时间 FixedZone 构造一个指定偏移时的时区 LoadLocation 加载时区信息 LoadLocationFromTZData 从TZData文件加载时区信息 Parse 解析时间字符串 ParseDuration 解析时间间隔字符串 ParseInLocation 在指定时区解析时间字符串 Since 计算指定时间与现在的间隔 等同于time.</description>
    </item>
    <item>
      <title>Go strings包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_strings/</link>
      <pubDate>Sun, 20 Oct 2024 13:36:24 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_strings/</guid>
      <description>Builder 方法 说明 String 返回最终构造的字符串 Len 返回缓冲区（字节切片）的长度 Cap 返回缓冲区（字节切片）的容量 Reset 重置Builder Grow 显式扩容 Write 向Builder追加字节切片 WriteByte 向Builder追加字节 WriteRune 向Builder追加Unicode码点 WriteString 向Builder追加字符串 包函数 函数名 含义 说明 Clone 返回字符串的副本 Compare 比较两个字符串的大小，返回-1、0、1 Contains 判断一个字符串是否包含另一个字符串 类似于pascal的Pos()&amp;gt;0 ContainsAny 判断一个字符串是否包含另一个字符串中的任意一个字符 ContainsRune 判断一个字符串是否包含一个Unicode码点 ContainsFunc 判断一个字符串是否包含满足特定条件的字符 Count 统计一个字符串中某个子字符串出现的次数 Cut 将一个字符串按照指定的分隔符进行切割 只进行一次切割 CutPrefix 判断一个字符串是否以指定的前缀开始，是则进行切割 CutSuffix 判断一个字符串是否以指定的后缀结束，是则进行切割 EqualFold 判断两个字符串是否相等，忽略大小写 类似于pascal的SameText() Fields 用连续的空白字符对字符串进行分割 FieldsFunc 用指定的函数对字符串进行分割 HasPrefix 判断一个字符串是否以指定的前缀开始 HasSuffix 判断一个字符串是否以指定的后缀结束 Index 返回一个字符串中某个子字符串第一次出现的位置（从0开始，未找到返回-1） 类似于pascal的Pos() IndexAny 返回一个字符串中任意一个字符第一次出现的位置（从0开始，未找到返回-1） IndexByte 返回一个字符串中某个字节第一次出现的位置（从0开始，未找到返回-1） IndexRune 返回一个字符串中某个Unicode码点第一次出现的位置（从0开始，未找到返回-1） IndexFunc 返回一个字符串中满足特定条件的字符第一次出现的位置（从0开始，未找到返回-1） LastIndex 返回一个字符串中某个子字符串最后一次出现的位置（从0开始，未找到返回-1） LastIndexAny 返回一个字符串中任意一个字符最后一次出现的位置（从0开始，未找到返回-1） LastIndexByte 返回一个字符串中某个字节最后一次出现的位置（从0开始，未找到返回-1） LastIndexFunc 返回一个字符串中满足特定条件的字符最后一次出现的位置（从0开始，未找到返回-1） Join 将一个字符串切片用指定的字符串连接成一个新字符串 Map 将一个字符串中的每个字符都映射成另一个字符 Repeat 将一个字符串重复指定的次数 Replace 将一个字符串中的某个子字符串替换成另一个字符串 ReplaceAll 将一个字符串中的所有子字符串替换成另一个字符串 Split 用指定的字符对字符串进行分割 SplitN 用指定的字符对字符串进行分割，最多分割n次 SplitAfter 用指定的字符对字符串进行分割，保留分隔符 SplitAfterN 用指定的字符对字符串进行分割，保留分隔符，最多分割n次 ToLower 将一个字符串中的所有字符都转换成小写 ToUpper 将一个字符串中的所有字符都转换成大写 ToTitle 将其中所有的Unicode字母转换为它们对应的Unicode标题大小写 ToLowerSpecial 将字符串中的字符按照特定规则转换为小写形式 ToUpperSpecial 将字符串中的字符按照特定规则转换为大写形式 ToTitleSpecial 将字符串中的字符按照特定规则转换为标题形式 ToValidUTF8 将一个字符串中的无效UTF-8字符替换成Unicode替换字符 Trim 去除字符串两端的指定字符 连续的指定字符都会被去除 TrimLeft 去除字符串左边的指定字符 连续的指定字符都会被去除 TrimRight 去除字符串右边的指定字符 连续的指定字符都会被去除 TrimFunc 去除字符串两端满足特定条件的字符 连续的满足条件的字符都会被去除 TrimLeftFunc 去除字符串左边满足特定条件的字符 连续的满足条件的字符都会被去除 TrimRightFunc 去除字符串右边满足特定条件的字符 连续的满足条件的字符都会被去除 TrimSpace 去除字符串两端的空白字符 连续的空白都会被去除 TrimPrefix 去除字符串前缀 TrimSuffix 去除字符串后缀 </description>
    </item>
    <item>
      <title>Go builtin包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_builtin/</link>
      <pubDate>Fri, 18 Oct 2024 13:35:53 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_builtin/</guid>
      <description>说明 预声明标识符是指在代码中可以直接使用的标识符，但它们并没有在任何包中声明。这些标识符通常是由Go语言的标准库或编译器提供的，它们在代码中可以直接使用，而不需要导入任何包。
builtin包的作用是为这些预声明标识符提供文档说明，以便开发人员了解它们的用途和用法。通过查看builtin包的文档，开发人员可以了解到哪些预声明标识符是可用的，以及它们的作用和使用方法。
内置函数 函数名 含义 说明 append 将元素追加到切片末尾 容量足够时，不会重新分配内存；容量不足时，会重新分配内存 copy 将切片中的元素复制到另一个切片中，返回复制的元素数量 delete 从映射中删除指定的键值对 len 返回切片、映射、通道或字符串的长度 cap 返回切片、映射或通道的容量 make 为切片、映射或通道分配内存，并返回该类型的零值 max 返回一组可比较类型中的最大值 如果是浮点型且参数中有NaN，则返回NaN min 返回一组可比较类型中的最小值 如果是浮点型且参数中有NaN，则返回NaN new 为指定类型的新值分配内存，并返回指向该类型的零值的指针 complex 创建一个复数 real 返回复数的实部 imag 返回复数的虚部 clear 清除切片、映射中的所有元素 close 关闭通道 只能由发送方调用 panic 停止当前协程的正常执行，引发一个运行时错误，导致程序回溯调用栈 recover 从panic中恢复，并返回panic的值 只能在defer语句中使用 print println 对传入的参数进行格式化，然后将格式化后的结果输出到标准错误 用于引导程序和调试，未来其可能会被修改或移除，不应该在生产环境中使用 </description>
    </item>
    <item>
      <title>Go strconv包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_strconv/</link>
      <pubDate>Thu, 17 Oct 2024 13:14:07 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_strconv/</guid>
      <description>Go是强数据类型语言，且不支持隐式类型转换，strconv包是用于字符串和基本数据类型之间转换的。
其它类型转字符串 函数名 含义 说明 FormatBool 布尔型转字符串 FormatInt FormatUint 整形转字符串 需指定进制 FormatFloat 浮点型转字符串 需指定格式、精度、位宽（32/64） FormatComplex 复数型转字符串 需指定格式、精度、位宽（64/128） Itoa 整形转字符串 固定十进制 字符串转其它类型 函数名 含义 说明 ParseBool 字符串转布尔型 1 t T true TRUE True为真，0 f F false FALSE False为假 ParseInt ParseUint 字符串转整形 需指定字符串的进制及转换后的位宽 ParseFloat 字符串转浮点型 需指定转换后的位宽 ParseComplex 字符串转复数 需指定转换后的位宽 Atoi 字符串转整形 固定十进制 其它 函数名 含义 说明 CanBackquote 判断一个字符串是否可以不被修改地放在反引号中 不能包含换行符，除了制表符之外，不能包含其他控制字符 IsGraphic 判断一个Unicode字符是否是图形字符 IsPrint的超集 IsPrint 判断一个Unicode字符是否是可打印字符 IsGraphic的子集 Quote 返回一个用双引号包裹的Go语言字符串字面量 控制字符和由IsPrint定义的不可打印字符会进行转义 QuoteToASCII 返回一个用双引号包裹的Go语言字符串字面量 非ASCII字符以及由IsPrint定义的不可打印字符会进行转义 QuoteToGraphic 返回一个用双引号包裹的Go语言字符串字面量 由IsGraphic定义的非图形字符会进行转义 QuoteRune 返回一个单引号包裹的Go字符字面量 控制字符和由IsPrint定义的不可打印字符会进行转义 QuoteRuneToASCII 返回一个单引号包裹的Go字符字面量 非ASCII字符以及由IsPrint定义的不可打印字符会进行转义 QuoteRuneToGraphic 返回一个单引号包裹的Go字符字面量 由IsGraphic定义的非图形字符会进行转义 AppendBool 布尔型转字符串，结果追加到指定的字节切片，并返回新的字节切片 AppendInt AppendUint 整型转字符串，结果追加到指定的字节切片，并返回新的字节切片 需指定进制 AppendFloat 浮点型转字符串，结果追加到指定的字节切片，并返回新的字节切片 需指定格式、精度、位宽（32/64） AppendQuote Quote处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteToASCII QuoteToASCII处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteToGraphic QuoteToGraphic处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteRune QuoteRune处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteRuneToASCII QuoteRuneToASCII处理后的结果追加到指定的字节切片，并返回新的字节切片 AppendQuoteRuneToGraphic QuoteRuneToGraphic处理后的结果追加到指定的字节切片，并返回新的字节切片 </description>
    </item>
    <item>
      <title>Go fmt包</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_fmt/</link>
      <pubDate>Wed, 16 Oct 2024 20:51:40 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_fmt/</guid>
      <description>fmt包提供了格式化输入、输出的功能。
格式化输出 函数名 说明 Print 以默认格式进行格式化，格式化结果输出到os.Stdout Printf 以指定格式进行格式化，格式化结果输出到os.Stdout Println 以默认格式进行格式化，并在末尾添加换行符，格式化结果输出到os.Stdout Fprint 以默认格式进行格式化，格式化结果输出到指定的io.Writer接口 Fprintf 以指定格式进行格式化，格式化结果输出到指定的io.Writer接口 Fprintln 以默认格式进行格式化，并在末尾添加换行符，格式化结果输出到指定的io.Writer接口 Sprint 以默认格式进行格式化，格式化结果以字符串形式返回 Sprintf 以指定格式进行格式化，格式化结果以字符串形式返回 Sprintln 以默认格式进行格式化，并在末尾添加换行符，格式化结果以字符串形式返回 具体格式化规则详见Go 格式化。
格式化输入 函数名 说明 Scan 按默认格式从os.Stdin进行扫描，空格用于分隔数据，换行符按空格处理，扫描结果存入对应的变量 Scanf 按指定格式从os.Stdin进行扫描，扫描结果存入对应的变量 Scanln 按默认格式从os.Stdin进行扫描，空格用于分隔数据，遇换行符时停止扫描，扫描结果存入对应的变量 Fscan 按默认格式从指定的io.Reader接口进行扫描，空格用于分隔数据，换行符按空格处理，扫描结果存入对应的变量 Fscanf 按指定格式从指定的io.Reader接口进行扫描，扫描结果存入对应的变量 Fscanln 按默认格式从指定的io.Reader接口进行扫描，空格用于分隔数据，遇换行符时停止扫描，扫描结果存入对应的变量 Sscan 按默认格式从指定的字符串中进行扫描，空格用于分隔数据，换行符按空格处理，扫描结果存入对应的变量 Sscanf 按指定格式从指定的字符串中进行扫描，扫描结果存入对应的变量 Sscanln 按默认格式从指定的字符串中进行扫描，空格用于分隔数据，遇换行符时停止扫描，扫描结果存入对应的变量 注意：变量前必须要带上&amp;amp;才能成功接收扫描到的数据!
其它 函数名 说明 Append 以默认格式进行格式化，格式化结果追加到指定的字节切片，并返回新的字节切片 Appendf 以指定格式进行格式化，格式化结果追加到指定的字节切片，并返回新的字节切片 Appendln 以默认格式进行格式化，并在末尾添加换行符，格式化结果追加到指定的字节切片，并返回新的字节切片 Errorf 以指定格式进行格式化，格式化结果转为error接口并返回 </description>
    </item>
    <item>
      <title>Go 格式化</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_learn_format/</link>
      <pubDate>Tue, 15 Oct 2024 21:34:07 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_learn_format/</guid>
      <description>格式化动词 常规 格式化动词 含义 %v 默认格式 %T 数据的类型 %% %本身 使用%v时不同类型默认对应的格式化动词如下：
数据类型 格式化动词 说明 bool %t int int8 等 %d uint uint8 等 %d %#v时对应%#x float32 complex64 等 %g string %s chan %p pointer %p 布尔型 格式化动词 含义 示例 结果 %t true或false 1&amp;gt;2 false 整型 格式化动词 含义 示例 结果 %b 二进制 90 1011010 %c 对应的 Unicode 字符 90 Z %d 十进制 90 90 %o 八进制 90 132 %O 带0o前缀的八进制 90 0o132 %q 用单引号包括的对应的 Unicode 字符，并且特殊字符会进行转义 90 &amp;lsquo;Z&amp;rsquo; %x 小写的十六进制 90 5a %X 大写的十六进制 90 5A %U Unicode 格式：U+1234；与U+%04X相同 90 U+005A 浮点型和复数型 格式化动词 含义 示例 结果 %b 十进制无小数的科学计数法表示浮点数，指数部分是2的幂次方 3.</description>
    </item>
    <item>
      <title>Lazarus获取纳秒级时间</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_nanosecond/</link>
      <pubDate>Sat, 31 Aug 2024 21:25:25 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_nanosecond/</guid>
      <description>背景 最近在改写一个加密算法，算法不可避免用到了随机数，但是Lazarus默认的随机种子初始化函数Randomize是依赖于GetTickCount的，而GetTickCount的时间精度是毫秒级的（windows平台实际大约是16ms级），日常是够用的，但在加密算法中就显得太过粗糙了。
关于GetTickCount的时间精度，详见Delphi中的延时和在Lazarus中分析Windows和Linux的延时。
在以上文章中有提到，windows平台下可以使用QueryPerformanceFrequency和QueryPerformanceCounter获取高精度的时间，事实上是微秒级的时间（本机实测是0.1微秒级，即百纳秒）。
考虑跨平台的话，如何获取非windows平台的高精度时间就变得很有必要了。
解决方案 搜索资料及查看Lazarus源码，找到了fpgettimeofday和clock_gettime两个函数。
fpgettimeofday fpgettimeofday实际上就是UNIX平台的gettimeofday，只引用unix单元即可。其定义如下：
1 function fpgettimeofday(tp: ptimeval;tzp:ptimezone):cint; external name &amp;#39;FPC_SYSC_GETTIMEOFDAY&amp;#39;; 其参数ptimeval的定义如下：
1 2 3 4 5 6 7 8 9 10 timeval = record tv_sec:time_t; {$ifdef CPUSPARC64} tv_usec:cint; {$else CPUSPARC64} tv_usec:clong; {$endif CPUSPARC64} end; ptimeval = ^timeval; TTimeVal = timeval; 另外，unix平台的GetTickCount64用到了fpgettimeofday：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function GetTickCount64: QWord; var tp: TTimeVal; {$IFDEF HAVECLOCKGETTIME} ts: TTimeSpec; {$ENDIF} begin {$IFDEF HAVECLOCKGETTIME} if clock_gettime(CLOCK_MONOTONIC, @ts)=0 then begin Result := (Int64(ts.</description>
    </item>
    <item>
      <title>Lazarus跨平台方案总结</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_cross_platform/</link>
      <pubDate>Wed, 07 Aug 2024 21:57:25 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_cross_platform/</guid>
      <description>前言 对于Lazarus跨平台开发接触有一段时间了，虽然踩了不坑，但仍觉得已踩过的坑不过是九牛一毛。不过还是应该记录一下，以备忘，以后又踩新坑了再补充吧。
环境 项目 Linux Windows 操作系统 Debian 12 Win10 CPU架构 x86_64 x86_64 桌面环境 xfce 4 / 输入法 fcitx 5 系统自带 GUI环境 gtk2/qt5/qt6 win32/gtk2/qt5 目标程序 64位 32位/64位 Qt6Pas1.dll未能得到，win + qt6未测试
linux 64位系统未能设置好32位运行环境，未测试
qt5未能得到64位的dll，未测试
坑 windows Application.MessageBox按钮文字英文，无法直接本地化，Windows.MessageBoxAPI可以
TPageControl组件自带的关闭按钮在win32下不可用，gtk2和qt5正常
qt5下，某些组件会有很诡异的现象
gtk2下，64位目标程序运行时报错
gtk2下，默认界面很丑，需要用皮肤
带GUI的dll机制和行为与delphi不一致
使用ShareMem单元需要自行构建fpcmemdll.dll
linux gtk2版IDE无法输入中文；目标程序可正常输入（SynEdit不可以，必须修改相关源码）
qt5和qt6版IDE可输入中文，但部分字无法输入，也无法正常输入多于两个字的词组；目标程序存在相同的问题
qt5版IDE及目标程序所需要的libqt5pas一定要和编译用的IDE版本匹配
总结 基于有限的测试经验，得出了以下结论：
虽然Lazarus是跨平台的，并且号称一次编写，到处编译，但GUI的跨平台表现是不完全一致的，需要分别处理
整体上，gtk2兼容性和稳定性优于qt
最佳的开发方案：在windows系统上开发，然后交叉编译或在目标环境下进行编译（若使用了SynEdit，必须修改相关源码）
保持跨平台一致性的方案：windows平台采用32位的gtk2+皮肤，linux平台采用gtk2+皮肤</description>
    </item>
    <item>
      <title>在Lazarus中分析Windows和Linux的延时</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_delay/</link>
      <pubDate>Wed, 24 Jul 2024 23:23:07 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_delay/</guid>
      <description>前言 之前用Delphi时，研究过延时及其时间精度，并写了篇文章——Delphi中的延时，当时是仅在windows平台下测试的，现在想用Lazarus分别在windows和linux平台测试对比下。
测试 测试环境 CPU：x86_64
win：win10
linux：debian 12.6 + xfce
ide：Lazarus 3.4 + fpc 3.2.2
测试设计 整体与之前的设计保持一致，增加了GetTickCount64的测试，Timer的测试有改动，具体如下：
假定系统时间是足够精确的，因此使用Now分别在延时前后获取系统当前时间来进行耗时评估。
为使测试更具代表性，每个测试点连续测试100次，取算术平均值。
在1ms~100ms内，测试点步长为1ms，在100ms~1000ms内，测试点步长为10ms。
为尽可能减小干扰，测试过程中未使用并行，Sleep、GetTickCount和GetTickCount64未使用Application.ProcessMessages;，Timer绕不开事件触发，使用了Application.ProcessMessages;。
测试结果 windows 延时(ms) Sleep GetTickCount GetTickCount64 Timer 1 1.93 15.51 15.63 15.62 2 2.93 16.59 15.62 15.63 3 3.95 15.58 15.62 15.66 4 5.10 15.49 15.94 15.61 5 5.86 15.55 15.62 15.65 6 6.83 15.50 15.62 15.63 7 7.81 15.62 15.63 15.67 8 8.77 15.55 15.63 15.68 9 9.76 15.</description>
    </item>
    <item>
      <title>在Lazarus中使用ShareMem</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_sharemem/</link>
      <pubDate>Tue, 23 Jul 2024 20:40:36 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_sharemem/</guid>
      <description>问题 使用Delphi开发应用时，如果要在主程序和dll间传递字符串、对象等不兼容C的类型时，通常需要在主程序和dll工程的uses区第一个位置引用ShareMem单元，并将borlndmm.dll随应用一起发布使用。
Lazarus中也有ShareMem单元，说明也可以采用相同的策略解决同样的需求，但是并不是使用borlndmm.dll。
在源码sharemem.pp中可以看到const fpcmemdll = &#39;fpcmemdll.dll&#39;;，说明使用的是fpcmemdll.dll，但是这个dll实际上是并不存在的！
解决 全盘搜索并没有找到fpcmemdll.dll，但是却找到了fpcmemdll.pp。
打开fpcmemdll.pp后发现，其实这并不是一个普通的用于uses的单元，而是一个library工程单元，那么问题就好办了。
创建一个空白library工程，并命名为fpcmemdll
复制fpcmemdll.pp内容到fpcmemdll.lpr
构建fpcmemdll.lpr得到fpcmemdll.dll
其它 linux平台似乎并没有ShareMem单元，也不存在以上用法，应该是只有windows平台才要这样用。</description>
    </item>
    <item>
      <title>让应用以单例运行</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_single_instance/</link>
      <pubDate>Fri, 26 Jan 2024 22:24:01 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_single_instance/</guid>
      <description>从其它平台迁移而来
有时候我们会期望所编写的应用只运行一个实例，比如监听网络端口或串口，用Lazarus有两种不同的实现方案。
SingleInstanceEnabled属性 SingleInstanceEnabled是TCustomApplication的属性，在初始化之前设置为True即可轻松实现单实例应用：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 program project1; {$mode objfpc}{$H+} uses AdvancedSingleInstance, //注意：必须引用该单元！！！ Interfaces, Forms, ...; {$R *.res} begin Application.SingleInstanceEnabled := True; //注意：必须在调用 Initialize 前赋值！！！ Application.Initialize; ... Application.Run; end. 特别注意 必须引用AdvancedSingleInstance单元，且该单元必须在Interfaces单元和Forms单元前
必须在调用Application.Initialize前赋值
该方法仅针对同一个可执行文件生效，并非系统全局生效
互斥对象 利用操作系统的互斥对象可实现系统级的单例。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var AppMutex: THandle; begin Application.</description>
    </item>
    <item>
      <title>给json数组中的元素排序</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_json_order/</link>
      <pubDate>Tue, 28 Nov 2023 21:38:45 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_json_order/</guid>
      <description>从其它平台迁移而来
起因 基本信息 平台：windows
IDE：Lazarus 2.2.6
json包：FPC自带的fpjson
背景 最近在搞一个小工具，数据文件采用的是json格式，其中一个节点存放的是一组文件的基本信息的清单，这个节点自然就是个json数组，元素就是每个文件基本信息的json对象。界面展示用的是经典的DBGrid + DataSource + DataSet方案，所以会把json数组转为DataSet。
操作过程中会比对磁盘上的文件，该添的添，该删的的删，该改的改，该标记的标记。一番操作下来，顺序自然是乱的，虽然可以操作DataSet或者换用带排序功能的DBGridEh达到排序的目的，但直接看json数据的话，依然是乱序的。因此，期望直接对json数组进行排序。
解决过程 习惯先看源码，如果没有原生解决方案了，或者原生解决方案太别扭了，才会选择第三方解决方案或自己造轮子。
一看源码 1 2 3 4 TJSONArray = class(TJSONData) public ... Procedure Sort(Compare: TListSortCompare); TJSONArray已经提供了排序方法，不过这个参数是什么东西？
1 TListSortCompare = function (Item1, Item2: Pointer): Integer; 嗯，是个函数声明，也就是说具体的算法实现要自己写，可以先找找看有默认的实现没。结果是：没有！那就自己写吧。
看声明，这个函数是要比较两个指针指向的东西，并返回一个整数。嗯，看上去很简单，不过：
到底是怎么实现排序的？
参数是指针，指向的又是什么东西？
返回一个什么样的整数才能实现排序呢？
没懂！！！
还是接着看源码吧：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 procedure TJSONArray.</description>
    </item>
    <item>
      <title>给类型、记录、类添加助手</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_helper/</link>
      <pubDate>Fri, 25 Aug 2023 20:38:35 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_helper/</guid>
      <description>从其它平台迁移而来
通常情况下，类型和记录是没有方法的，只有类有方法，但是可以通过给类型和记录添加助手来达到类似于类的方法的功能，当然，也可以给类添加助手。
语法 1 2 3 HelperName = class|record|type helper[(OptionalBaseHelper)] for TypeName [properties, procedures, functions, constructors, consts, vars] end [hint modifiers]; 类助手 FPC 2.6+版本可用，ObjFPC模式下无需特别设置。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //定义 TObjectHelper = class helper for TObject function SomeFunc: string; end; //实现 function TObjectHelper.SomeFunc: string; begin Result := &amp;#39;类名:&amp;#39; + Self.ClassName; end; //使用 var o: TObject; begin Writeln(o.SomeFunc); end. 一般情况下，给类添加方法可直接在类中添加，但这样添加的方法会直接在所有后代类中显示，如果只是想在特定的范围内添加方法，就可以使用类助手。</description>
    </item>
    <item>
      <title>使用Lazarus压缩/解压zip</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_zip02/</link>
      <pubDate>Sat, 29 Jul 2023 21:31:15 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_zip02/</guid>
      <description>从其它平台迁移而来
Lazarus默认已经提供了zip文件的压缩和解压功能，在Zipper单元中，不过，使用过程中还是有一些细节需要注意。
压缩 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 uses Zipper; { 使用类方法进行压缩 } //压缩单个文件 TZipper.Zip(&amp;#39;压缩后的文件.zip&amp;#39;, &amp;#39;待压缩的文件.txt&amp;#39;); //压缩多个文件 TZipper.Zip(&amp;#39;压缩后的文件.zip&amp;#39;, [&amp;#39;待压缩的文件1.txt&amp;#39;, &amp;#39;待压缩的文件2.pdf&amp;#39;]); { 使用实例对象进行压缩 } var zip: TZipper; zip := TZipper.Create; try //压缩单个文件 zip.ZipFile(&amp;#39;压缩后的文件.zip&amp;#39;, &amp;#39;待压缩的文件.txt&amp;#39;); //压缩多个文件 zip.ZipFiles(&amp;#39;压缩后的文件.zip&amp;#39;, [&amp;#39;待压缩的文件1.txt&amp;#39;, &amp;#39;待压缩的文件2.pdf&amp;#39;]); finally zip.Free; end; 以上为比较方便的使用方法，但是还存在一些问题：
以上仅限于文件名为英文的情况，若文件名为中文则会出现乱码（主要是在windows平台上，用专门的压缩/解压工具打开查看列表和解压时）。查看解决方案。
若待压缩的文件包括路径，则压缩后的文件内也会包含传参时传入的路径。查看解决方案。
另外，也可以配合FileName（压缩后的文件名）和Entries（待压缩的文件）属性使用ZipAllFiles方法；或者配合Entries（待压缩的文件）属性使用SaveToFile方法。不过，多次调用前一定要调用Clear方法，否则就会受前一次压缩操作的影响。
解压 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 uses Zipper; { 使用类方法进行解压 } //解压出全部文件 TUnZipper.</description>
    </item>
    <item>
      <title>ctypes里的bug？</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_ctype/</link>
      <pubDate>Mon, 24 Apr 2023 21:20:06 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_ctype/</guid>
      <description>从其它平台迁移而来
起因 以前使用Delphi调用海康SDK时，专门改写过HCNetSDK.h，当时大部分桌面应用还都是32位的，毕竟64位还没彻底普及开（即便现在，还是有一部分桌面考虑兼容性依然是32位）。后来也搞过64位版的，编译没问题，运行就不成功。虽然没成功，但心里还是清楚这基本上是数据类型的问题，由于对64位了解不多，也就一直搁置着。
转Lazarus之后，又搞过一次64位版，还是没成功。后来知道有ctypes这个单元，也知道这是专门针对c语言数据类型的，但一直没去看过。近来又想起这个事，就想一探究竟。
探 直接看源码，其实就是给pascal的数据类型取了个c的别名。要想了解透彻，自已撸码跑一下还是很有必要的：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 program test; uses SysUtils, ctypes; begin writeln(Format(&amp;#39;%-16s%s&amp;#39;, [&amp;#39;type&amp;#39;, &amp;#39;size&amp;#39;])); writeln(&amp;#39;--------------------&amp;#39;); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cint8&amp;#39;, SizeOf(cint8)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cuint8&amp;#39;, SizeOf(cuint8)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cchar&amp;#39;, SizeOf(cchar)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cschar&amp;#39;, SizeOf(cschar)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cuchar&amp;#39;, SizeOf(cuchar)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cint16&amp;#39;, SizeOf(cint16)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cuint16&amp;#39;, SizeOf(cuint16)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cshort&amp;#39;, SizeOf(cshort)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;csshort&amp;#39;, SizeOf(csshort)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cushort&amp;#39;, SizeOf(cushort)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cint32&amp;#39;, SizeOf(cint32)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cuint32&amp;#39;, SizeOf(cuint32)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cint64&amp;#39;, SizeOf(cint64)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cuint64&amp;#39;, SizeOf(cuint64)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;clonglong&amp;#39;, SizeOf(clonglong)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cslonglong&amp;#39;, SizeOf(cslonglong)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;culonglong&amp;#39;, SizeOf(culonglong)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cbool&amp;#39;, SizeOf(cbool)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cint&amp;#39;, SizeOf(cint)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;csint&amp;#39;, SizeOf(csint)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cuint&amp;#39;, SizeOf(cuint)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;clong&amp;#39;, SizeOf(clong)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cslong&amp;#39;, SizeOf(cslong)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;culong&amp;#39;, SizeOf(culong)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;csigned&amp;#39;, SizeOf(csigned)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cunsigned&amp;#39;, SizeOf(cunsigned)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;csize_t&amp;#39;, SizeOf(csize_t)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cfloat&amp;#39;, SizeOf(cfloat)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;cdouble&amp;#39;, SizeOf(cdouble)])); writeln(Format(&amp;#39;%-16s%d&amp;#39;, [&amp;#39;clongdouble&amp;#39;, SizeOf(clongdouble)])); Readln(); end.</description>
    </item>
    <item>
      <title>FPHTTPClient请求https</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_fphttpclient_https/</link>
      <pubDate>Fri, 17 Feb 2023 20:59:53 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_fphttpclient_https/</guid>
      <description>从其它平台迁移而来
在客户端不需要证书的情况下，简单两步操作即可让TFPHTTPClient实现https的请求：
在源码中引用opensslsockets单元
在生成目录下加入动态库libcrypto-1_1.dll和libssl-1_1.dll</description>
    </item>
    <item>
      <title>Lazarus连数据库的那点坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_connection/</link>
      <pubDate>Sat, 24 Dec 2022 22:03:38 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_connection/</guid>
      <description>从其它平台迁移而来
环境 Lazarus v2.2.4(32位/64位)
MySQL 8.0.31 64位
PostgreSQL 15.1 64位
坑 MySQL Lazarus v2.2.4已内置MySQL8.0的TMySQL80Connection组件，但是连接时却提示Can not load MySQL library &amp;quot;libmysql.dll&amp;quot;. Please check your installation.使用64位编译，放进64位MySQL8.0.31的libmysql.dll仍然报该错，一直到把版本降到5.7系列才正常，换32位编译，同样的结果：使用5.7系列的libmysql.dll可正常使用。
PostgreSQL 连接PostgreSQL时，同样遇到与MySQL类似的报错：Can not load PostgreSQL client library &amp;quot;libpq.dll&amp;quot;. Check your installation.按照与MySQL相同的思路，版本从15.1一直降到目前支持的最低版本9.2.24，仍然报错！
查一下官方论坛，各种方式试了一通，发现64位的程序除libpq.dll外，v11+还需要libcrypto-3-x64.dll、libiconv-2.dll、libintl-9.dll、libssl-3-x64.dll和libwinpthread-1.dll；v9.4~v10.23还需要libcrypto-1_1-x64.dll、libiconv-2.dll、libintl-8.dll、libssl-1_1-x64.dll。
而32位程序，最高可用版本为v10.23，除libpq.dll外，还需要libcrypto-1_1.dll、libiconv-2.dll、libintl-8.dll、libssl-1_1.dll，必要时可能还需要VC运行时。</description>
    </item>
    <item>
      <title>Lazarus的dll卸载问题</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_dll_unload/</link>
      <pubDate>Sat, 10 Dec 2022 22:26:44 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_dll_unload/</guid>
      <description>从其它平台迁移而来
事件 计划做一个插件式的桌面应用框架，一方面练练手，另一方面算是自身的技术积累吧。
在练手过程中，发现一个巨难受的问题，dll卸载不掉，程序直接假死！
虽然可以不直接调用卸载，依赖主程序退出时卸载的特性，但做为插件式应用，必须能在运行中加载/卸载才算完整。即便不是插件式应用，dll的正常卸载也应该是很常用的功能，现在不正常，那么一定是代码写得有问题。
写了测试Demo，一行一行加代码，结果都能正常卸载，这就杯具了……测试了无数次，直到想把每一步都输出到日志时，dll无法卸载了。一点点分析源码后，发现很可能是日志中为了方便使用，加的initialization节和finalization节导致的，注释掉之后就真的正常了。
分析 initialization节应该是在Application.Initialize;时执行的，finalization节应该是在Application.Terminate;之后的某个时间点执行的（具体执行时机没深入研究过）。而我的dll是要做成插件的，不可避免会有可视化窗体，所以Application.Initialize;不可避免（Lazarus是这样，Delphi不是），而在initialization节中创建了日志记录器实例，在finalization节中进行释放，这样，在卸载dll时就出现了锁死的情况：卸载时有内存（实例）未释放，需要等内存释放了才能完全卸载，而未卸载又导致执行不到finalization节，就不能释放实例……于是，dll无法卸载，程序就进入假死状态。
以上只是初步分析，鉴于对底层机制了解不深，可能分析不完全正确，甚至是错误的。
结论 在编写的dll中不要在initialization节和finalization节中进行内存管理的工作。 对于无对象、纯函数式的dll，initialization节和finalization节会不会产生影响尚未测试，目前也暂无这方面需求，待以后遇到了再详细测试吧。</description>
    </item>
    <item>
      <title>Lazarus debug的坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_debug/</link>
      <pubDate>Sun, 20 Nov 2022 23:44:48 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_debug/</guid>
      <description>从其它平台迁移而来
最近在研究Lazarus写dll，已经踩了不少坑了，这下又踩了个不大不小的坑，记录下。
问题 在dll工程里，断点失效，根本没办法调试 解决方案 网上查了N多资料，个中辛酸在此不表，终于找到些蛛丝马迹。
Lazarus在windows上默认使用的是FpDebug内置的Dwarf，这货本身就不支持在dll中调试，法了个克！切换为gdb，立马OK！
不过，据说gdb在windows上有bug，这……反正FpDebug的bug遇到了也不是一个两个了，先用着再说。</description>
    </item>
    <item>
      <title>Lazarus编写dll与接口注意事项小结</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_dll_api/</link>
      <pubDate>Tue, 13 Sep 2022 20:40:27 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_dll_api/</guid>
      <description>从其它平台迁移而来
之前用lazarus编写了使用IInterface的dll，可惜没有成功。当把IInterface编译到exe里时，功能正常，编译到dll里再在exe里调用就不正常，原因未深究，不过大致也知道是哪一类问题，至于还有没有其它问题，暂未可知。
闲来有空，有写了点Demo来，有了不少新发现，在此记录下：
只有使用exports导出的函数才能在dll外部调用
只有使用stdcall修饰的函数传参规则才与标准C的传参规则相同，其它遵守标准C传参规则的语言可以正常调用；否则，只有lazarus编写的程序可以正常调用
入参为string类型时，无论是否使用stdcall修饰，lazarus编写的程序调用正常，其它语言未测试
返回值或出参为string类型时，调用报External: ACCESS VIOLATION错误；但参数为PChar时，调用正常
入参/出参/返回值为结构体时，调用正常
string类型传参是指针/引用拷贝，结构体传参是值拷贝
string做入参时，由主调函数分配内存并增加引用计数，被调函数执行时再次增加引用计数，被调函数结束时减少引用计数，此时引用计数不为0不释放内存，主调函数结束时再次减少引用计数，引用计数为0释放内存，该内存由exe分配，因此释放不报错；做出参时，由被调函数执行时分配内存并增加引用计数，被调函数返回时先赋值给主调函数的变量，增加引用计数，再结束被调函数，减少引用计数，主调函数结束时再次减少引用计数，此时引用计数为0释放内存，但该内存是由dll分配，因此产生External: ACCESS VIOLATION错误
string类型不适合在dll和exe之间传参（尤其是出参）
返回值为对象时，调用异常；入参/出参为exe创建的对象时，调用正常
结论 根据测试得出的结论，可能不严谨：
指针做为形参（入参/出参）传递没有问题，但必须遵守谁创建谁释放的原则；指针做为返回值可能会有隐患
对象传参实际传的是对象的指针，规则与指针相同
返回值适合传递值拷贝的类型，如整型、浮点型、布尔型、结构体、指针（但指针指向的内存要遵守谁创建谁释放的原则，不过一般不直接使用）等
字符串、结构体的生命周期是由编译器维护的，使用需慎重</description>
    </item>
    <item>
      <title>*.frf报表中字段计算的坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/fastreport_frf_calc/</link>
      <pubDate>Wed, 31 Aug 2022 23:40:11 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/fastreport_frf_calc/</guid>
      <description>从其它平台迁移而来
老坑 *.frf是FastReport 2.x的报表模板，现维护的老项目中有使用到该报表。
问题描述 报表通过数据集DS和报表变量V1、V2、V3等获取数据，并在模板中进行展示。
单独展示数据集中的某个字段：[DS.&amp;quot;D1&amp;quot;]
展示数据集中的某两个字段的运算结果：[[DS.&amp;quot;D1&amp;quot;]+[DS.&amp;quot;D2&amp;quot;]]
单独展示某个变量：[V1]
展示数据集中的某个字段与变量的运算结果：[[DS.&amp;quot;D1&amp;quot;]+[V2]]
以上都是没有问题的，但当需要展示两个变量的运算结果时就不行了，[V1]+[V2]实际展示的是两个变量的字符串连接，因为报表变量本来就是字符串。查看模板其它写法，发现有使用尖括号&amp;lt;&amp;gt;的，尝试后也不行，[V1]+&amp;lt;V2&amp;gt;实际展示的只有V2的值。
由于报表变量本身就是字符串，想着通过数据类型转换来解决，但非常遗憾，报表没有提供把字符串转为数值的函数。
实在不行就只能考虑在代码中计算完之后再赋值给报表变量了，但这样就牺牲了报表的灵活性了，乃是没有办法的最后的办法了。
最后灵光一现，既然数据集字段与变量可以运算，那加个0是不是也可以运算？一试果然可行！
结果 展示某两个变量的运算结果：[0+[V1]+[V2]-[V3]] 问题解决了，不过总感觉是个偏方，不晓得正统的解决方案是什么。
不过话说回来，FastReport 2.x已经很古老了，除了老项目维护基本不可能会用到，因为现在连FastReport 3+用得都很少了，毕竟现在已经是什么乱七八糟的牛鬼蛇神都有的元宇宙时代了，能解决问题就好。</description>
    </item>
    <item>
      <title>Lazarus压缩/解压zip乱码问题</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_zip01/</link>
      <pubDate>Wed, 24 Aug 2022 22:10:38 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_zip01/</guid>
      <description>从其它平台迁移而来
Lazarus压缩/解压zip文件可以使用Zipper单元中的TZipper/TUnZipper类来实现，但是在有中文文件名时需要注意，否则会出现乱码。
压缩 TZipper的Zip类方法无需创建实例即可直接生成zip压缩文件。
TZipper实例的ZipFile方法是压缩一个指定的文件生成zip压缩文件，ZipFiles方法是压缩多个指定的文件生成zip压缩文件，UnZipAllFiles方法是配合Entries等属性生成zip压缩文件。
解压 TUnZipper的UnZip类方法无需创建实例即可直接解压zip文件。
TUnZipper实例的UnZipFile方法是解压出一个指定的文件，UnZipFiles方法是解压出多个指定的文件，UnZipAllFiles方法可以从zip文件中解压出所有文件。
乱码 无中文文件名的情况下，以上类方法和实例方法使用都是正常的，与其它压缩/解压工具交叉使用也不会出现问题。
当存在中文文件名时，成对使用以上压缩/解压方法，从结果上来说是没什么问题的，但与其它压缩/解压工具交叉使用时就会出现文件名乱码问题。
乱码其实还是字符编码的问题，Lazarus默认使用UTF8编码，windows默认使用OEM对应的编码，对于中文windows就是GBK编码，于是就出问题了。
解决方案 TZipper有UseLanguageEncoding属性，TUnZipper有UseUTF8属性，均设置为True，再进行压缩/解压即可，因此，类方法是肯定不行的了。
不过，这两个属性在语意上却十分让人费解，因为属性为False时，zip文件头里的文件名实际使用的是UTF8编码，而当属性为True时，zip文件头里的文件名实际使用的却是GBK编码，搞不懂这些老外的想法。
对了，好像要使用FPC 3.2.0+的编译器版本才可以。</description>
    </item>
    <item>
      <title>idhttp POST的坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_idhttp_post/</link>
      <pubDate>Tue, 12 Jul 2022 21:47:37 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_idhttp_post/</guid>
      <description> 从其它平台迁移而来
坑 最近要和一个平台提供的http接口进行对接，由于服务不是部署在公网上的，所以没办法直接在开发环境下直接调试，又不能在客户的测试机上部署开发环境，只能选择加日志这种古老的方法。
在对接过程中却出现了莫名其妙的问题：POST的内容是一样的，但返回的内容却不一样，更准确点说是有的接口返回正常有的返回不正常（其实还是测试有限，测试多的话还会出现同一接口有的请求正常有的不正常）。
平台提供的word接口文档写得真的是……一言难尽，由此也对接口的准确性、可靠性等保持怀疑。不过，这次用我们提供的数据，平台方给出了相应的中间结果（中间结果一致）及返回结果，还有postman和curl的测试截图，充分证明接口以及数据请求是没有问题的。
在客户测试机上装了curl测试也证明接口没问题。（问为什么一开始没想到用curl？因为windows默认没有，而且utf8还会显示乱码，习惯性的就没想起来用）
请求头也改了，没用一样的效果。
最后实在找不出问题，就只能进行TCP抓包了，这一抓还就真抓出问题了：
原始数据
1 /knwRBV5D4Qtk7RzoQhtBUSMXQig3zURYmeSQBB17NVr6qddCkTxS7e0oO/qfNCkuX14vGsxEoLLN4KS5vtQWDs5on+GeAE5LadCZuHDCe7M25GitNKqnsCfC5qVmti1LyxLxYg2JpLP6GylWERWBOmbP2yO2Aiuey6V526rlRICnidM1W0A4ziNMSjGCng0n5Md4so/RjswNdcE4C5F0kBEGRWH0ZK+QdkZMs4zL84Pu/aiSMpiID9Mm+jtdLZuk0m0UtEd1MmxnU2KPdQz9057JAtM5LIj4YenZl3J86OPWtb9DE6a+410CWBawZY1vItZ+43Kh/QPnkw6Qe4toXRnF84X/ijtiWkTt4moJT87xDpf/TXEd7LRkddWPRRGF3KHnUKacLySwMmXkU6CQMazE1Kh1ZGML6zl1weaq4xVulFwhGfp2XKzYdZfT3uq4yqVr30AaEqYoy2/P1MkhTs5on+GeAE54r939gdklpefguipLJVBpWk/B5S9QsCDxDbfGYNxJo3rIAxDL7sjjlmVL1RjU86sHsNIbmRii7dL70pf5qcIMJzryGmtn94SAE2HjLw0abfr0A9amRsdIzs5on+GeAE5RIxdCKDfNRFnPqLzNU5stMSDcpuafJpNhUXDbQOMlPungXJHHZAgbE2XtoI4geIRYjiyBLDMQuB0l5WvfDhpRnYo1VaEu7J0tRuezwUplK61p4I8giLwAtO+yNMRV+J65g9XaT8vmf8gxmtK3wEFrve7HwsYH0QhlQQiMilY/JVsiHZS6+ID/w== 发送后抓到的却是
1 /knwRBV5D4Qtk7RzoQhtBUSMXQig3zURYmeSQBB17NVr6qddCkTxS7e0oO/qfNCkuX14vGsxEoLLN4KS5vtQWDs5on+GeAE5LadCZuHDCe7M25GitNKqnsCfC5qVmti1LyxLxYg2JpLP6GylWERWBOmbP2yO2Aiuey6V526rlRICnidM1W0A4ziNMSjGCng0n5Md4so/RjswNdcE4C5F0kBEGRWH0ZK+QdkZMs4zL84Pu/aiSMpiID9Mm+jtdLZuk0m0UtEd1MmxnU2KPdQz9057JAtM5LIj4YenZl3J86OPWtb9DE6a+410CWBawZY1vItZ+43Kh/QPnkw6Qe4toXRnF84X/ijtiWkTt4moJT87xDpf/TXEd7LRkddWPRRGF3KHnUKacLySwMmXkU6CQMazE1Kh1ZGML6zl1weaq4xVulFwhGfp2XKzYdZfT3uq4yqVr30AaEqYoy2/P1MkhTs5on+GeAE54r939gdklpefguipLJVBpWk/B5S9QsCDxDbfGYNxJo3rIAxDL7sjjlmVL1RjU86sHsNIbmRii7dL70pf5qcIMJzryGmtn94SAE2HjLw0abfr0A9amRsdIzs5on+GeAE5RIxdCKDfNRFnPqLzNU5stMSDcpuafJpNhUXDbQOMlPungXJHHZAgbE2XtoI4geIRYjiyBLDMQuB0l5WvfDhpRnYo1VaEu7J0tRuezwUplK61p4I8giLwAtO+yNMRV+J65g9XaT8vmf8gxmtK3wEFrve7HwsYH0QhlQQiMilY/JVsiHZS6+ID/w=%3D 最后的=被转码为%3D了！
解决 找到原因就好办了
1 2 //idhttp.HTTPOptions := [hoForceEncodeParams]; //默认强制对参数进行转码 idhttp.HTTPOptions := []; //去掉就OK了 </description>
    </item>
    <item>
      <title>Lazarus构造/析构等方法的执行顺序</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_order/</link>
      <pubDate>Fri, 24 Jun 2022 22:53:40 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_order/</guid>
      <description>从其它平台迁移而来
AfterConstruction、BeforeDestruction是TObject本身就有的方法，Loaded是从TComponent才有的方法，好好利用的话就可以更精准的控制对象的生命周期或者初始化/清理工作。虽然知道这点，而且也经常在自己的程序中使用，但还是会经常搞错执行顺序，因此专门记录一下以备忘备查。
Form graph TD f1[inherited Create 前] --&gt; f2[inherited Loaded 前] --&gt; f3[inherited Loaded 后] --&gt; f4[inherited Create 后] --&gt; f5[inherited AfterConstruction 前] --&gt; f6[FormCreate] --&gt; f7[inherited AfterConstruction 后] --&gt; f8[FormResize] --&gt; f9[FormShow] --&gt; f10[FormCloseQuery] --&gt; f11[FormClose] --&gt; f12[inherited BeforeDestruction 前] --&gt; f13[FormHide] --&gt; f14[FormDestroy] --&gt; f15[inherited BeforeDestruction 后] --&gt; f16[inherited Destroy 前] --&gt; f17[inherited Destroy 后] DataModule graph TD d1[inherited Create 前] --&gt; d2[inherited Loaded 前] --&gt; d3[inherited Loaded 后] --&gt; d4[inherited Create 后] --&gt; d5[inherited AfterConstruction 前] --&gt; d6[DataModuleCreate] --&gt; d7[inherited AfterConstruction 后] --&gt; d8[inherited BeforeDestruction 前] --&gt; d9[DataModuleDestroy] --&gt; d10[inherited BeforeDestruction 后] --&gt; d11[inherited Destroy 前] --&gt; d12[inherited Destroy 后] Frame graph TD f1[inherited Create 前] --&gt; f2[inherited Loaded 前] --&gt; f3[inherited Loaded 后] --&gt; f4[inherited Create 后] --&gt; f5[inherited AfterConstruction 前] --&gt; f6[inherited AfterConstruction 后] --&gt; f7[FrameResize] --&gt; f8[inherited BeforeDestruction 前] --&gt; f9[inherited BeforeDestruction 后] --&gt; f10[inherited Destroy 前] --&gt; f11[inherited Destroy 后] 总结 Loaded是在Create的过程执行的，应该是用来做一些加载资源之类或其它辅助构造的工作</description>
    </item>
    <item>
      <title>Lazarus速查</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_info/</link>
      <pubDate>Thu, 23 Jun 2022 22:55:57 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_info/</guid>
      <description>从其它平台迁移而来
Package-&amp;gt;Install/Uninstall Packages AnchorDockingDsgn：安装后转为一体式IDE
LazActiveX：安装后可安装ActiveX组件
lazdaemon：可开发windows服务
lazprojectgroups：使IDE支持工程组
lazvlc：VLC 播放器组件，需要V2版本以上的libvlccore.dll和libvlc.dll
Package-&amp;gt;Online Package Manager DBTreeViewAndDBCntrlGrid：可从数据集中把树型数据直接显示为树
DCPcrypt：常用加密/解密，如DES、3DES、AES、RC2、RC4、RC5、RC6、MD4、MD5、SHA1、SHA256、SHA384、SHA512等
自带单元 fpjson、jsonscanner、jsonparser：自带JSON
jsonConf：JSON配置
fphttpclient：HTTP客户端
fphttpserver：HTTP服务端
base64：BASE64编码/解码
md5：MD2、MD4、MD5算法
sha1：SHA-1(RFC 3174)算法
crcCRC32、CRC64和CRC128算法
开源库 dataset-serialize：数据集与JSON序列化/反序列化
CEF4Delphi：谷歌浏览器内核，依赖DCPcrypt</description>
    </item>
    <item>
      <title>Lazarus报Error: Undefined symbol</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_undefined_symbol/</link>
      <pubDate>Mon, 06 Jun 2022 21:59:18 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_undefined_symbol/</guid>
      <description>从其它平台迁移而来
在使用Lazarus编写动态库的过程中遇到了报Error: Undefined symbol:错误的问题，死活编译不过去，加了LCL包依赖也不行，找了N久终于在一个英文网站上找到了解决办法。
Error: Undefined symbol:错误会依据所写的代码用到的单元不同而有一定的差异，我遇到的报错大致如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 project1.lpr(18,1) Error: Undefined symbol: WSRegisterCustomImageListResolution project1.lpr(18,1) Error: Undefined symbol: WSRegisterMenuItem project1.lpr(18,1) Error: Undefined symbol: WSRegisterMenu project1.lpr(18,1) Error: Undefined symbol: WSRegisterMainMenu project1.lpr(18,1) Error: Undefined symbol: WSRegisterPopupMenu project1.lpr(18,1) Error: Undefined symbol: WSRegisterDragImageListResolution project1.lpr(18,1) Error: Undefined symbol: WSRegisterLazAccessibleObject project1.lpr(18,1) Error: Undefined symbol: WSRegisterControl project1.lpr(18,1) Error: Undefined symbol: WSRegisterWinControl project1.lpr(18,1) Error: Undefined symbol: WSRegisterGraphicControl project1.</description>
    </item>
    <item>
      <title>慎用 out</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_use_out/</link>
      <pubDate>Wed, 15 Dec 2021 11:29:07 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_use_out/</guid>
      <description>从其它平台迁移而来
最近需要评估一下海康摄像头不同抓拍方式的性能，以及封装类的可靠性。
在测试过程中，又发现了当初遇见的设备内存抓拍报错的问题。当初排查的结论是：当封装类开启预览的情况下，使用设备抓图有较高概率抓拍失败。由于预览是必需的，最终选择了预览抓拍。
现在，换用lazarus进行测试，发现设备抓图必失败，与是否预览无关。一点点调试，发现直接调用SDK原始方法进行设备抓图正常，使用封装类的设备抓图就不行，那肯定是封装类出了问题。
最终发现，封装类的设备抓图使用了out来修饰参数，参数是TMemoryStream和TJPEGImage对象，尝试去掉out修饰符，然后就一切正常了。
记得很久前专门研究过out和var修饰符的区别，当时查阅的结果是：out和var修饰的参数都是传址的，区别是out会对参数进行初始化，而var则不会。
另外，参数为对象的情况，实际也是传址的。
本次发现的问题可能就是使用out来修饰对象参数导致的，但并没有进行进一步的测试。
附 测试环境 操作系统：win10
硬盘：SSD
测试结果 子码流预览抓图，耗时毫秒级；主码流预览抓图，耗时10+毫秒级
预览抓图比设备拍图耗时少得多，设备抓图在100+毫秒级
在相同分辨率情况下，预览抓图的文件大小比设备抓图的略大</description>
    </item>
    <item>
      <title>配置Lazarus免重装</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/lazarus_install/</link>
      <pubDate>Sun, 10 Oct 2021 11:21:03 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/lazarus_install/</guid>
      <description>从其它平台迁移而来
事件 过了个十一，原本好好的电脑，突然鼠标不能用了，本着重启能解决80%的问题的原则重启了下，结果就杯具了，直接就蓝屏了，怎么折腾都进不了系统，BUG 10果然是BUG 10，绝对名不虚传！
无奈，只剩下重装系统这一条路了，装完系统之后还要装一堆软件，还要把软件配置成自己的习惯，还有其它一些细节工作……要把这些都做完才能大致恢复到原先的样子，想想就各种不爽。
虽然已经尽可能的使用免安装/重装的软件了，但还是避免不了有一些软件必须要重装才能使用的情况，唉~
其中最令人头疼的就是开发环境了，几乎绝大部分都要重装，Lazarus就是其中之一，先前已经尝试过了，离成功只差一步了，这次终于搞定了，记录下来。
免重装 正常安装Lazarus
首次启动Lazarus会弹出初始配置界面，关闭
打开Lazarus的根安装目录，新建一个config文件夹
打开C:\Users\xxx\AppData\Local\lazarus文件夹(xxx为用户名)，复制里面所有内容到config
找到Lazarus的快捷方式，右键属性，在目标里原有内容后面添加 --pcp=.\config(注意前面有空格)，确定
把修改好的快捷方式复制到Lazarus的根安装目录下，供以后使用
删除C:\Users\xxx\AppData\Local\lazarus文件夹
使用刚才的快捷方式启动Lazarus，进行个性化设置、安装组件等
以后重装系统了直接使用快捷方式启动Lazarus即可
如果安装的组件全部都在Lazarus的安装目录下，整个Lazarus的安装目录即为一个便携式的IDE了
为避免如果使用过程中出现莫名其妙的现象，建议把Lazarus的安装目录下的ssleay32.dll、libeay32.dll、Qt5Pas1.dll和Qt4Pas5.dll复制到C:\Windows\System32或C:\Windows\SysWOW64下
本文参考了https://blog.csdn.net/love3s/article/details/7450339
附 在命令行进入Lazarus的根安装目录，运行lazarus.exe -?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 lazarus [options] &amp;lt;project-filename&amp;gt; IDE Options: --help or -?</description>
    </item>
    <item>
      <title>踩坑记：DBGridEh中取Footer的Sum值</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/ehlib_dbgrideh_footer_sum/</link>
      <pubDate>Wed, 24 Mar 2021 16:26:13 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/ehlib_dbgrideh_footer_sum/</guid>
      <description>从其它平台迁移而来
DBGridEh算是Delphi中比较好用的第三方数据感知组件了，但其中有些小坑是真的有点小无语的。
场景 客户需要的有这样一组数据，大部分列是要求和的，用DBGridEh的Footer是轻松加愉快的；但是个别列是和每一行的计算方法一致的，用求和反倒是大错特错的，所以要求针对这些个别列按照给定的算法进行计算后显示在Footer中。
坑 Footer有个ValueType和Value属性，汇总类型是通过ValueType设置的，习惯性的以为汇总值是通过Value来读写的。
然而，事实并非如此！
对于求和列，DBGridEh1.Columns[i].Footer.Value的值一直是&#39;&#39;空串，要想取得求和列的汇总值，正确的打开方式是DBGridEh1.GetFooterValue(0,DBGridEh1.Columns[i])！这简直是反人类啊有木有！
后记 这是第二次踩这个坑了，记录下，给自己长点记性！事不过三！！
另外，公司使用的版本比较老，新版本可能没有这些问题了，不太清楚，暂时没空去求证。</description>
    </item>
    <item>
      <title>安装 CodeTyphon</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/codetyphon_install/</link>
      <pubDate>Sun, 07 Feb 2021 09:29:48 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/codetyphon_install/</guid>
      <description>从其它平台迁移而来
一直想找个开源的可以商用的Delphi的替代品，能跨平台了最好。开始时试过Lazarus，和D7还真是挺像的，不过用惯了XE，还是想找个习惯相似的IDE，扒拉下论坛后发现了CodeTyphon，就想着试一下。
下载 下载就不多说了，网上很容易找到，而且官方wiki写得也很好，英文好的可以直接看，像我这样的英语渣渣，还是有必要慢慢去啃的。
CodeTyphon下载后只有一个CodeTyphonIns.zip的压缩包，无论是Windows、Linux还是MacOS，安装包都是它，因为不管在哪个平台上安装，都是要编译的。
安装 解压CodeTyphonIns.zip得到CodeTyphonIns
在Windows平台，以管理员方式运行install.bat；在类unix平台，先cd CodeTyphonIns，再sudo ./install.sh
出现以下界面，输入0
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ==================================================== CodeTyphon Studio Version 7.30 (GEN 7) Installation for Linux-Solaris-Openindiana-MacOS FreeBSD-NetBSD-OpenBSD-DragonFly ==================================================== -----WARNING------ WARNING ----WARNING------- You tryng to install CT as root This is NOT the correct procedure. You MUST start CodeTyphon Installation as normal user with sudo root privileges --------------------------------------------- 0) Install CodeTyphon Studio (remove old first) 1) Update CodeTyphon Studio 2) Remove CodeTyphon Studio 9) Exit &amp;gt;&amp;gt;&amp;gt; Select an action (press 0.</description>
    </item>
    <item>
      <title>自学RTC——DualServer</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc_dual_server/</link>
      <pubDate>Sun, 22 Nov 2020 14:54:39 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc_dual_server/</guid>
      <description>从其它平台迁移而来
在窗体上放4个TRtcHttpServer，依次设置ServerPort为：80、443、8080和8090，并分别命名为HS80、HS443、HS8080和HS8090
再放3个TRtcDualDataServerLink到窗体上，分别命名为DL80and443、DL8080and8090和DLall
设置DL80and443的Server属性为HS80，Server2属性为HS443；设置DL8080and8090的Server属性为HS8080，Server2属性为HS8090
设置DLall的Link属性为DL80and443，Link2属性为DL8080and8090
再放1个TRtcDataProvider到窗体上，设置Link属性为DLall，并在OnCheckRequest事件里写上代码：
1 2 3 4 5 with TRtcDataServer(Sender) do begin Accept; Write(&amp;#39;you are on Server &amp;#39; + ServerPort); end; 在窗口OnShow事件里启动所有TRtcHttpServer，在OnClose事件里停止所有TRtcHttpServer
编译运行
在浏览器里分别访问http://localhost:80、http://localhost:443、http://localhost:8080、http://localhost:8090
注意：TRtcDualDataServerLink只能选择设置Server*或Link*！</description>
    </item>
    <item>
      <title>RTC组件关系图</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc/</link>
      <pubDate>Tue, 10 Nov 2020 21:26:27 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc/</guid>
      <description>从其它平台迁移而来</description>
    </item>
    <item>
      <title>自学RTC——BrowserUpload</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc_browser_upload/</link>
      <pubDate>Tue, 10 Nov 2020 20:04:07 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc_browser_upload/</guid>
      <description>从其它平台迁移而来
核心代码 OnCheckRequest事件中的代码： 1 2 3 with TRtcDataServer(Sender) do if Request.FilePath.Equal(0, &amp;#39;UPLOAD&amp;#39;) then Accept; OnDataReceived事件中的代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 var fname: string; cnt: integer; begin with TRtcDataServer(Sender) do begin if Request.</description>
    </item>
    <item>
      <title>自学RTC——ServerLesson4</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson4/</link>
      <pubDate>Sat, 07 Nov 2020 23:47:54 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson4/</guid>
      <description>从其它平台迁移而来
对于上节的示例中，比较适合发送小文件，若直接用于发送大文件的话，很容易把服务器的内存资源耗尽。当请求大文件时，可以限制每次发送大文件时使用的内存大小（例如16000 B）。
打开上节的工程
修改RtcDataProvider3的OnCheckRequest事件：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var fname: string; begin with TRtcDataServer(Sender) do begin fname := GetFullFileName(Request.FileName); if (fname &amp;lt;&amp;gt; &amp;#39;&amp;#39;) and (File_Exists(fname)) then begin Accept; Request.Info[&amp;#39;fname&amp;#39;] := fname; Response.ContentLength := File_Size(fname); WriteHeader; end; end; end; 修改RtcDataProvider3的OnDataReceived事件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var fname: string; len: cardinal; begin with TRtcDataServer(Sender) do if Request.</description>
    </item>
    <item>
      <title>自学RTC——ServerLesson3</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson3/</link>
      <pubDate>Sat, 07 Nov 2020 20:27:36 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson3/</guid>
      <description>从其它平台迁移而来
/test.txt 打开上节的工程
添加组件RtcDataProvider3并设置Server属性为RtcHttpServer1，设置CheckOrder属性为900，使得RtcDataProvider3所处理的请求在其它请求之后（CheckOrder越小越先处理）
在当前exe所在路径下创建一个data文件夹，并在该文件夹内新建一个有内容的test.txt，然后编写一个GetFullFileName函数，用于从请求中提取文件名并转化为本地文件名
1 2 3 4 5 6 7 8 9 10 11 12 13 function GetFullFileName(fname: string): string; var DocRoot: string; begin DocRoot := ExtractFilePath(AppFileName); if Copy(DocRoot, length(DocRoot), 1) = &amp;#39;\&amp;#39; then Delete(DocRoot, length(DocRoot), 1); DocRoot := DocRoot + &amp;#39;\data&amp;#39;; fname := StringReplace(fname, &amp;#39;/&amp;#39;, &amp;#39;\&amp;#39;, [rfreplaceall]); Result := ExpandFileName(DocRoot + fname); if UpperCase(Copy(Result, 1, length(DocRoot))) &amp;lt;&amp;gt; UpperCase(DocRoot) then Result := &amp;#39;&amp;#39;; end; 在RtcDataProvider3的OnCheckRequest事件中写上代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 var fname: string; begin with TRtcDataServer(Sender) do begin fname := GetFullFileName(Request.</description>
    </item>
    <item>
      <title>自学RTC——ServerLesson2</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson2/</link>
      <pubDate>Thu, 05 Nov 2020 23:34:37 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson2/</guid>
      <description>从其它平台迁移而来
/SQUARE 打开上节的工程
添加组件RtcDataProvider2并设置Server属性为RtcHttpServer1
在RtcDataProvider2的OnCheckRequest事件中写上代码：
1 2 3 with TRtcDataServer(Sender) do if UpperCase(Request.FileName)=&amp;#39;/SQUARE&amp;#39; then Accept; 在RtcDataProvider2的OnDataReceived事件中写上代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var line:integer; begin with TRtcDataServer(Sender) do if Request.Complete then begin Write(&amp;#39;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;#39;); Write(&amp;#39;Here comes a table of square values ... &amp;lt;br&amp;gt;&amp;#39;); for line:=1 to 100 do begin // 使用3个 write 和使用1个效果是一样的 Write(&amp;#39;Square of &amp;#39;+IntToStr(line)+&amp;#39; = &amp;#39;); Write(IntToStr(line*line)); Write(&amp;#39;&amp;lt;br&amp;gt;&amp;#39;); end; Write(&amp;#39;.</description>
    </item>
    <item>
      <title>自学RTC——ServerLesson1</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson1/</link>
      <pubDate>Thu, 05 Nov 2020 20:51:13 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/rtc_server_lesson1/</guid>
      <description>从其它平台迁移而来
RTC全称RealThinClient，据说是Delphi做三层的神器之一，虽然听说已久，却始终未好好研究过，而且安装包里带的有示例源码，于是乎，索性拿这些源码开这么个系列，督促下自己。
步骤 创建一个新工程
从RTC Server组件页中找到RtcHttpServer组件放到窗体上
设置RtcHttpServer1的ServerPort属性为80
在窗体的OnCreate事件里写上代码：
1 RtcHttpServer1.Listen; 从RTC Server组件页中找到RtcDataProvider组件放到窗体上
设置RtcDataProvider1的Server属性为RtcHttpServer1
在RtcDataProvider1的OnCheckRequest事件中写上代码：
1 2 3 with Sender as TRtcDataServer do if UpperCase(Request.FileName)=&amp;#39;/TIME&amp;#39; then Accept; 在RtcDataProvider1的OnDataReceived事件中写上代码： 1 2 3 with Sender as TRtcDataServer do if Request.Complete then Write(&amp;#39;Current time is: &amp;#39;+TimeToStr(Now)); 编译并运行
打开浏览器，访问网址http://localhost/time
示例源码 核心源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 procedure TForm1.</description>
    </item>
    <item>
      <title>FireDAC的数据连接池</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/firedac_fdconnection_pool/</link>
      <pubDate>Tue, 11 Aug 2020 21:59:09 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/firedac_fdconnection_pool/</guid>
      <description>从其它平台迁移而来
之前就想搞个数据连接池，结果太麻烦就放弃了，不想却在TFDConnection中看到了Pooled属性，就一路挖了下来，还真就是那么回事！
TFDManager 之前只知道，放上TFDManager控件后，什么都不用做，就可以在别的单元引用该单元后直接连接到TFDConnection控件了；现在，数据连接池还是要通过TFDManager来实现。
设置数据连接池参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //指定动态库 FDPhysMySQLDriverLink.VendorLib := &amp;#39;libmysql.dll&amp;#39;; //设置连接参数 with FDManager.ConnectionDefs.AddConnectionDef do begin Name := &amp;#39;MySQL_Conn&amp;#39;; Params.DriverID := &amp;#39;MySQL&amp;#39;; Params.Add(&amp;#39;CharacterSet=csUtf8mb4&amp;#39;); Params.Add(&amp;#39;Server=127.0.0.1&amp;#39;); Params.Add(&amp;#39;Port=3306&amp;#39;); Params.Database := &amp;#39;test&amp;#39;; Params.UserName := &amp;#39;root&amp;#39;; Params.Password := &amp;#39;123456&amp;#39;; Params.PoolMaximumItems := 10; Params.Pooled := True; end; 以上是以MySQL为例，其它数据库参照即可。
打开连接池 1 FDManager.Open; 获取连接 1 2 FDConnection.ConnectionDefName := &amp;#39;MySQL_Conn&amp;#39;; FDConnection.Connected := True; 归还连接 FDConnection直接放到窗体上，或动态创建，写上如下代码即可，无需在设计器里设置任何东西。</description>
    </item>
    <item>
      <title>从.h头文件到.pas单元</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/h2pas/</link>
      <pubDate>Mon, 04 May 2020 23:42:53 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/h2pas/</guid>
      <description>从其它平台迁移而来
由于长期使用Delphi开发，又与硬件打交道比较多，不可避免地要与标准C动态库进行对接，而往往厂家提供的SDK又偏偏没有Delphi的，无奈也就只好自己改写.h头文件了。写得多了，也就有了一点点心得，在这里就分享出来，也好与大家互相交流、学习。
知识点 标准C动态库使用的都是单字节字符。
Delphi 2007以前默认使用的是单字节字符，即Ansi编码，也就是说Char = AnsiChar、PChar = PAnsiChar、string = AnsiString；Delphi 2009以后使用的是双字节字符，即Unicode编码，也就是说Char = WideChar、PChar = PWideChar、string = WideString。为了保证改写后的.pas文件适用于Dephi的各个版本，应避免使用Char、PChar、string这种类型不明确的数据类型（通常情况下使用AnsiChar、PAnsiChar、AnsiString即可，但特殊情况要特殊处理）。
@string[1]才是字符串首地址。
Delphi中可以把AnsiString当作缓冲区来使用，某些情况下比array of Byte要方便得多。
对字符串变量第一次使用SetLengh时会重新分配内存，第二次使用时，若设定的长度比第一次小，则只会进行截断而并不改变已写入的内容，该特性在使用API返回字符串时非常好用。
Delphi中的record是进行过字节对齐的，执行效率高，但占用空间比看到的会略大；packed record是未进行过字节对齐的，执行效率略低，但占用空间与看到的保持一致。也就是说，Delphi中packed record才是与C中的struct等同。
在Delphi中packed record配合case可以实现C中的union，具体是否等同还要看实际定义的字节是否一致（需要对每种数据类型占用的空间十分熟悉）。
标准C动态库的API函数或回调函数，在Delphi中均要使用stdcall;来修饰，以确保传参顺序一致。
数据类型对应关系 C/C++ 类型 Delphi 基本类型 Delphi Window 单元类型 说明 char ShortInt / Int8 8位有符号整型 char* PShortInt unsigned char / BYTE Byte / UInt8 UCHAR 8位无符号整型，字节型 unsigned char* PByte LPBYTE / PUCHAR short SmallInt / Int16 SHORT 16位有符号整型 short* PSmallInt PSHORT unsigned short Word / UInt16 WORD 16位无符号整型 unsigned short* PWord PUSHORT int / long Integer / Longint / Int32 LONG 32位有符号整型 int* / long* PInteger / PLongInt PLONG unsigned / unsigned int / unsigned long Cardinal / LongWord / UInt32 DWORD / UINT / ULONG / ULONG32 32位无符号整型 unsigned int* / unsigned long* PCardinal / PLongWord / PUint32 PDWORD / PUINT / PULONG long long / __int64 Int64 LONG64 / LONGLONG 64位有符号整型 long long* / __int64* PInt64 PLONG64 unsigned long long / unsigned __int64 UInt64 ULONG64 / ULONGLONG / DWORD64 64位无符号整型 unsigned long long* / unsigned __int64* PUInt64 PULONG64 / PULONGLONG / PDWORD64 float Single / Float32 32位单精度浮点型 float* PSingle double Double / Float64 64位双精度浮点型 double* PDouble long double Extended 10字节浮点型 char AnsiChar 单字节字符 char* PAnsiChar LPSTR / LPCSTR char** PPAnsiChar wchar_t / WCHAR WideChar WCHAR 双字节字符 wchar_t* PWideChar PWChar / LPWSTR / LPCWSTR wchar_t** PPWideChar 任意1字节类型 Boolean / ByteBool 1字节布尔型 任意1字节类型指针 PBoolean / PByteBool 任意2字节类型 WordBool 2字节布尔型 任意2字节类型指针 PWordBool BOOL LongBool BOOL 4字节布尔型 BOOL* PLongBool PBOOL void* Pointer PVOID / LPVOID / LPCVOID 无类型指针 void** PPointer PPVOID 升华 有了以上知识，把.</description>
    </item>
    <item>
      <title>Delphi开发守则</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_rules/</link>
      <pubDate>Thu, 12 Mar 2020 22:39:03 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_rules/</guid>
      <description>从其它平台迁移而来
前言 接触编程已十年有余，使用Delphi谋生也已五年有余，不敢说阅码无数，实实在在看过的代码也是有几箩筐的，但见过的写得好的、写得漂亮的、写得优美的代码，少之又少。
由于pascal语言简单易学的优点，以及DelphiIDE快速开发的方便，致使随便来个阿猫阿狗搞几下就能搞出来个马马虎虎的东西，于是众多程序猿便借势野蛮生长，个个都长得很有个性，产出的代码也自然是个性十足。事实上，其它语言的这种现象也不少。
我无意发起圣战，毕竟每只猿都有自己的追求，而我，不过是长成了一只有点洁癖的猿。以下是我的洁癖，也是我的追求，算是总结，也算是对自己的警醒。
正文 排版 良好的排版能使代码看起来清晰愉悦，统一的排版能使团队合作愉快，也更能显出版本控制优势。
简单来说，cnPack提供的排版功能就不错。我喜欢在默认的基础上做如下调整：
关键字小写。因为小写比大写更易阅读。
begin 位于下一行。因为能突出代码块的起始位置。
当超过90列时自动换行于80列。因为我的屏幕有点小，而且我个人也比较懒，再加上一点点历史原因。
字符串拼接等不希望cnPack自动排版的地方，可在末尾加//单行注释进行妨碍。写过长SQL语句的都知道我在说什么。
注释 注释很重要，但注释也可以很美妙。比如：interface区主要使用xml风格的注释，implementation区主要使用默认风格的注释，具体如下：
函数、过程、类方法、类属性、结构体方法的声明使用xml风格的注释，注释在上，声明在下。当你把鼠标放上去的时候你就知道我是对的。
枚举成员、类字段、结构体字段使用//单行注释，注释在右，且同一代码块尽量缩进对齐。无他，我有洁癖。
xml风格的注释，我喜欢的格式如下，至于怎么设置，我想这不是问题。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 {func} /// &amp;lt;summary&amp;gt;|&amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n1&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;n2&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; {param} /// &amp;lt;param name=&amp;#34;|&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; {remarks} /// &amp;lt;remarks&amp;gt;|&amp;lt;/remarks&amp;gt; {returns} /// &amp;lt;returns&amp;gt;|&amp;lt;/returns&amp;gt; {seealso} /// &amp;lt;seealso&amp;gt;|&amp;lt;/seealso&amp;gt; {summary} /// &amp;lt;summary&amp;gt;|&amp;lt;/summary&amp;gt; {value} /// &amp;lt;value&amp;gt;|&amp;lt;/value&amp;gt; 命名 什么拼音首字母，什么1 2 3 4 5，我是极其痛恨的！</description>
    </item>
    <item>
      <title>从Delphi到Go——接口</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_interface/</link>
      <pubDate>Thu, 30 Jan 2020 12:52:16 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_interface/</guid>
      <description>从其它平台迁移而来
由于没有太多编写接口的经验，此处仅简单说明语法。后期对接口有更多认知和经验后再进行详细记录。
Delphi Delphi的接口是侵入式接口，并且是单继承的，但类可以同时实现多个接口，类声明时需要显示声明实现了哪些接口。
声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type //直接声明 IMyInterface1 = interface function Func1: Integer; //函数 procedure Proc1(Value: Integer); //过程 property MI: Integer read Func1 write Proc1; //属性 end; //从已有接口继承 IMyInterface2 = interface(IMyInterface1) procedure Proc2; end; //含有 GUID 的接口可以公开给其它进程调用 IMyInterface3 = interface [&amp;#39;{3E51374A-D0E8-4C84-AA30-9634409E45DD}&amp;#39;] procedure Proc3; end; Delphi已经提供了基接口IInterface，自己声明的接口最好从IInterface继承。
实现 1 2 3 4 5 6 7 8 9 10 11 type //含接口的类的声明 TMyClass = class(基类, 接口) public procedure Proc; //接口方法 end; //接口实现 procedure TMyClass.</description>
    </item>
    <item>
      <title>简单数学运算的比较</title>
      <link>https://afrusrsc.github.io/posts/program/misc/float_precision_calc/</link>
      <pubDate>Wed, 01 Jan 2020 22:37:24 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/misc/float_precision_calc/</guid>
      <description>从其它平台迁移而来
人到中年，总是不免生出些危机感，长年使用Delphi，心中自是不踏实，闲来便看两眼java，不想却发现个从未注意过的小问题。
java 1 2 3 4 5 double a = 1 / 10; //0.0 double b = 1.0 / 10; //0.1 double c = 1 / 10.0; //0.1 double d = 1 - 9.0 / 10; //0.09999999999999998 double e = 1 - 9 / 10; //1.0 Delphi 1 2 3 4 5 a := 1 / 10; //0.1 b := 1.0 / 10; //0.1 c := 1 / 10.</description>
    </item>
    <item>
      <title>Delphi中的延时</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_delay/</link>
      <pubDate>Fri, 13 Dec 2019 23:40:41 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_delay/</guid>
      <description>从其它平台迁移而来
开发过程中经常会需要使用到延时功能，Delphi中有不少实现延时的方法，网上已有不少文章做过说明和分析，但本着实践出真知的态度，还是亲自动手研究一番心里比较踏实。
常用的延时方法 Sleep Sleep(n)，延时n毫秒，延时过程中程序不响应，一般延时较小时使用。
在主线程中使用，延时较大（100+）的话会起程序假死，一般在子线程中使用较多。
无论在主线程还是子线程中，延时较长的话（如 2000 ms），一般不一次性Sleep(2000)，而是分多次循环Sleep。有时为了能在延时过程中响应外部消息，还会加上Application.ProcessMessages;，如：
1 2 3 4 5 6 //延时 2000 ms for i := 0 to 19 do begin Sleep(100); Application.ProcessMessages; end; Timer Timer为定时器，用于周期性地执行某个处理。也可用来实现延时，延时过程中不会引起程序假死，
GetTickCount GetTickCount返回从操作系统启动到当前所经过的毫秒数，一般用于计算代码段的用时。配合循环使用也可达到延时的功能。
1 2 3 4 n := GetTickCount; repeat Application.ProcessMessages; //若延时过程中需要响应消息可加上此句 until GetTickCount &amp;gt;= n + ms; //ms为延时的毫秒数 注意：使用以上代码进行延时的过程中，CPU使用率会异常地高（事实上，不加限制一直跑的循环都会导致CPU使用率过高）。
小结 以上是对Sleep、Timer和GetTickCount用于延时的简单说明，个人经验：通常较小延时的场景用Sleep，较大延时的场景用Timer，评估代码段耗时的场景用GetTickCount。至于为什么这样用，以前是不清楚的，但通过对三者的精度分析，目前已知晓来龙去脉。
延时精度分析 上文已经提到，一般用GetTickCount来分析代码段耗时，但由于本次GetTickCount在被测行列，故另寻他法。
本次测试假定系统时间是足够精确的，因此使用Now分别在延时前后获取系统当前时间来进行耗时评估。
为使测试更具代表性，每个测试点测试100次，取算术平均值。
在1ms~100ms内，测试点步长为1ms，在100ms~1000ms内，测试点步长为10ms。
为尽可能减小干扰，测试过程中未使用Application.ProcessMessages;，也未使用并行。
测试结果 XE10编译，Win10下运行，经过近5个小时的测试，结果终于出炉了。
延时(ms) Sleep GetTickCount Timer 1 1.70 15.58 15.64 2 2.</description>
    </item>
    <item>
      <title>从Delphi到Go——方法</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_method/</link>
      <pubDate>Mon, 02 Dec 2019 22:56:02 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_method/</guid>
      <description>从其它平台迁移而来
结构体的方法 Delphi Delphi结构体的方法与类的方法几乎是一致的，主要区别是内存的管理方式和可见性不同。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义 type TMyStruct = record No: Integer; Name: string; function ToString: string; end; //实现 function TMyStruct.ToString: string; begin Result := Format(&amp;#39;No:%d, Name:%s&amp;#39;, [Self.No, Self.Name]); end; //调用 var ms: TMyStruct; s: string; begin s := ms.ToString; end; Go 方法其实就是加了接收器的函数，语法如下：
1 2 3 func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) { 函数体 } Go结构体的方法无需声明，直接实现即可。</description>
    </item>
    <item>
      <title>从Delphi到Go——异常处理</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_except/</link>
      <pubDate>Sun, 01 Dec 2019 22:35:02 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_except/</guid>
      <description>从其它平台迁移而来
Delphi try&amp;hellip;finally&amp;hellip;end 1 2 3 4 5 6 //创建、打开、加锁等 try //具体处理 finally //释放、关闭、解锁等 end; raise 1 raise Exception.Create(&amp;#39;异常信息&amp;#39;); //手动抛出异常 try&amp;hellip;except&amp;hellip;end 1 2 3 4 5 6 7 8 9 try //可能产生异常的语句块 except //异常的相关处理 on E: Exception do begin //对应类型的异常的处理 end; end; Go defer 加defer的语句会延迟到函数调用结束返回时才执行，相当于finally...end区。存在多个defer语句时，最先出现的总是最后才执行。
1 2 3 4 5 func F(){ //打开、加锁等 defer //关闭、解锁等 //具体处理 } panic 1 panic(异常信息) recover 1 2 3 4 5 6 7 func FF(){ defer func(){ e := recover() //异常处理 }() //可能产生异常的语句块，或调用 panic() 抛出异常 } 虽然panic/recover组合可以模拟try.</description>
    </item>
    <item>
      <title>从Delphi到Go——函数的可变参数</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_func_args/</link>
      <pubDate>Wed, 27 Nov 2019 22:24:05 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_func_args/</guid>
      <description>从其它平台迁移而来
Delphi 事实上，Delphi并没有什么可以直接为函数传递可变参数（数量可变、类型可变）的语法，但是并不是说不可能实现，最常用的Format()函数就是最好的例子。
虽然不能直接传递可变参数，但是通过一种叫做可变类型的开放数组即可实现为函数传递数量不定、类型不一的可变参数。
可变类型 可变类型不是变体类型，而是一个记录类型TVarRec，在System单元中的定义如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 TVarRec = record { do not pack this record; it is compiler-generated } case Integer of 0: (case Byte of vtInteger: (VInteger: Integer); vtBoolean: (VBoolean: Boolean); vtChar: (VChar: _AnsiChr); vtExtended: (VExtended: PExtended); {$IFNDEF NEXTGEN} vtString: (VString: _PShortStr); {$ENDIF !</description>
    </item>
    <item>
      <title>从Delphi到Go——匿名函数</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_func/</link>
      <pubDate>Sun, 03 Nov 2019 12:14:24 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_func/</guid>
      <description>从其它平台迁移而来
早期的Delphi版本是没有匿名函数的，不过可以定义一个函数类型来实现类似的功能；后期的版本已经支持匿名函数，随用随写。Go天生就支持匿名函数。
Delphi 函数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //声明函数类型 type TMyProc = procedure(A: Integer); //过程 TMyFunc = function(x: Integer): Integer; //函数 //定义符合函数类型的函数 procedure MyProc(A: Integer); begin ShowMessage(IntToHex(A)); end; function MyFunc1(x: Integer): Integer; begin Result := x + x; end; function MyFunc2(x: Integer): Integer; begin Result := x * x; end; //使用 var mp: TMyProc; mf: TMyFunc; begin mp := MyProc; mf := MyFunc1; mp(mf(99)); end; //作为参数进行传递，这才是函数类型最主要的使用方法 procedure Test(x: Integer; Func: TMyFunc); begin ShowMessage(Func(x).</description>
    </item>
    <item>
      <title>从Delphi到Go——列表</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_list/</link>
      <pubDate>Wed, 30 Oct 2019 21:58:48 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_list/</guid>
      <description>从其它平台迁移而来
Delphi中最基本的列表是TList类和TList&amp;lt;T&amp;gt;泛型类，还有线程安全的TThreadList类和TThreadList&amp;lt;T&amp;gt;泛型类，底层实现是数组。Go用的是container/list包，内部实现是双向链表。
Delphi TList TList里存的是指针，使用时注意处理好指针即可。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //声明 var l: TList; //构造 l := TList.Create; //添加 l.Add(p); //元素个数 n := l.Count; //列表容量 cap := l.Capacity; //取值 p1 := l.Items[0]; p2 := l.Extract(p1); //找到指针p1并从列表中取出，列表中将不再有p1，若其后还有元素，则前移填充空缺。 p := l.First; //取第一个元素 p := l.Last; //取最后一个元素 //查找元素的索引 i := l.IndexOf(p); //修改 l.</description>
    </item>
    <item>
      <title>从Delphi到Go——字典</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_map/</link>
      <pubDate>Mon, 28 Oct 2019 22:09:02 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_map/</guid>
      <description>从其它平台迁移而来
字典，又称为哈希表，是一种能够快速寻找值的理想结构。Go语言中对应的数据类型是map，Delphi中是TDictionary泛型类。
声明 Delphi
1 2 uses System.Generics.Collections; var 字典名: TDictionary&amp;lt;键类型, 值类型&amp;gt;; Go
1 var 字典名 map[键类型]值类型 初始化 Delphi
1 字典名 := TDictionary&amp;lt;键类型, 值类型&amp;gt;.Create(初始容量); Go
1 2 3 4 //使用make构造 字典名 = make(map[键类型]值类型, 初始容量) //直接赋初值 字典名 = map[键类型]值类型{键1: 值1, 键2: 值2} 元素操作 Delphi
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 var m: TDictionary&amp;lt;Integer, string&amp;gt;; //构造 m := TDictionary&amp;lt;Integer, string&amp;gt;.</description>
    </item>
    <item>
      <title>从Delphi到Go——数组</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_array/</link>
      <pubDate>Tue, 08 Oct 2019 22:03:53 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_array/</guid>
      <description>从其它平台迁移而来
静态数组 一维数组 声明 Delphi
1 var 数组名 : array[索引范围] of 元素类型; //索引范围是子界类型，格式为：下限..上限 Go
1 var 数组名 [数组长度]元素类型 Delphi的索引范围可以是任意的子界类型，而且是包含上下限的闭区间。子界可以是任意的序数类型（整型、字符型、枚举元素等），例如：0..8、5..11、&#39;a&#39;..&#39;z&#39;等。子界元素就是数组元素的下标。
Go的数组长度只能是整型，下标为0~数组长度-1。
初始化 Delphi
1 2 var 数组名 : array[1..N] of 元素类型 = (元素1, 元素2, ……, 元素N); //如果先声明后赋值的话，赋值时就需要遍历数组对每个元素分别赋值 Go
1 2 3 4 5 6 7 8 9 10 11 var 数组名 [N]元素类型 = [N]元素类型{元素0, 元素1, ……, 元素N-1} //由于初始化时元素个数已知，以上代码也可写为： var 数组名 [N]元素类型 = [...]元素类型{元素0, 元素1, ……, 元素N-1} //如果先声明后赋值的话，写法如下： var 数组名 [N]元素类型 数组名 = [.</description>
    </item>
    <item>
      <title>再探Delphi字符串</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_string02/</link>
      <pubDate>Sun, 06 Oct 2019 04:43:45 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_string02/</guid>
      <description>从其它平台迁移而来
闲来无事，又开始扒拉起Delphi的源码，这次发现一个比较有意思的函数StringCodePage，作用是返回传入字符串的CodePage。至于什么是CodePage，暂且认为是字符编码吧。
先测试一把：
1 2 3 4 5 6 7 8 9 10 11 12 13 var s1: AnsiString; s2: WideString; s3: UTF8String; cp1, cp2, cp3: Word; begin s1 := &amp;#39;123abc中国&amp;#39;; s2 := &amp;#39;123abc中国&amp;#39;; s3 := &amp;#39;123abc中国&amp;#39;; cp1 := StringCodePage(s1); //936 - GBK(简体中文) cp2 := StringCodePage(s2); //1200 - UCS-2LE Unicode 小端序 cp3 := StringCodePage(s3); //65001 - UTF-8 Unicode end; 来看下是怎么实现的：
1 2 3 4 5 6 7 function StringCodePage(const S: UnicodeString): Word; overload; begin if S &amp;lt;&amp;gt; &amp;#39;&amp;#39; then Result := PWord(PByte(S) - 12)^ // StrRec.</description>
    </item>
    <item>
      <title>从Delphi到Go——基础</title>
      <link>https://afrusrsc.github.io/posts/program/go/go_delphi_base/</link>
      <pubDate>Mon, 09 Sep 2019 23:30:04 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/go/go_delphi_base/</guid>
      <description>从其它平台迁移而来
废话 长期从事Delphi开发，虽不敢说精通，但说很熟悉还是相当有自信的。不过，只会一门语言，而且还是这么老的语言，更是在大天朝很小众的语言，总感觉自己离饿死街头没多远了，所以趁着还没老再学个潮点的吧。
先前考虑过Python，初步了解后觉得不太适合自己：
解释型语言：部署时得先搞个运行环境，发布的程序就是源码本身，再加上这个执行效率，怎么想都还是编译型语言更合适。
动态语言：无需声明，拿来就用，这已经很不合习惯了。想想一个变量，前一秒还是浮点数，下一秒就成字符串了，再一眨眼又成某个对象了……虽然一般不会有人这么写，但是挡不住手误啊，还是把这种小细节交给编译器更让人放心。
所以，对于有点强迫症和洁癖的自己，最后还是选了Go，比较符合已有的编程习惯，学习成本应该相对会低些吧。
至于Go嘛，想学是已经很久了，但由于种种原因却迟迟未开启，不过终究还是要迈出这一步的，所以就搞这么个系列来记录吧，一方面算是自我督促，另一方面也算是一种交流吧，当然，若一不留神帮上了谁，那自是开心极了。
言归正传 已经初步了解过了Go，说来和Delphi还是有不少相似之处呢，从Delphi转向Go应该会比较轻松吧。
工程结构 Delphi的工程算是比较自由的，源码的话，只要把单元路径引了或是直接包含进工程单元里就可以了，编译出的dcu和最终的exe指定下路径也就没问题了，通常我都使用下面这种结构：
1 2 3 4 5 6 7 8 9 10 11 Project/ bin/ src/ dcu/ mod1/ *.dfm *.pas mod2/ *.dfm *.pas *.dpr 不过，每一个工程都要设置，而且我习惯将Debug和Release设置完全一样，也还真是够烦的。
Go就没得选了，只有一种结构：
1 2 3 4 5 6 7 8 9 10 11 Project/ bin/ pkg/ src/ *.go mod1/ *.go *_test.go mod2/ *.go *_test.go 整体和我原有的习惯差不多，还是蛮容易接受的，不过倒是要把这Project的路径加入到GOPATH系统变量里让人有一点小不爽。但是Go可以直接把测试都写了，这点还是蛮让我惊喜的，毕竟用了这么多年Delphi也没写过一行像样的测试。
源码结构 Delphi典型的源码结构是这样：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 unit Unit1; interface uses .</description>
    </item>
    <item>
      <title>关于TField.DataSize的坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_field_datasize/</link>
      <pubDate>Thu, 11 Jul 2019 20:03:00 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_field_datasize/</guid>
      <description>从其它平台迁移而来
在从数据库中查询数据时，有时需要事先取得字段内容的大小，再根据情况进行处理。
对于ADO之类返回TField类型的，可以使用DataSize属性，但是！！！这里有很深的坑！！！。
首先看如下代码：
1 2 3 4 if ADOQuery.FieldByName(&amp;#39;Test&amp;#39;).DataSize &amp;gt; 3 then {处理1} else {处理2}; 按预想，当Test字段里的数据超过3B时，应该执行处理1的代码，但事实上无论该内容长短，都是执行处理2的代码，WHY?
扒一下Delphi的源码就明白了。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 function TField.</description>
    </item>
    <item>
      <title>Delphi安全结束线程</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_thread/</link>
      <pubDate>Sun, 28 Apr 2019 19:13:48 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_thread/</guid>
      <description>从其它平台迁移而来
在开发过程中，不可避免的要用到多线程，而线程的同步、释放等又可能引入新的问题，不过网上已有许多资料，这里重点说下我使用的方法。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 type TMyThread = class(TThread) protected procedure Execute; override; public constructor Create(...); destructor Destroy; override; //使用 reintroduce 关键字可以明确通知编译器屏蔽父类的同名方法而使用自己的方法。 procedure Free; reintroduce; end; constructor TMyThread.Create(...); begin { 在这里创建相关对象，可以省去先挂起线程再恢复的操作 } inherited Create; end; destructor TMyThread.</description>
    </item>
    <item>
      <title>关于窗口置屏的那个坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_screen_monitor/</link>
      <pubDate>Fri, 01 Mar 2019 16:16:46 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_screen_monitor/</guid>
      <description>从其它平台迁移而来
在开发多屏应用程序的时候，经常需要把某个窗口置到某个屏上的某个位置。以下是一个Delphi写的置屏方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 procedure ShowInMonitor(Sender: TObject; AIndex: Integer; ALeft: Integer = 0; ATop: Integer = 0); var lM: TMonitor; begin if Sender is TControl then begin if AIndex &amp;gt; Screen.MonitorCount - 1 then begin AIndex := 0; end; lM := Screen.Monitors[AIndex]; (Sender as TControl).Left := lM.Left + ALeft; (Sender as TControl).Top := lM.Top + ATop; end; end; Sender是需要置屏的窗口；AIndex是置屏的目标屏号，从0开始；ALeft是水平偏移量，ATop是垂直偏移量，默认均为0，即在目标屏的左上角。</description>
    </item>
    <item>
      <title>DBGridEh显示、编辑标记字段</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/ehlib_dbgrideh_field_dict/</link>
      <pubDate>Fri, 25 Jan 2019 11:37:40 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/ehlib_dbgrideh_field_dict/</guid>
      <description>从其它平台迁移而来
在用Delphi开发数据库应用过程中，经常需要用到DBBrid来显示或编辑数据库表，但相对于IDE自带的DBBrid，DBGridEh显然要更好用一些（cxDBGrid也同样好使，这里只对DBGridEh进行说明）。
在数据库表结构设计时，通常会习惯使用整型字段来存储如男、女、已修改、已删除、已作废等具有标记性的信息，好处是占存储空间小且可扩展性强，缺点是显示方式不友好，但是，使用DBGridEh的一些设置可以弥补这个缺陷。
假设数据库里的表T_Demo里有一个表示性别的字段Sex，其用0表示男，1表示女，2表示未知，用DBGridEh显示时仍为0、1、2，十分不友好。这时只要做一点美化即可。
在DBGridEh的对应列的KeyList属性里分别加入0、1、2三个数字，每个数字一行，用代码实现的话就是： 1 2 3 4 5 //这里假设第一列就是性别，以下代码相同 DBGridEh.Columns[0].KeyList.Clear; DBGridEh.Columns[0].KeyList.Append(&amp;#39;0&amp;#39;); DBGridEh.Columns[0].KeyList.Append(&amp;#39;1&amp;#39;); DBGridEh.Columns[0].KeyList.Append(&amp;#39;2&amp;#39;); 在DBGridEh的对应列的PickList属性里分别加入男、女、未知三行，用代码实现是： 1 2 3 4 DBGridEh.Columns[0].PickList.Clear; DBGridEh.Columns[0].PickList.Append(&amp;#39;男&amp;#39;); DBGridEh.Columns[0].PickList.Append(&amp;#39;女&amp;#39;); DBGridEh.Columns[0].PickList.Append(&amp;#39;未知&amp;#39;); 这样，原先显示为0、1、2的性别就变成了男、女、未知。也可以加上图片来进一步美化。
放置一个TImagList控件，并命名为ilSex，然后分别添加三个图片，比如像卫生间的男、女图片和问号，注意添加后图片对应的索引，否则会张冠李戴。
在DBGridEh的ImagList属性里关联ilSex，并且设置ShowImageAndText属性为True，用代码是：
1 2 DBGridEh.ImagList := ilSex; DBGridEh.ShowImageAndText := True; 这样，性别这一列就有图片有文字，比0、1、2要友好很多，而且在编辑的时候也可以直接下拉进行选择来实现性别的录入。</description>
    </item>
    <item>
      <title>TClientDataSet的使用以及遇到的坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_clientdataset/</link>
      <pubDate>Sat, 12 Jan 2019 14:43:15 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_clientdataset/</guid>
      <description>从其它平台迁移而来
在Delphi未加入FireDAC之前，似乎是没有内存表控件的（也许有，可能我不知道吧），但是可以用TClientDataSet控件来做内存表使用，即使有了FireDAC可以使用TFDMemTable，我还是觉得TClientDataSet更好用一些。
做内存表使用 创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 with ClientDataSet do begin Close; //定义字段 with FieldDefs do begin Clear; Add(&amp;#39;Field1&amp;#39;, ftInteger, 0, False); Add(&amp;#39;Field2&amp;#39;, ftString, 0, False); ...... end; //创建结构 CreateDataSet; Open; end; 排序 在定义字段后，创建结构前，也可以指定排序字段。
1 IndexFieldNames := &amp;#39;Field1&amp;#39;; 做缓存使用 需要结合TDataSetProvider来使用。以下示例以使用ADO组件为例。
拉取数据 方法1 TDBGrid-&amp;gt;TDataSource-&amp;gt;TClientDataSet-&amp;gt;TDataSetProvider-&amp;gt;TADOQuery-&amp;gt;TADOConnection
1 2 3 4 5 6 7 ClientDataSet.ProviderName := DataSetProvider.Name; //设计器里设置过就不需要了 with ClientDataSet do begin Close; CommandText:=&amp;#39;select * from T_Table&amp;#39;; Open; end; 方法2 TDBGrid-&amp;gt;TDataSource</description>
    </item>
    <item>
      <title>使用海康威视SDK的那些坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/sdk_hcnetsdk/</link>
      <pubDate>Wed, 02 Jan 2019 16:29:46 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/sdk_hcnetsdk/</guid>
      <description>从其它平台迁移而来
由于工作需要，项目中有使用到海康威视的产品，不可避免的就要使用海康的SDK进行二次开发。开发过程中磕磕绊绊的，踩了不少坑，这里做一个简单的记录，算是给健忘的自己提个醒吧。
Delphi版本的接口 Gitee地址
首先，自己一直使用Delphi进行开发，然而海康官方只提供了C/C++的接口和示例，无奈只能自己改写了。改写完的部分已经上传，希望能有人共同来完善。
由于Delphi商业使用的限制，现已转到Lazarus，全面拥抱开源。
坑 播放声音 预览时播放声音，回放时播放声音，甚至使用播放库播放已下载的视频时播放声音，这些对于前端摄像头自带麦克的场景肯定是刚需（另接麦克的情况暂未测试），然而按照官方SDK文档和示例代码写出的程序死活就是没有声音，这样的情况似乎不少人都遇到过，但是，好像并没有见谁把解决方法公开过。
其实，这个问题特别简单，只需要把HCNetSDKCom目录下的OpenAL32.dll拷贝到PlayCtrl.dll所在的目录下就可以了。这下就明白了吧，没有声音的原因其实就是使用NET_DVR_OpenSound调了PlayCtrl.dll，而PlayCtrl.dll又调了OpenAL32.dll来播放声音，但是由于PlayCtrl.dll没有找到OpenAL32.dll所以没有声音，而且这个有问题的返回值也并没有一层层的返回给NET_DVR_OpenSound函数，结果就是函数返回调用成功了，但就是死活没声音。
PlayCtrl.dll不是PlayCtrl.dll 使用海康SDK进行二次开发的，一般也会使用到海康的播放库，但是有一个问题是需要注意的，那就是SDK里的PlayCtrl.dll并不是播放库里的PlayCtrl.dll。虽然它们长得一样，名字也一样，但它们的本质却是完全不一样的，是不能互相替代的！有兴趣的朋友可以使用eXeScope详细查看。</description>
    </item>
    <item>
      <title>Delphi自定义图形控件的自定义字体属性在设计期报错的解决办法</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_custom_graphic_control/</link>
      <pubDate>Tue, 02 Oct 2018 02:40:14 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_custom_graphic_control/</guid>
      <description>从其它平台迁移而来
背景 自定义一个图形控件（继承自TGraphicControl类），需要在不同区域显示不同字体的内容，此时会需要在设计器中加入多个字体，方法是在控件的published区增加对应的字体属性即可（使用Ctrl+Shift+C可快速生成），如：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 TMyGraphicControl = class(GraphicControl) private FText1Font: TFont; FText2Font: TFont; procedure SetText1Font(const Value: TFont); procedure SetText2Font(const Value: TFont); protected procedure Paint; override; public { public declarations } published property Text1Font:TFont read FText1Font write SetText1Font; property Text2Font:TFont read FText2Font write SetText2Font; end; 这样就可以在设计器里像使用原生控件一样使用自己的控件了。
问题 但是，如果在设计期选择了弹出字体对话框进行设置字体，IDE就会报错（大意是读或写某个地址异常），而在运行期则正常！
原因 对比查看Delphi自带的控件源码，终于找到了原因。
1 2 3 4 5 6 7 8 9 10 //Delphi TControl类设置字体属性的方法 procedure TControl.</description>
    </item>
    <item>
      <title>Delphi版本号对照表</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_version/</link>
      <pubDate>Sun, 12 Aug 2018 15:52:38 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_version/</guid>
      <description>从其它平台迁移而来
Conditional VER Product Product Version Package Version VER330 Delphi / C++Builder XE10.3 Rio 26 260 VER320 Delphi / C++Builder XE10.2 Tokyo 25 250 VER310 Delphi / C++Builder XE10.1 Berlin 24 240 VER300 Delphi / C++Builder XE10 Seattle 23 230 VER290 Delphi / C++Builder XE8 22 220 VER280 Delphi / C++Builder XE7 21 210 VER270 Delphi / C++Builder XE6 20 200 VER260 Delphi / C++Builder XE5 19 190 VER250 Delphi / C++Builder XE4 18 180 VER240 Delphi / C++Builder XE3 17 170 VER230 Delphi / C++Builder XE2 16 160 VER220 Delphi / C++Builder XE 15 150 VER210 Delphi / C++Builder 2010 14 140 VER200 Delphi / C++Builder 2009 12 120 VER190 Delphi 2007 for .</description>
    </item>
    <item>
      <title>使用FireDAC的TFDQuery查询Firebird遇到的坑</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/firedac_fdquery_firebird/</link>
      <pubDate>Wed, 03 Jan 2018 01:43:02 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/firedac_fdquery_firebird/</guid>
      <description>从其它平台迁移而来
这几天被Prepare这个东西搞死了，虽然用它解决了目前的问题，但是完全不知道为什么，如有大侠知道还望指教，不胜感激！
首先，说下开发环境：
win10 x64(1709 [10.0.16299.125])+Delphi XE7 up1(自带FireDAC)+Firebird 3.0.2.32703_0(数据库字符集使用UTF8)
问题一：中文模糊查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var CompanyType: Integer FDQuery1.Close; FDQuery1.SQL.Text := &amp;#39;SELECT * FROM companyinfo &amp;#39; + &amp;#39;WHERE (tag = 0) AND (companytype = :companytype) AND &amp;#39; + &amp;#39;((companyname LIKE :Text) OR (pym LIKE :Text))&amp;#39; + &amp;#39; ORDER BY TIMES DESC&amp;#39;; //FDQuery1.Prepare; //写在这里会报错，提示如下，大致意思是： //数据库 companytype 字段是SmallInt类型，却赋了一个Integer类型的值 {--------------------------- [FireDAC][Phys][FB]-338.</description>
    </item>
    <item>
      <title>cxGrid基本用法小记</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/devexpress_cxgrid/</link>
      <pubDate>Sat, 25 Nov 2017 20:41:33 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/devexpress_cxgrid/</guid>
      <description>从其它平台迁移而来
汉化 在DevExpress选项卡找到TcxLocalizer控件放到窗体上，为了通用，我是放到DataModule窗体上。 准备好汉化的资源文件或配置文件（我使用的是后者），在DataModule的Create事件里写上如下代码 1 2 3 4 5 6 7 with cxLocalizer1 do begin StorageType := lstIni; LoadFromFile(IniPath + &amp;#39;DevChs.ini&amp;#39;); locale := 2052; Active := True; end; 在有cxGrid或其实Dev控件的单元引用DataModule单元。 更改视觉样式 在DevExpress选项卡找到TcxLookAndFeelController控件放到DataModule窗体上。
在有cxGrid或其它Dev控件的单元引用DataModule单元。
在要更改视觉样式的代码段里设置TcxLookAndFeelController控件的Kind属性和NativeStyle属性。
让cxGrid的数据以斑马线的方式显示，即奇偶行分别使用不同样式 在DevExpress选项卡找到TcxStyleRepository控件放到DataModule窗体上。
双击cxStyleRepository控件，打开如下窗口，点Add添加两个样式，并命名。
分别在属性中设置不同的样式，颜色、字体、字号、字体颜色等。 在有cxGrid的单元中引用DataModule单元。
选中cxGrid的cxGridDBTableView，展开Styles，分别关联ContentEven和ContentOdd。
另外也可设置Header、Selection和Inactive。Header改变的是表头的样式，Selection改变的是当前选择行的样式，Inactive改变的是cxGrid失去焦点时当前选择行的样式。
不显示分组框 设置cxGridDBTableView的OptionsView下的GroupByBox属性为False。
显示合计等脚注 设置cxGridDBTableView的OptionsView下的Footer属性为True。
点cxGrid的Customize...按钮，弹出对话框，选择Summary标签页，在Footer子标签页中点Add增加合计项目。
选择增加的项目，在属性中设置关联的列、字段名等属性。 设置行号 增加一列，不关联数据库字段，设置好属性。
在该列的OnGetDataText事件中写如下代码：
1 AText := IntToStr(ARecordIndex + 1); 编辑完成前光标不能离开当前行 在cxGridDBTableView的OnCanFocusRecord事件中写入类似以下的代码： 1 AAllow := DbState in [dsBrowse]; 只读 设置cxGridDBTableView.OptionsData.Editing属性为False。
选择整行 设置cxGridDBTableView.OptionsSelection.CellSelect属性为False。</description>
    </item>
    <item>
      <title>FireDAC之TFDStoredProc</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/firedac_fdstoredproc/</link>
      <pubDate>Fri, 24 Nov 2017 10:11:13 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/firedac_fdstoredproc/</guid>
      <description>从其它平台迁移而来
1.在FireDAC选项卡中找到TFDStoredProc控件，放到窗体上，并把Connection属性设置为准备好的数据库连接控件上。
2.在需要执行存储过程的位置写入类似以下的代码：
1 2 3 4 5 6 7 8 9 FDStoredProc1.StoredProcName := &amp;#39;SP_StoredProcName&amp;#39;; FDStoredProc1.Prepare; //必须，否则会报找不到参数的错误 FDStoredProc1.ParamByName(&amp;#39;I_ID&amp;#39;).AsInteger := id; //无返回值或返回值由输出参数传递时 FDStoredProc1.ExecProc; UserName := FDStoredProc1.ParamByName(&amp;#39;O_USERNAME&amp;#39;).AsString; //有返回值或数据集时 FDStoredProc1.Open(); UserName := FDStoredProc1.FindField(&amp;#39;O_USERNAME&amp;#39;).AsString; 3.以上为存储过程返回单个值或单条记录时的用法，存储过程返回多条记录（即数据表）的用法暂未研究。</description>
    </item>
    <item>
      <title>FirdDAC之TFDQuery使用</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/firedac_fdquery/</link>
      <pubDate>Thu, 23 Nov 2017 22:31:27 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/firedac_fdquery/</guid>
      <description> 从其它平台迁移而来
1.在FireDAC选项卡中找到TFDQuery控件，放到窗体上，并把Connection属性设置为准备好的数据库连接控件上。
2.在需要查询或执行SQL语句的位置写入类似以下的代码：
1 2 3 4 5 6 7 8 //查询，有返回集 FDQuery1.SQL.Text := &amp;#39;SELECT * FROM DBTable WHERE id = :id&amp;#39;; FDQuery1.ParamByName(&amp;#39;id&amp;#39;).AsInteger := 1; FDQuery1.Open(); //执行SQL语句，无返回集 FDQuery1.SQL.Text := &amp;#39;DELETE FROM DBTable WHERE id = :id&amp;#39;; FDQuery1.ParamByName(&amp;#39;id&amp;#39;).AsInteger := 1; FDQuery1.ExecSQL; 3.若查询结果需要连接到数据集，则在DataAccess选项卡中找到TDataSource控件，放到窗体上，并把DataSet属性连接到TFDQuery控件。然后把数据感知控件（如cxGrid等）的DataSource属性连接到TDataSource控件。
4.若只需要取出查询结果并进行后续处理，可使用如下代码取出结果：
1 2 3 id := FDQuery1.FindField(&amp;#39;id&amp;#39;).AsInteger; DeptName := FDQuery1.FindField(&amp;#39;deptname&amp;#39;).AsString; Money := FDQuery1.FindField(&amp;#39;money&amp;#39;).AsFloat; </description>
    </item>
    <item>
      <title>FireDAC连接数据库</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/firedac_fdconnection/</link>
      <pubDate>Wed, 22 Nov 2017 11:25:47 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/firedac_fdconnection/</guid>
      <description>从其它平台迁移而来
建立DataModule
在FireDAC选项卡中找到我们的主角TFDConnection控件，并放到DataModule窗体上，把LoginPrompt设为False，这样在连接时就不会弹出登陆对话框了。然后再找到TFDManager控件，也放到DataModule窗体上，并且把Active属性设为True，这样一来，在引用了本单元的其它单元中，就可以直接把FireDAC控件的Connection连接到本单元的TFDConnection了。
在FireDAC Links选项卡中找到所需要连接的数据的驱动链接控件，放到DataModule窗体上。本例中使用的是FireBird数据库，因此就选择了TFDPhysFBDriverLink，其它数据库参照执行（本人接触的数据库不多，各数据库间的差异不敢妄言，但整体使用思路和方法应是不差的）。 在FireDAC UI选项卡中找到TFDGUIxWaitCursor控件，放到DataModule窗体上。该控件其实只是个光标，可修改ScreenCursor属性来改变光标。 至此，拖控件的工作基本上就做完了，下面该写代码了（虽然代码中有相当一部分工作可以直接在设计器中修改属性来达到，但建议用代码来实现，一方面便于DEBUG，另一方面也易于进行数据库的变更、迁移等）。
在DataModule的Create事件中写入类似以下的代码（也可写在其它地主，但要保证必须在任何数据库操作代码前运行）： 1 2 3 4 5 6 7 8 9 10 11 12 FDPhysFBDriverLink1.VendorLib := DllPath + &amp;#39;fbclient.dll&amp;#39;; FDConnection1.Params.DriverID := &amp;#39;FB&amp;#39;; FDConnection1.Params.Database := HostName + &amp;#39;/&amp;#39; + DBPort + &amp;#39;:&amp;#39; + DBFilePathAndName; FDConnection1.Params.UserName := UserName; FDConnection1.Params.Password := Password; FDConnection1.Params.Add(&amp;#39;CharacterSet=utf8&amp;#39;); try FDConnection1.Open(); except on E:Exception do ShowMessage(E.Message); end; 注意：FDConnection1.Params.Add(&#39;CharacterSet=utf8&#39;);这句是设置客户端连接数据库是默认使用的字符集，一定要与所连接的数据库使用的默认字符集一致，否则将会发生很多奇怪的事情。而且该项无法在设计器的属性中进行设置！</description>
    </item>
    <item>
      <title>深入Delphi的字符串类型</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_string01/</link>
      <pubDate>Tue, 15 Aug 2017 23:17:53 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_string01/</guid>
      <description>从其它平台迁移而来
探索 之前提到了Delphi的字符串，但并未展开说，这里就详细探讨下Delphi的字符串类型。
废话不多说，直接上源码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 program StringTest; {$APPTYPE CONSOLE} uses SysUtils; var s1, s2, s3: string; begin Writeln(&amp;#39;Now time : &amp;#39;,FormatDateTime(&amp;#39;HH:MM:SS.</description>
    </item>
    <item>
      <title>Delphi中的数据类型</title>
      <link>https://afrusrsc.github.io/posts/program/pascal/delphi_type/</link>
      <pubDate>Sun, 13 Aug 2017 14:34:21 +0800</pubDate>
      <guid>https://afrusrsc.github.io/posts/program/pascal/delphi_type/</guid>
      <description>从其它平台迁移而来
之前一直使用的是Delphi 7，现在准备转向Delphi XE7，据说数据类型上有一些微小的调整，便想亲自验证一下，也顺便加深一下自己对Delphi数据类型的认识，毕竟之前仅仅是在用而从未考虑过类型在内存中的形态。
验证方法很简单，就是在控制台用Sizeof()把相应数据类型的字节数显示出来。源码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 program TypeSize; {$APPTYPE CONSOLE} uses SysUtils; type Emnu = (one, two, three, four); Range1 = $0.</description>
    </item>
  </channel>
</rss>
